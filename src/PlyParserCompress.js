import { Chunk } from './Chunk.js';
import { PlyParserCodecBase } from "./PlyParserCoDecBase";

export class PlyParserCompress extends PlyParserCodecBase {
  constructor() {
    super();
  }
  compress() {
    const splatData = this.splatData;
    const modelMat = Float32Array.from([
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ]);
    const encodeMorton3 = (x, y, z) => {
      const Part1By2 = (x) => {
        x &= 0x000003ff;
        x = (x ^ (x << 16)) & 0xff0000ff;
        x = (x ^ (x << 8)) & 0x0300f00f;
        x = (x ^ (x << 4)) & 0x030c30c3;
        x = (x ^ (x << 2)) & 0x09249249;
        return x;
      };

      return (Part1By2(z) << 2) + (Part1By2(y) << 1) + Part1By2(x);
    };
    const sortSplats = (indices) => {
      const x = this.getProp('x');
      const y = this.getProp('y');
      const z = this.getProp('z');

      const bx = this.calcMinMax(x, indices);
      const by = this.calcMinMax(y, indices);
      const bz = this.calcMinMax(z, indices);

      // generate morton codes
      const morton = indices.map((i) => {
        const ix = Math.floor(1024 * (x[i] - bx.min) / (bx.max - bx.min));
        const iy = Math.floor(1024 * (y[i] - by.min) / (by.max - by.min));
        const iz = Math.floor(1024 * (z[i] - bz.min) / (bz.max - bz.min));
        return encodeMorton3(ix, iy, iz);
      });

      // order splats by morton code
      indices.sort((a, b) => morton[a] - morton[b]);
    };

    // generate index list of surviving splats
    const opacity = this.getProp('opacity');
    const indices = [];
    for (let i = 0; i < splatData.count; ++i) {
      if (opacity[i] !== this.deletedOpacity) {
        indices.push(i);
      }
    }

    if (indices.length === 0) {
      console.error('nothing to export');
      return;
    }

    const numSplats = indices.length;
    const numChunks = Math.ceil(numSplats / 256);

    const chunkProps = ['min_x', 'min_y', 'min_z', 'max_x', 'max_y', 'max_z', 'min_scale_x', 'min_scale_y', 'min_scale_z', 'max_scale_x', 'max_scale_y', 'max_scale_z'];
    const vertexProps = ['packed_position', 'packed_rotation', 'packed_scale', 'packed_color'];
    const headerText = [
      [
        `ply`,
        `format binary_little_endian 1.0`,
        `comment generated by super-splat`,
        `element chunk ${numChunks}`
      ],
      chunkProps.map(p => `property float ${p}`),
      [
        `element vertex ${numSplats}`
      ],
      vertexProps.map(p => `property uint ${p}`),
      [
        `end_header\n`
      ]
    ].flat().join('\n');

    const header = (new TextEncoder()).encode(headerText);
    const result = new Uint8Array(header.byteLength + numChunks * chunkProps.length * 4 + numSplats * vertexProps.length * 4);
    const dataView = new DataView(result.buffer);

    result.set(header);

    const chunkOffset = header.byteLength;
    const vertexOffset = chunkOffset + numChunks * 12 * 4;

    const chunk = new Chunk(this.plyElements[0]);

    // sort splats into some kind of order
    sortSplats(indices);

    for (let i = 0; i < numChunks; ++i) {
      chunk.set(splatData, indices.slice(i * 256, (i + 1) * 256));
      chunk.transform(modelMat);

      const result = chunk.pack();

      // write chunk data
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 0, result.px.min, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 4, result.py.min, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 8, result.pz.min, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 12, result.px.max, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 16, result.py.max, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 20, result.pz.max, true);

      dataView.setFloat32(chunkOffset + i * 12 * 4 + 24, result.sx.min, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 28, result.sy.min, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 32, result.sz.min, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 36, result.sx.max, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 40, result.sy.max, true);
      dataView.setFloat32(chunkOffset + i * 12 * 4 + 44, result.sz.max, true);

      // write splat data
      let offset = vertexOffset + i * 256 * 4 * 4;
      const chunkSplats = Math.min(numSplats, (i + 1) * 256) - i * 256;
      for (let j = 0; j < chunkSplats; ++j) {
        dataView.setUint32(offset + j * 4 * 4 + 0, chunk.position[j], true);
        dataView.setUint32(offset + j * 4 * 4 + 4, chunk.rotation[j], true);
        dataView.setUint32(offset + j * 4 * 4 + 8, chunk.scale[j], true);
        dataView.setUint32(offset + j * 4 * 4 + 12, chunk.color[j], true);
      }
    }

    return result;
  };
}
