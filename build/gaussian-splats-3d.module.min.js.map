{"version":3,"file":"gaussian-splats-3d.module.min.js","sources":["../src/AbortablePromise.js","../src/Util.js","../src/loaders/UncompressedSplatArray.js","../src/Constants.js","../src/loaders/SplatBuffer.js","../src/loaders/ply/PlayCanvasCompressedPlyParser.js","../src/loaders/ply/PlyFormat.js","../src/loaders/ply/PlyParserUtils.js","../src/loaders/ply/INRIAV1PlyParser.js","../src/loaders/ply/INRIAV2PlyParser.js","../src/loaders/ply/PlyParser.js","../src/loaders/DirectLoadError.js","../src/loaders/InternalLoadType.js","../src/loaders/LoaderStatus.js","../src/loaders/SplatPartitioner.js","../src/loaders/SplatBufferGenerator.js","../src/loaders/ply/PlyLoader.js","../src/loaders/splat/SplatParser.js","../src/loaders/splat/SplatLoader.js","../src/loaders/ksplat/KSplatLoader.js","../src/loaders/SceneFormat.js","../src/loaders/Utils.js","../src/LogLevel.js","../src/OrbitControls.js","../src/RenderMode.js","../src/ArrowHelper.js","../src/SceneHelper.js","../src/SceneRevealMode.js","../src/SplatRenderMode.js","../src/loaders/splat/gltf/GLTFParser.js","../src/loaders/splat/gltf/GLTFLoader.js","../src/raycaster/Ray.js","../src/raycaster/Hit.js","../src/raycaster/Raycaster.js","../src/splatmesh/SplatMaterial.js","../src/splatmesh/SplatMaterial3D.js","../src/splatmesh/SplatMaterial2D.js","../src/splatmesh/SplatGeometry.js","../src/splatmesh/SplatScene.js","../src/splattree/SplatTree.js","../src/three-shim/WebGLExtensions.js","../src/three-shim/WebGLCapabilities.js","../src/splatmesh/SplatMesh.js","../src/ui/InfoPanel.js","../src/ui/LoadingProgressBar.js","../src/ui/LoadingSpinner.js","../src/ui/Util.js","../src/webxr/ARButton.js","../src/webxr/VRButton.js","../src/webxr/WebXRMode.js","../src/worker/sorter.wasm","../src/worker/sorter_no_simd.wasm","../src/worker/SortWorker.js","../src/Viewer.js","../src/worker/sorter_non_shared.wasm","../src/worker/sorter_no_simd_non_shared.wasm","../src/DropInViewer.js"],"sourcesContent":["/**\n * AbortablePromise: A quick & dirty wrapper for JavaScript's Promise class that allows the underlying\n * asynchronous operation to be cancelled. It is only meant for simple situations where no complex promise\n * chaining or merging occurs. It needs a significant amount of work to truly replicate the full\n * functionality of JavaScript's Promise class. Look at Util.fetchWithProgress() for example usage.\n *\n * This class was primarily added to allow splat scene downloads to be cancelled. It has not been tested\n * very thoroughly and the implementation is kinda janky. If you can at all help it, please avoid using it :)\n */\nexport class AbortablePromise {\n  static idGen = 0;\n\n  constructor(promiseFunc, abortHandler) {\n    let resolver;\n    let rejecter;\n    this.promise = new Promise((resolve, reject) => {\n      resolver = resolve;\n      rejecter = reject;\n    });\n\n    const promiseResolve = resolver.bind(this);\n    const promiseReject = rejecter.bind(this);\n\n    const resolve = (...args) => {\n      promiseResolve(...args);\n    };\n\n    const reject = (error) => {\n      promiseReject(error);\n    };\n\n    promiseFunc(resolve.bind(this), reject.bind(this));\n    this.abortHandler = abortHandler;\n    this.id = AbortablePromise.idGen++;\n  }\n\n  then(onResolve) {\n    return new AbortablePromise((resolve, reject) => {\n      this.promise = this.promise\n        .then((...args) => {\n          const onResolveResult = onResolve(...args);\n          if (\n            onResolveResult instanceof Promise ||\n            onResolveResult instanceof AbortablePromise\n          ) {\n            onResolveResult.then((...args2) => {\n              resolve(...args2);\n            });\n          } else {\n            resolve(onResolveResult);\n          }\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    }, this.abortHandler);\n  }\n\n  catch(onFail) {\n    return new AbortablePromise((resolve) => {\n      this.promise = this.promise\n        .then((...args) => {\n          resolve(...args);\n        })\n        .catch(onFail);\n    }, this.abortHandler);\n  }\n\n  abort(reason) {\n    if (this.abortHandler) this.abortHandler(reason);\n  }\n}\n\nexport class AbortedPromiseError extends Error {\n  constructor(msg) {\n    super(msg);\n  }\n}\n","import { AbortablePromise, AbortedPromiseError } from './AbortablePromise.js';\n\nexport const floatToHalf = (function() {\n  const floatView = new Float32Array(1);\n  const int32View = new Int32Array(floatView.buffer);\n\n  return function(val) {\n    floatView[0] = val;\n    const x = int32View[0];\n\n    let bits = (x >> 16) & 0x8000;\n    let m = (x >> 12) & 0x07ff;\n    const e = (x >> 23) & 0xff;\n\n    if (e < 103) return bits;\n\n    if (e > 142) {\n      bits |= 0x7c00;\n      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n      return bits;\n    }\n\n    if (e < 113) {\n      m |= 0x0800;\n      bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n      return bits;\n    }\n\n    bits |= ((e - 112) << 10) | (m >> 1);\n    bits += m & 1;\n    return bits;\n  };\n})();\n\nexport const uintEncodedFloat = (function() {\n  const floatView = new Float32Array(1);\n  const int32View = new Int32Array(floatView.buffer);\n\n  return function(f) {\n    floatView[0] = f;\n    return int32View[0];\n  };\n})();\n\nexport const rgbaToInteger = function(r, g, b, a) {\n  return r + (g << 8) + (b << 16) + (a << 24);\n};\n\nexport const rgbaArrayToInteger = function(arr, offset) {\n  return (\n    arr[offset] +\n    (arr[offset + 1] << 8) +\n    (arr[offset + 2] << 16) +\n    (arr[offset + 3] << 24)\n  );\n};\n\nexport const makeProgressiveFetchFunction =\n  (get = globalThis.fetch) =>\n  (path, onProgress, saveChunks = true) => {\n    const abortController = new AbortController();\n    const signal = abortController.signal;\n    let aborted = false;\n    const abortHandler = (reason) => {\n      abortController.abort(reason);\n      aborted = true;\n    };\n\n    return new AbortablePromise((resolve, reject) => {\n      get(path, { signal })\n        .then(async (data) => {\n          // Handle error conditions where data is still returned\n          if (!data.ok) {\n            const errorText = await data.text();\n            reject(\n              new Error(\n                `Fetch failed: ${data.status} ${data.statusText} ${errorText}`,\n              ),\n            );\n            return;\n          }\n\n          const reader = data.body.getReader();\n          let bytesDownloaded = 0;\n          let _fileSize = data.headers.get('Content-Length');\n          let fileSize = _fileSize ? parseInt(_fileSize) : undefined;\n\n          const chunks = [];\n\n          while (!aborted) {\n            try {\n              const { value: chunk, done } = await reader.read();\n              if (done) {\n                if (onProgress) {\n                  onProgress(100, '100%', chunk, fileSize);\n                }\n                if (saveChunks) {\n                  const buffer = new Blob(chunks).arrayBuffer();\n                  resolve(buffer);\n                } else {\n                  resolve();\n                }\n                break;\n              }\n              bytesDownloaded += chunk.length;\n              let percent;\n              let percentLabel;\n              if (fileSize !== undefined) {\n                percent = (bytesDownloaded / fileSize) * 100;\n                percentLabel = `${percent.toFixed(2)}%`;\n              }\n              if (saveChunks) {\n                chunks.push(chunk);\n              }\n              if (onProgress) {\n                onProgress(percent, percentLabel, chunk, fileSize);\n              }\n            } catch (error) {\n              reject(error);\n              return;\n            }\n          }\n        })\n        .catch((error) => {\n          reject(new AbortedPromiseError(error));\n        });\n    }, abortHandler);\n  };\n\nexport const fetchWithProgress = makeProgressiveFetchFunction();\n\nexport const clamp = function(val, min, max) {\n  return Math.max(Math.min(val, max), min);\n};\n\nexport const getCurrentTime = function() {\n  return performance.now() / 1000;\n};\n\nexport const disposeAllMeshes = (object3D) => {\n  if (object3D.geometry) {\n    object3D.geometry.dispose();\n    object3D.geometry = null;\n  }\n  if (object3D.material) {\n    object3D.material.dispose();\n    object3D.material = null;\n  }\n  if (object3D.children) {\n    for (let child of object3D.children) {\n      disposeAllMeshes(child);\n    }\n  }\n};\n\nexport const delayedExecute = (func, fast) => {\n  return new Promise((resolve) => {\n    window.setTimeout(\n      () => {\n        resolve(func());\n      },\n      fast ? 1 : 50,\n    );\n  });\n};\n\nexport const getSphericalHarmonicsComponentCountForDegree = (\n  sphericalHarmonicsDegree = 0,\n) => {\n  switch (sphericalHarmonicsDegree) {\n    case 1:\n      return 9;\n    case 2:\n      return 24;\n  }\n  return 0;\n};\n\nexport const nativePromiseWithExtractedComponents = () => {\n  let resolver;\n  let rejecter;\n  const promise = new Promise((resolve, reject) => {\n    resolver = resolve;\n    rejecter = reject;\n  });\n  return {\n    promise: promise,\n    resolve: resolver,\n    reject: rejecter,\n  };\n};\n\nexport const abortablePromiseWithExtractedComponents = (abortHandler) => {\n  let resolver;\n  let rejecter;\n  if (!abortHandler) {\n    abortHandler = () => {};\n  }\n  const promise = new AbortablePromise((resolve, reject) => {\n    resolver = resolve;\n    rejecter = reject;\n  }, abortHandler);\n  return {\n    promise: promise,\n    resolve: resolver,\n    reject: rejecter,\n  };\n};\n\nclass Semver {\n  constructor(major, minor, patch) {\n    this.major = major;\n    this.minor = minor;\n    this.patch = patch;\n  }\n\n  toString() {\n    return `${this.major}_${this.minor}_${this.patch}`;\n  }\n}\n\nexport function isIOS() {\n  const ua = navigator.userAgent;\n  return ua.indexOf('iPhone') > 0 || ua.indexOf('iPad') > 0;\n}\n\nexport function getIOSSemever() {\n  if (isIOS()) {\n    const extract = navigator.userAgent.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    return new Semver(\n      parseInt(extract[1] || 0, 10),\n      parseInt(extract[2] || 0, 10),\n      parseInt(extract[3] || 0, 10),\n    );\n  } else {\n    return null; // or [0,0,0]\n  }\n}\n","import { getSphericalHarmonicsComponentCountForDegree } from '../Util.js';\n\nconst BASE_COMPONENT_COUNT = 14;\n\nexport class UncompressedSplatArray {\n  static OFFSET = {\n    X: 0,\n    Y: 1,\n    Z: 2,\n    SCALE0: 3,\n    SCALE1: 4,\n    SCALE2: 5,\n    ROTATION0: 6,\n    ROTATION1: 7,\n    ROTATION2: 8,\n    ROTATION3: 9,\n    FDC0: 10,\n    FDC1: 11,\n    FDC2: 12,\n    OPACITY: 13,\n    FRC0: 14,\n    FRC1: 15,\n    FRC2: 16,\n    FRC3: 17,\n    FRC4: 18,\n    FRC5: 19,\n    FRC6: 20,\n    FRC7: 21,\n    FRC8: 22,\n    FRC9: 23,\n    FRC10: 24,\n    FRC11: 25,\n    FRC12: 26,\n    FRC13: 27,\n    FRC14: 28,\n    FRC15: 29,\n    FRC16: 30,\n    FRC17: 31,\n    FRC18: 32,\n    FRC19: 33,\n    FRC20: 34,\n    FRC21: 35,\n    FRC22: 36,\n    FRC23: 37,\n  };\n\n  constructor(sphericalHarmonicsDegree = 0) {\n    this.sphericalHarmonicsDegree = sphericalHarmonicsDegree;\n    this.sphericalHarmonicsCount = getSphericalHarmonicsComponentCountForDegree(\n      this.sphericalHarmonicsDegree,\n    );\n    this.componentCount = this.sphericalHarmonicsCount + BASE_COMPONENT_COUNT;\n    this.defaultSphericalHarmonics = new Array(\n      this.sphericalHarmonicsCount,\n    ).fill(0);\n    this.splats = [];\n    this.splatCount = 0;\n  }\n\n  static createSplat(sphericalHarmonicsDegree = 0) {\n    const baseSplat = [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];\n    let shEntries = getSphericalHarmonicsComponentCountForDegree(\n      sphericalHarmonicsDegree,\n    );\n    for (let i = 0; i < shEntries; i++) baseSplat.push(0);\n    return baseSplat;\n  }\n\n  addSplat(splat) {\n    this.splats.push(splat);\n    this.splatCount++;\n  }\n\n  getSplat(index) {\n    return this.splats[index];\n  }\n\n  addDefaultSplat() {\n    const newSplat = UncompressedSplatArray.createSplat(\n      this.sphericalHarmonicsDegree,\n    );\n    this.addSplat(newSplat);\n    return newSplat;\n  }\n\n  addSplatFromComonents(\n    x,\n    y,\n    z,\n    scale0,\n    scale1,\n    scale2,\n    rot0,\n    rot1,\n    rot2,\n    rot3,\n    r,\n    g,\n    b,\n    opacity,\n    ...rest\n  ) {\n    const newSplat = [\n      x,\n      y,\n      z,\n      scale0,\n      scale1,\n      scale2,\n      rot0,\n      rot1,\n      rot2,\n      rot3,\n      r,\n      g,\n      b,\n      opacity,\n      ...this.defaultSphericalHarmonics,\n    ];\n    for (let i = 0; i < rest.length && i < this.sphericalHarmonicsCount; i++) {\n      newSplat[i] = rest[i];\n    }\n    this.addSplat(newSplat);\n    return newSplat;\n  }\n\n  addSplatFromArray(src, srcIndex) {\n    const srcSplat = src.splats[srcIndex];\n    const newSplat = UncompressedSplatArray.createSplat(\n      this.sphericalHarmonicsDegree,\n    );\n    for (let i = 0; i < this.componentCount && i < srcSplat.length; i++) {\n      newSplat[i] = srcSplat[i];\n    }\n    this.addSplat(newSplat);\n  }\n}\n","export class Constants {\n  static DefaultSplatSortDistanceMapPrecision = 16;\n  static MemoryPageSize = 65536;\n  static BytesPerFloat = 4;\n  static BytesPerInt = 4;\n  static MaxScenes = 32;\n  static ProgressiveLoadSectionSize = 262144;\n  static ProgressiveLoadSectionDelayDuration = 15;\n  static SphericalHarmonics8BitCompressionRange = 3;\n}\n","import * as THREE from 'three';\nimport { UncompressedSplatArray } from './UncompressedSplatArray.js';\nimport {\n  clamp,\n  getSphericalHarmonicsComponentCountForDegree,\n} from '../Util.js';\nimport { Constants } from '../Constants.js';\n\nconst DefaultSphericalHarmonics8BitCompressionRange =\n  Constants.SphericalHarmonics8BitCompressionRange;\nconst DefaultSphericalHarmonics8BitCompressionHalfRange =\n  DefaultSphericalHarmonics8BitCompressionRange / 2.0;\n\nconst toHalfFloat = THREE.DataUtils.toHalfFloat.bind(THREE.DataUtils);\nconst fromHalfFloat = THREE.DataUtils.fromHalfFloat.bind(THREE.DataUtils);\n\nconst toUncompressedFloat = (\n  f,\n  compressionLevel,\n  isSH = false,\n  range8BitMin,\n  range8BitMax,\n) => {\n  if (compressionLevel === 0) {\n    return f;\n  } else if (compressionLevel === 1 || (compressionLevel === 2 && !isSH)) {\n    return THREE.DataUtils.fromHalfFloat(f);\n  } else if (compressionLevel === 2) {\n    return fromUint8(f, range8BitMin, range8BitMax);\n  }\n};\n\nconst toUint8 = (v, rangeMin, rangeMax) => {\n  v = clamp(v, rangeMin, rangeMax);\n  const range = rangeMax - rangeMin;\n  return clamp(Math.floor(((v - rangeMin) / range) * 255), 0, 255);\n};\n\nconst fromUint8 = (v, rangeMin, rangeMax) => {\n  const range = rangeMax - rangeMin;\n  return (v / 255) * range + rangeMin;\n};\n\nconst fromHalfFloatToUint8 = (v, rangeMin, rangeMax) => {\n  return toUint8(fromHalfFloat(v, rangeMin, rangeMax));\n};\n\nconst fromUint8ToHalfFloat = (v, rangeMin, rangeMax) => {\n  return toHalfFloat(fromUint8(v, rangeMin, rangeMax));\n};\n\nconst dataViewFloatForCompressionLevel = (\n  dataView,\n  floatIndex,\n  compressionLevel,\n  isSH = false,\n) => {\n  if (compressionLevel === 0) {\n    return dataView.getFloat32(floatIndex * 4, true);\n  } else if (compressionLevel === 1 || (compressionLevel === 2 && !isSH)) {\n    return dataView.getUint16(floatIndex * 2, true);\n  } else {\n    return dataView.getUint8(floatIndex, true);\n  }\n};\n\nconst convertBetweenCompressionLevels = (function() {\n  const noop = (v) => v;\n\n  return function(val, fromLevel, toLevel, isSH = false) {\n    if (fromLevel === toLevel) return val;\n    let outputConversionFunc = noop;\n\n    if (fromLevel === 2 && isSH) {\n      if (toLevel === 1) outputConversionFunc = fromUint8ToHalfFloat;\n      else if (toLevel == 0) {\n        outputConversionFunc = fromUint8;\n      }\n    } else if (fromLevel === 2 || fromLevel === 1) {\n      if (toLevel === 0) outputConversionFunc = fromHalfFloat;\n      else if (toLevel == 2) {\n        if (!isSH) outputConversionFunc = noop;\n        else outputConversionFunc = fromHalfFloatToUint8;\n      }\n    } else if (fromLevel === 0) {\n      if (toLevel === 1) outputConversionFunc = toHalfFloat;\n      else if (toLevel == 2) {\n        if (!isSH) outputConversionFunc = toHalfFloat;\n        else outputConversionFunc = toUint8;\n      }\n    }\n\n    return outputConversionFunc(val);\n  };\n})();\n\nconst copyBetweenBuffers = (\n  srcBuffer,\n  srcOffset,\n  destBuffer,\n  destOffset,\n  byteCount = 0,\n) => {\n  const src = new Uint8Array(srcBuffer, srcOffset);\n  const dest = new Uint8Array(destBuffer, destOffset);\n  for (let i = 0; i < byteCount; i++) {\n    dest[i] = src[i];\n  }\n};\n\n/**\n * SplatBuffer: Container for splat data from a single scene/file and capable of (mediocre) compression.\n */\nexport class SplatBuffer {\n  static CurrentMajorVersion = 0;\n  static CurrentMinorVersion = 1;\n\n  static CenterComponentCount = 3;\n  static ScaleComponentCount = 3;\n  static RotationComponentCount = 4;\n  static ColorComponentCount = 4;\n  static CovarianceComponentCount = 6;\n\n  static SplatScaleOffsetFloat = 3;\n  static SplatRotationOffsetFloat = 6;\n\n  static CompressionLevels = {\n    0: {\n      BytesPerCenter: 12,\n      BytesPerScale: 12,\n      BytesPerRotation: 16,\n      BytesPerColor: 4,\n      ScaleOffsetBytes: 12,\n      RotationffsetBytes: 24,\n      ColorOffsetBytes: 40,\n      SphericalHarmonicsOffsetBytes: 44,\n      ScaleRange: 1,\n      BytesPerSphericalHarmonicsComponent: 4,\n      SphericalHarmonicsOffsetFloat: 11,\n      SphericalHarmonicsDegrees: {\n        0: { BytesPerSplat: 44 },\n        1: { BytesPerSplat: 80 },\n        2: { BytesPerSplat: 140 },\n      },\n    },\n    1: {\n      BytesPerCenter: 6,\n      BytesPerScale: 6,\n      BytesPerRotation: 8,\n      BytesPerColor: 4,\n      ScaleOffsetBytes: 6,\n      RotationffsetBytes: 12,\n      ColorOffsetBytes: 20,\n      SphericalHarmonicsOffsetBytes: 24,\n      ScaleRange: 32767,\n      BytesPerSphericalHarmonicsComponent: 2,\n      SphericalHarmonicsOffsetFloat: 12,\n      SphericalHarmonicsDegrees: {\n        0: { BytesPerSplat: 24 },\n        1: { BytesPerSplat: 42 },\n        2: { BytesPerSplat: 72 },\n      },\n    },\n    2: {\n      BytesPerCenter: 6,\n      BytesPerScale: 6,\n      BytesPerRotation: 8,\n      BytesPerColor: 4,\n      ScaleOffsetBytes: 6,\n      RotationffsetBytes: 12,\n      ColorOffsetBytes: 20,\n      SphericalHarmonicsOffsetBytes: 24,\n      ScaleRange: 32767,\n      BytesPerSphericalHarmonicsComponent: 1,\n      SphericalHarmonicsOffsetFloat: 12,\n      SphericalHarmonicsDegrees: {\n        0: { BytesPerSplat: 24 },\n        1: { BytesPerSplat: 33 },\n        2: { BytesPerSplat: 48 },\n      },\n    },\n  };\n\n  static CovarianceSizeFloats = 6;\n\n  static HeaderSizeBytes = 4096;\n  static SectionHeaderSizeBytes = 1024;\n\n  static BucketStorageSizeBytes = 12;\n  static BucketStorageSizeFloats = 3;\n\n  static BucketBlockSize = 5.0;\n  static BucketSize = 256;\n\n  constructor(bufferData, secLoadedCountsToMax = true) {\n    this.constructFromBuffer(bufferData, secLoadedCountsToMax);\n  }\n\n  getSplatCount() {\n    return this.splatCount;\n  }\n\n  getMaxSplatCount() {\n    return this.maxSplatCount;\n  }\n\n  getMinSphericalHarmonicsDegree() {\n    let minSphericalHarmonicsDegree = 0;\n    for (let i = 0; i < this.sections.length; i++) {\n      const section = this.sections[i];\n      if (\n        i === 0 ||\n        section.sphericalHarmonicsDegree < minSphericalHarmonicsDegree\n      ) {\n        minSphericalHarmonicsDegree = section.sphericalHarmonicsDegree;\n      }\n    }\n    return minSphericalHarmonicsDegree;\n  }\n\n  getBucketIndex(section, localSplatIndex) {\n    let bucketIndex;\n    const maxSplatIndexInFullBuckets =\n      section.fullBucketCount * section.bucketSize;\n    if (localSplatIndex < maxSplatIndexInFullBuckets) {\n      bucketIndex = Math.floor(localSplatIndex / section.bucketSize);\n    } else {\n      let bucketSplatIndex = maxSplatIndexInFullBuckets;\n      bucketIndex = section.fullBucketCount;\n      let partiallyFullBucketIndex = 0;\n      while (bucketSplatIndex < section.splatCount) {\n        let currentPartiallyFilledBucketSize =\n          section.partiallyFilledBucketLengths[partiallyFullBucketIndex];\n        if (\n          localSplatIndex >= bucketSplatIndex &&\n          localSplatIndex < bucketSplatIndex + currentPartiallyFilledBucketSize\n        ) {\n          break;\n        }\n        bucketSplatIndex += currentPartiallyFilledBucketSize;\n        bucketIndex++;\n        partiallyFullBucketIndex++;\n      }\n    }\n    return bucketIndex;\n  }\n\n  getSplatCenter(globalSplatIndex, outCenter, transform) {\n    const sectionIndex = this.globalSplatIndexToSectionMap[globalSplatIndex];\n    const section = this.sections[sectionIndex];\n    const localSplatIndex = globalSplatIndex - section.splatCountOffset;\n\n    const srcSplatCentersBase = section.bytesPerSplat * localSplatIndex;\n    const dataView = new DataView(\n      this.bufferData,\n      section.dataBase + srcSplatCentersBase,\n    );\n\n    const x = dataViewFloatForCompressionLevel(\n      dataView,\n      0,\n      this.compressionLevel,\n    );\n    const y = dataViewFloatForCompressionLevel(\n      dataView,\n      1,\n      this.compressionLevel,\n    );\n    const z = dataViewFloatForCompressionLevel(\n      dataView,\n      2,\n      this.compressionLevel,\n    );\n    if (this.compressionLevel >= 1) {\n      const bucketIndex = this.getBucketIndex(section, localSplatIndex);\n      const bucketBase = bucketIndex * SplatBuffer.BucketStorageSizeFloats;\n      const sf = section.compressionScaleFactor;\n      const sr = section.compressionScaleRange;\n      outCenter.x = (x - sr) * sf + section.bucketArray[bucketBase];\n      outCenter.y = (y - sr) * sf + section.bucketArray[bucketBase + 1];\n      outCenter.z = (z - sr) * sf + section.bucketArray[bucketBase + 2];\n    } else {\n      outCenter.x = x;\n      outCenter.y = y;\n      outCenter.z = z;\n    }\n    if (transform) outCenter.applyMatrix4(transform);\n  }\n\n  getSplatScaleAndRotation = (function() {\n    const scaleMatrix = new THREE.Matrix4();\n    const rotationMatrix = new THREE.Matrix4();\n    const tempMatrix = new THREE.Matrix4();\n    const tempPosition = new THREE.Vector3();\n    const scale = new THREE.Vector3();\n    const rotation = new THREE.Quaternion();\n\n    return function(index, outScale, outRotation, transform, scaleOverride) {\n      const sectionIndex = this.globalSplatIndexToSectionMap[index];\n      const section = this.sections[sectionIndex];\n      const localSplatIndex = index - section.splatCountOffset;\n\n      const srcSplatScalesBase =\n        section.bytesPerSplat * localSplatIndex +\n        SplatBuffer.CompressionLevels[this.compressionLevel].ScaleOffsetBytes;\n\n      const dataView = new DataView(\n        this.bufferData,\n        section.dataBase + srcSplatScalesBase,\n      );\n\n      scale.set(\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 0, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 1, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 2, this.compressionLevel),\n          this.compressionLevel,\n        ),\n      );\n      if (scaleOverride) {\n        if (scaleOverride.x !== undefined) scale.x = scaleOverride.x;\n        if (scaleOverride.y !== undefined) scale.y = scaleOverride.y;\n        if (scaleOverride.z !== undefined) scale.z = scaleOverride.z;\n      }\n\n      rotation.set(\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 4, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 5, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 6, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 3, this.compressionLevel),\n          this.compressionLevel,\n        ),\n      );\n\n      if (transform) {\n        scaleMatrix.makeScale(scale.x, scale.y, scale.z);\n        rotationMatrix.makeRotationFromQuaternion(rotation);\n        tempMatrix\n          .copy(scaleMatrix)\n          .multiply(rotationMatrix)\n          .multiply(transform);\n        tempMatrix.decompose(tempPosition, outRotation, outScale);\n      } else {\n        outScale.copy(scale);\n        outRotation.copy(rotation);\n      }\n    };\n  })();\n\n  getSplatColor(globalSplatIndex, outColor) {\n    const sectionIndex = this.globalSplatIndexToSectionMap[globalSplatIndex];\n    const section = this.sections[sectionIndex];\n    const localSplatIndex = globalSplatIndex - section.splatCountOffset;\n\n    const srcSplatColorsBase =\n      section.bytesPerSplat * localSplatIndex +\n      SplatBuffer.CompressionLevels[this.compressionLevel].ColorOffsetBytes;\n    const splatColorsArray = new Uint8Array(\n      this.bufferData,\n      section.dataBase + srcSplatColorsBase,\n      4,\n    );\n\n    outColor.set(\n      splatColorsArray[0],\n      splatColorsArray[1],\n      splatColorsArray[2],\n      splatColorsArray[3],\n    );\n  }\n\n  fillSplatCenterArray(outCenterArray, transform, srcFrom, srcTo, destFrom) {\n    const splatCount = this.splatCount;\n\n    srcFrom = srcFrom || 0;\n    srcTo = srcTo || splatCount - 1;\n    if (destFrom === undefined) destFrom = srcFrom;\n\n    const center = new THREE.Vector3();\n    for (let i = srcFrom; i <= srcTo; i++) {\n      const sectionIndex = this.globalSplatIndexToSectionMap[i];\n      const section = this.sections[sectionIndex];\n      const localSplatIndex = i - section.splatCountOffset;\n      const centerDestBase =\n        (i - srcFrom + destFrom) * SplatBuffer.CenterComponentCount;\n\n      const srcSplatCentersBase = section.bytesPerSplat * localSplatIndex;\n      const dataView = new DataView(\n        this.bufferData,\n        section.dataBase + srcSplatCentersBase,\n      );\n\n      const x = dataViewFloatForCompressionLevel(\n        dataView,\n        0,\n        this.compressionLevel,\n      );\n      const y = dataViewFloatForCompressionLevel(\n        dataView,\n        1,\n        this.compressionLevel,\n      );\n      const z = dataViewFloatForCompressionLevel(\n        dataView,\n        2,\n        this.compressionLevel,\n      );\n      if (this.compressionLevel >= 1) {\n        const bucketIndex = this.getBucketIndex(section, localSplatIndex);\n        const bucketBase = bucketIndex * SplatBuffer.BucketStorageSizeFloats;\n        const sf = section.compressionScaleFactor;\n        const sr = section.compressionScaleRange;\n        center.x = (x - sr) * sf + section.bucketArray[bucketBase];\n        center.y = (y - sr) * sf + section.bucketArray[bucketBase + 1];\n        center.z = (z - sr) * sf + section.bucketArray[bucketBase + 2];\n      } else {\n        center.x = x;\n        center.y = y;\n        center.z = z;\n      }\n      if (transform) {\n        center.applyMatrix4(transform);\n      }\n      outCenterArray[centerDestBase] = center.x;\n      outCenterArray[centerDestBase + 1] = center.y;\n      outCenterArray[centerDestBase + 2] = center.z;\n    }\n  }\n\n  fillSplatScaleRotationArray = (function() {\n    const scaleMatrix = new THREE.Matrix4();\n    const rotationMatrix = new THREE.Matrix4();\n    const tempMatrix = new THREE.Matrix4();\n    const scale = new THREE.Vector3();\n    const rotation = new THREE.Quaternion();\n    const tempPosition = new THREE.Vector3();\n\n    const ensurePositiveW = (quaternion) => {\n      const flip = quaternion.w < 0 ? -1 : 1;\n      quaternion.x *= flip;\n      quaternion.y *= flip;\n      quaternion.z *= flip;\n      quaternion.w *= flip;\n    };\n\n    return function(\n      outScaleArray,\n      outRotationArray,\n      transform,\n      srcFrom,\n      srcTo,\n      destFrom,\n      desiredOutputCompressionLevel,\n      scaleOverride,\n    ) {\n      const splatCount = this.splatCount;\n\n      srcFrom = srcFrom || 0;\n      srcTo = srcTo || splatCount - 1;\n      if (destFrom === undefined) destFrom = srcFrom;\n\n      const outputConversion = (value, srcCompressionLevel) => {\n        if (srcCompressionLevel === undefined) {\n          srcCompressionLevel = this.compressionLevel;\n        }\n        return convertBetweenCompressionLevels(\n          value,\n          srcCompressionLevel,\n          desiredOutputCompressionLevel,\n        );\n      };\n\n      for (let i = srcFrom; i <= srcTo; i++) {\n        const sectionIndex = this.globalSplatIndexToSectionMap[i];\n        const section = this.sections[sectionIndex];\n        const localSplatIndex = i - section.splatCountOffset;\n\n        const srcSplatScalesBase =\n          section.bytesPerSplat * localSplatIndex +\n          SplatBuffer.CompressionLevels[this.compressionLevel].ScaleOffsetBytes;\n\n        const scaleDestBase =\n          (i - srcFrom + destFrom) * SplatBuffer.ScaleComponentCount;\n        const rotationDestBase =\n          (i - srcFrom + destFrom) * SplatBuffer.RotationComponentCount;\n        const dataView = new DataView(\n          this.bufferData,\n          section.dataBase + srcSplatScalesBase,\n        );\n\n        const srcScaleX =\n          scaleOverride && scaleOverride.x !== undefined ?\n            scaleOverride.x :\n            dataViewFloatForCompressionLevel(\n                dataView,\n                0,\n                this.compressionLevel,\n              );\n        const srcScaleY =\n          scaleOverride && scaleOverride.y !== undefined ?\n            scaleOverride.y :\n            dataViewFloatForCompressionLevel(\n                dataView,\n                1,\n                this.compressionLevel,\n              );\n        const srcScaleZ =\n          scaleOverride && scaleOverride.z !== undefined ?\n            scaleOverride.z :\n            dataViewFloatForCompressionLevel(\n                dataView,\n                2,\n                this.compressionLevel,\n              );\n\n        const srcRotationW = dataViewFloatForCompressionLevel(\n          dataView,\n          3,\n          this.compressionLevel,\n        );\n        const srcRotationX = dataViewFloatForCompressionLevel(\n          dataView,\n          4,\n          this.compressionLevel,\n        );\n        const srcRotationY = dataViewFloatForCompressionLevel(\n          dataView,\n          5,\n          this.compressionLevel,\n        );\n        const srcRotationZ = dataViewFloatForCompressionLevel(\n          dataView,\n          6,\n          this.compressionLevel,\n        );\n\n        scale.set(\n          toUncompressedFloat(srcScaleX, this.compressionLevel),\n          toUncompressedFloat(srcScaleY, this.compressionLevel),\n          toUncompressedFloat(srcScaleZ, this.compressionLevel),\n        );\n\n        rotation\n          .set(\n            toUncompressedFloat(srcRotationX, this.compressionLevel),\n            toUncompressedFloat(srcRotationY, this.compressionLevel),\n            toUncompressedFloat(srcRotationZ, this.compressionLevel),\n            toUncompressedFloat(srcRotationW, this.compressionLevel),\n          )\n          .normalize();\n\n        if (transform) {\n          tempPosition.set(0, 0, 0);\n          scaleMatrix.makeScale(scale.x, scale.y, scale.z);\n          rotationMatrix.makeRotationFromQuaternion(rotation);\n          tempMatrix\n            .identity()\n            .premultiply(scaleMatrix)\n            .premultiply(rotationMatrix);\n          tempMatrix.premultiply(transform);\n          tempMatrix.decompose(tempPosition, rotation, scale);\n          rotation.normalize();\n        }\n\n        ensurePositiveW(rotation);\n\n        if (outScaleArray) {\n          outScaleArray[scaleDestBase] = outputConversion(scale.x, 0);\n          outScaleArray[scaleDestBase + 1] = outputConversion(scale.y, 0);\n          outScaleArray[scaleDestBase + 2] = outputConversion(scale.z, 0);\n        }\n\n        if (outRotationArray) {\n          outRotationArray[rotationDestBase] = outputConversion(rotation.x, 0);\n          outRotationArray[rotationDestBase + 1] = outputConversion(\n            rotation.y,\n            0,\n          );\n          outRotationArray[rotationDestBase + 2] = outputConversion(\n            rotation.z,\n            0,\n          );\n          outRotationArray[rotationDestBase + 3] = outputConversion(\n            rotation.w,\n            0,\n          );\n        }\n      }\n    };\n  })();\n\n  static computeCovariance = (function() {\n    const tempMatrix4 = new THREE.Matrix4();\n    const scaleMatrix = new THREE.Matrix3();\n    const rotationMatrix = new THREE.Matrix3();\n    const covarianceMatrix = new THREE.Matrix3();\n    const transformedCovariance = new THREE.Matrix3();\n    const transform3x3 = new THREE.Matrix3();\n    const transform3x3Transpose = new THREE.Matrix3();\n\n    return function(\n      scale,\n      rotation,\n      transform,\n      outCovariance,\n      outOffset = 0,\n      desiredOutputCompressionLevel,\n    ) {\n      tempMatrix4.makeScale(scale.x, scale.y, scale.z);\n      scaleMatrix.setFromMatrix4(tempMatrix4);\n\n      tempMatrix4.makeRotationFromQuaternion(rotation);\n      rotationMatrix.setFromMatrix4(tempMatrix4);\n\n      covarianceMatrix.copy(rotationMatrix).multiply(scaleMatrix);\n      transformedCovariance\n        .copy(covarianceMatrix)\n        .transpose()\n        .premultiply(covarianceMatrix);\n\n      if (transform) {\n        transform3x3.setFromMatrix4(transform);\n        transform3x3Transpose.copy(transform3x3).transpose();\n        transformedCovariance.multiply(transform3x3Transpose);\n        transformedCovariance.premultiply(transform3x3);\n      }\n\n      if (desiredOutputCompressionLevel >= 1) {\n        outCovariance[outOffset] = toHalfFloat(\n          transformedCovariance.elements[0],\n        );\n        outCovariance[outOffset + 1] = toHalfFloat(\n          transformedCovariance.elements[3],\n        );\n        outCovariance[outOffset + 2] = toHalfFloat(\n          transformedCovariance.elements[6],\n        );\n        outCovariance[outOffset + 3] = toHalfFloat(\n          transformedCovariance.elements[4],\n        );\n        outCovariance[outOffset + 4] = toHalfFloat(\n          transformedCovariance.elements[7],\n        );\n        outCovariance[outOffset + 5] = toHalfFloat(\n          transformedCovariance.elements[8],\n        );\n      } else {\n        outCovariance[outOffset] = transformedCovariance.elements[0];\n        outCovariance[outOffset + 1] = transformedCovariance.elements[3];\n        outCovariance[outOffset + 2] = transformedCovariance.elements[6];\n        outCovariance[outOffset + 3] = transformedCovariance.elements[4];\n        outCovariance[outOffset + 4] = transformedCovariance.elements[7];\n        outCovariance[outOffset + 5] = transformedCovariance.elements[8];\n      }\n    };\n  })();\n\n  fillSplatCovarianceArray(\n    covarianceArray,\n    transform,\n    srcFrom,\n    srcTo,\n    destFrom,\n    desiredOutputCompressionLevel,\n  ) {\n    const splatCount = this.splatCount;\n\n    const scale = new THREE.Vector3();\n    const rotation = new THREE.Quaternion();\n\n    srcFrom = srcFrom || 0;\n    srcTo = srcTo || splatCount - 1;\n    if (destFrom === undefined) destFrom = srcFrom;\n\n    for (let i = srcFrom; i <= srcTo; i++) {\n      const sectionIndex = this.globalSplatIndexToSectionMap[i];\n      const section = this.sections[sectionIndex];\n      const localSplatIndex = i - section.splatCountOffset;\n\n      const covarianceDestBase =\n        (i - srcFrom + destFrom) * SplatBuffer.CovarianceComponentCount;\n      const srcSplatScalesBase =\n        section.bytesPerSplat * localSplatIndex +\n        SplatBuffer.CompressionLevels[this.compressionLevel].ScaleOffsetBytes;\n\n      const dataView = new DataView(\n        this.bufferData,\n        section.dataBase + srcSplatScalesBase,\n      );\n\n      scale.set(\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 0, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 1, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 2, this.compressionLevel),\n          this.compressionLevel,\n        ),\n      );\n\n      rotation.set(\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 4, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 5, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 6, this.compressionLevel),\n          this.compressionLevel,\n        ),\n        toUncompressedFloat(\n          dataViewFloatForCompressionLevel(dataView, 3, this.compressionLevel),\n          this.compressionLevel,\n        ),\n      );\n\n      SplatBuffer.computeCovariance(\n        scale,\n        rotation,\n        transform,\n        covarianceArray,\n        covarianceDestBase,\n        desiredOutputCompressionLevel,\n      );\n    }\n  }\n\n  fillSplatColorArray(outColorArray, minimumAlpha, srcFrom, srcTo, destFrom) {\n    const splatCount = this.splatCount;\n\n    srcFrom = srcFrom || 0;\n    srcTo = srcTo || splatCount - 1;\n    if (destFrom === undefined) destFrom = srcFrom;\n\n    for (let i = srcFrom; i <= srcTo; i++) {\n      const sectionIndex = this.globalSplatIndexToSectionMap[i];\n      const section = this.sections[sectionIndex];\n      const localSplatIndex = i - section.splatCountOffset;\n\n      const colorDestBase =\n        (i - srcFrom + destFrom) * SplatBuffer.ColorComponentCount;\n      const srcSplatColorsBase =\n        section.bytesPerSplat * localSplatIndex +\n        SplatBuffer.CompressionLevels[this.compressionLevel].ColorOffsetBytes;\n\n      const dataView = new Uint8Array(\n        this.bufferData,\n        section.dataBase + srcSplatColorsBase,\n      );\n\n      let alpha = dataView[3];\n      alpha = alpha >= minimumAlpha ? alpha : 0;\n\n      outColorArray[colorDestBase] = dataView[0];\n      outColorArray[colorDestBase + 1] = dataView[1];\n      outColorArray[colorDestBase + 2] = dataView[2];\n      outColorArray[colorDestBase + 3] = alpha;\n    }\n  }\n\n  fillSphericalHarmonicsArray = (function() {\n    const sphericalHarmonicVectors = [];\n    for (let i = 0; i < 15; i++) {\n      sphericalHarmonicVectors[i] = new THREE.Vector3();\n    }\n\n    const tempMatrix3 = new THREE.Matrix3();\n    const tempMatrix4 = new THREE.Matrix4();\n\n    const tempTranslation = new THREE.Vector3();\n    const tempScale = new THREE.Vector3();\n    const tempRotation = new THREE.Quaternion();\n\n    const sh11 = [];\n    const sh12 = [];\n    const sh13 = [];\n\n    const sh21 = [];\n    const sh22 = [];\n    const sh23 = [];\n    const sh24 = [];\n    const sh25 = [];\n\n    const shIn1 = [];\n    const shIn2 = [];\n    const shIn3 = [];\n    const shIn4 = [];\n    const shIn5 = [];\n\n    const shOut1 = [];\n    const shOut2 = [];\n    const shOut3 = [];\n    const shOut4 = [];\n    const shOut5 = [];\n\n    const noop = (v) => v;\n\n    const set3 = (array, val1, val2, val3) => {\n      array[0] = val1;\n      array[1] = val2;\n      array[2] = val3;\n    };\n\n    const set3FromArray = (\n      array,\n      srcDestView,\n      stride,\n      srcBase,\n      compressionLevel,\n    ) => {\n      array[0] = dataViewFloatForCompressionLevel(\n        srcDestView,\n        srcBase,\n        compressionLevel,\n        true,\n      );\n      array[1] = dataViewFloatForCompressionLevel(\n        srcDestView,\n        srcBase + stride,\n        compressionLevel,\n        true,\n      );\n      array[2] = dataViewFloatForCompressionLevel(\n        srcDestView,\n        srcBase + stride + stride,\n        compressionLevel,\n        true,\n      );\n    };\n\n    const copy3 = (srcArray, destArray) => {\n      destArray[0] = srcArray[0];\n      destArray[1] = srcArray[1];\n      destArray[2] = srcArray[2];\n    };\n\n    const setOutput3 = (srcArray, destArray, destBase, conversionFunc) => {\n      destArray[destBase] = conversionFunc(srcArray[0]);\n      destArray[destBase + 1] = conversionFunc(srcArray[1]);\n      destArray[destBase + 2] = conversionFunc(srcArray[2]);\n    };\n\n    const toUncompressedFloatArray3 = (\n      src,\n      dest,\n      compressionLevel,\n      range8BitMin,\n      range8BitMax,\n    ) => {\n      dest[0] = toUncompressedFloat(\n        src[0],\n        compressionLevel,\n        true,\n        range8BitMin,\n        range8BitMax,\n      );\n      dest[1] = toUncompressedFloat(\n        src[1],\n        compressionLevel,\n        true,\n        range8BitMin,\n        range8BitMax,\n      );\n      dest[2] = toUncompressedFloat(\n        src[2],\n        compressionLevel,\n        true,\n        range8BitMin,\n        range8BitMax,\n      );\n      return dest;\n    };\n\n    return function(\n      outSphericalHarmonicsArray,\n      outSphericalHarmonicsDegree,\n      transform,\n      srcFrom,\n      srcTo,\n      destFrom,\n      desiredOutputCompressionLevel,\n    ) {\n      const splatCount = this.splatCount;\n\n      srcFrom = srcFrom || 0;\n      srcTo = srcTo || splatCount - 1;\n      if (destFrom === undefined) destFrom = srcFrom;\n\n      if (transform && outSphericalHarmonicsDegree >= 1) {\n        tempMatrix4.copy(transform);\n        tempMatrix4.decompose(tempTranslation, tempRotation, tempScale);\n        tempRotation.normalize();\n        tempMatrix4.makeRotationFromQuaternion(tempRotation);\n        tempMatrix3.setFromMatrix4(tempMatrix4);\n        set3(\n          sh11,\n          tempMatrix3.elements[4],\n          -tempMatrix3.elements[7],\n          tempMatrix3.elements[1],\n        );\n        set3(\n          sh12,\n          -tempMatrix3.elements[5],\n          tempMatrix3.elements[8],\n          -tempMatrix3.elements[2],\n        );\n        set3(\n          sh13,\n          tempMatrix3.elements[3],\n          -tempMatrix3.elements[6],\n          tempMatrix3.elements[0],\n        );\n      }\n\n      const localFromHalfFloatToUint8 = (v) => {\n        return fromHalfFloatToUint8(\n          v,\n          this.minSphericalHarmonicsCoeff,\n          this.maxSphericalHarmonicsCoeff,\n        );\n      };\n\n      const localToUint8 = (v) => {\n        return toUint8(\n          v,\n          this.minSphericalHarmonicsCoeff,\n          this.maxSphericalHarmonicsCoeff,\n        );\n      };\n\n      for (let i = srcFrom; i <= srcTo; i++) {\n        const sectionIndex = this.globalSplatIndexToSectionMap[i];\n        const section = this.sections[sectionIndex];\n        outSphericalHarmonicsDegree = Math.min(\n          outSphericalHarmonicsDegree,\n          section.sphericalHarmonicsDegree,\n        );\n        const outSphericalHarmonicsComponentsCount =\n          getSphericalHarmonicsComponentCountForDegree(\n            outSphericalHarmonicsDegree,\n          );\n\n        const localSplatIndex = i - section.splatCountOffset;\n\n        const srcSplatSHBase =\n          section.bytesPerSplat * localSplatIndex +\n          SplatBuffer.CompressionLevels[this.compressionLevel]\n            .SphericalHarmonicsOffsetBytes;\n\n        const dataView = new DataView(\n          this.bufferData,\n          section.dataBase + srcSplatSHBase,\n        );\n\n        const shDestBase =\n          (i - srcFrom + destFrom) * outSphericalHarmonicsComponentsCount;\n\n        let compressionLevelForOutputConversion = transform ?\n          0 :\n          this.compressionLevel;\n        let outputConversionFunc = noop;\n        if (\n          compressionLevelForOutputConversion !== desiredOutputCompressionLevel\n        ) {\n          if (compressionLevelForOutputConversion === 1) {\n            if (desiredOutputCompressionLevel === 0) {\n              outputConversionFunc = fromHalfFloat;\n            } else if (desiredOutputCompressionLevel == 2) {\n              outputConversionFunc = localFromHalfFloatToUint8;\n            }\n          } else if (compressionLevelForOutputConversion === 0) {\n            if (desiredOutputCompressionLevel === 1) {\n              outputConversionFunc = toHalfFloat;\n            } else if (desiredOutputCompressionLevel == 2) {\n              outputConversionFunc = localToUint8;\n            }\n          }\n        }\n\n        const minShCoeff = this.minSphericalHarmonicsCoeff;\n        const maxShCoeff = this.maxSphericalHarmonicsCoeff;\n\n        if (outSphericalHarmonicsDegree >= 1) {\n          set3FromArray(shIn1, dataView, 3, 0, this.compressionLevel);\n          set3FromArray(shIn2, dataView, 3, 1, this.compressionLevel);\n          set3FromArray(shIn3, dataView, 3, 2, this.compressionLevel);\n\n          if (transform) {\n            toUncompressedFloatArray3(\n              shIn1,\n              shIn1,\n              this.compressionLevel,\n              minShCoeff,\n              maxShCoeff,\n            );\n            toUncompressedFloatArray3(\n              shIn2,\n              shIn2,\n              this.compressionLevel,\n              minShCoeff,\n              maxShCoeff,\n            );\n            toUncompressedFloatArray3(\n              shIn3,\n              shIn3,\n              this.compressionLevel,\n              minShCoeff,\n              maxShCoeff,\n            );\n            SplatBuffer.rotateSphericalHarmonics3(\n              shIn1,\n              shIn2,\n              shIn3,\n              sh11,\n              sh12,\n              sh13,\n              shOut1,\n              shOut2,\n              shOut3,\n            );\n          } else {\n            copy3(shIn1, shOut1);\n            copy3(shIn2, shOut2);\n            copy3(shIn3, shOut3);\n          }\n\n          setOutput3(\n            shOut1,\n            outSphericalHarmonicsArray,\n            shDestBase,\n            outputConversionFunc,\n          );\n          setOutput3(\n            shOut2,\n            outSphericalHarmonicsArray,\n            shDestBase + 3,\n            outputConversionFunc,\n          );\n          setOutput3(\n            shOut3,\n            outSphericalHarmonicsArray,\n            shDestBase + 6,\n            outputConversionFunc,\n          );\n\n          if (outSphericalHarmonicsDegree >= 2) {\n            set3FromArray(shIn1, dataView, 5, 9, this.compressionLevel);\n            set3FromArray(shIn2, dataView, 5, 10, this.compressionLevel);\n            set3FromArray(shIn3, dataView, 5, 11, this.compressionLevel);\n            set3FromArray(shIn4, dataView, 5, 12, this.compressionLevel);\n            set3FromArray(shIn5, dataView, 5, 13, this.compressionLevel);\n\n            if (transform) {\n              toUncompressedFloatArray3(\n                shIn1,\n                shIn1,\n                this.compressionLevel,\n                minShCoeff,\n                maxShCoeff,\n              );\n              toUncompressedFloatArray3(\n                shIn2,\n                shIn2,\n                this.compressionLevel,\n                minShCoeff,\n                maxShCoeff,\n              );\n              toUncompressedFloatArray3(\n                shIn3,\n                shIn3,\n                this.compressionLevel,\n                minShCoeff,\n                maxShCoeff,\n              );\n              toUncompressedFloatArray3(\n                shIn4,\n                shIn4,\n                this.compressionLevel,\n                minShCoeff,\n                maxShCoeff,\n              );\n              toUncompressedFloatArray3(\n                shIn5,\n                shIn5,\n                this.compressionLevel,\n                minShCoeff,\n                maxShCoeff,\n              );\n              SplatBuffer.rotateSphericalHarmonics5(\n                shIn1,\n                shIn2,\n                shIn3,\n                shIn4,\n                shIn5,\n                sh11,\n                sh12,\n                sh13,\n                sh21,\n                sh22,\n                sh23,\n                sh24,\n                sh25,\n                shOut1,\n                shOut2,\n                shOut3,\n                shOut4,\n                shOut5,\n              );\n            } else {\n              copy3(shIn1, shOut1);\n              copy3(shIn2, shOut2);\n              copy3(shIn3, shOut3);\n              copy3(shIn4, shOut4);\n              copy3(shIn5, shOut5);\n            }\n\n            setOutput3(\n              shOut1,\n              outSphericalHarmonicsArray,\n              shDestBase + 9,\n              outputConversionFunc,\n            );\n            setOutput3(\n              shOut2,\n              outSphericalHarmonicsArray,\n              shDestBase + 12,\n              outputConversionFunc,\n            );\n            setOutput3(\n              shOut3,\n              outSphericalHarmonicsArray,\n              shDestBase + 15,\n              outputConversionFunc,\n            );\n            setOutput3(\n              shOut4,\n              outSphericalHarmonicsArray,\n              shDestBase + 18,\n              outputConversionFunc,\n            );\n            setOutput3(\n              shOut5,\n              outSphericalHarmonicsArray,\n              shDestBase + 21,\n              outputConversionFunc,\n            );\n          }\n        }\n      }\n    };\n  })();\n\n  static dot3 = (v1, v2, v3, transformRow, outArray) => {\n    outArray[0] = outArray[1] = outArray[2] = 0;\n    const t0 = transformRow[0];\n    const t1 = transformRow[1];\n    const t2 = transformRow[2];\n    SplatBuffer.addInto3(v1[0] * t0, v1[1] * t0, v1[2] * t0, outArray);\n    SplatBuffer.addInto3(v2[0] * t1, v2[1] * t1, v2[2] * t1, outArray);\n    SplatBuffer.addInto3(v3[0] * t2, v3[1] * t2, v3[2] * t2, outArray);\n  };\n\n  static addInto3 = (val1, val2, val3, destArray) => {\n    destArray[0] = destArray[0] + val1;\n    destArray[1] = destArray[1] + val2;\n    destArray[2] = destArray[2] + val3;\n  };\n\n  static dot5 = (v1, v2, v3, v4, v5, transformRow, outArray) => {\n    outArray[0] = outArray[1] = outArray[2] = 0;\n    const t0 = transformRow[0];\n    const t1 = transformRow[1];\n    const t2 = transformRow[2];\n    const t3 = transformRow[3];\n    const t4 = transformRow[4];\n    SplatBuffer.addInto3(v1[0] * t0, v1[1] * t0, v1[2] * t0, outArray);\n    SplatBuffer.addInto3(v2[0] * t1, v2[1] * t1, v2[2] * t1, outArray);\n    SplatBuffer.addInto3(v3[0] * t2, v3[1] * t2, v3[2] * t2, outArray);\n    SplatBuffer.addInto3(v4[0] * t3, v4[1] * t3, v4[2] * t3, outArray);\n    SplatBuffer.addInto3(v5[0] * t4, v5[1] * t4, v5[2] * t4, outArray);\n  };\n\n  static rotateSphericalHarmonics3 = (\n    in1,\n    in2,\n    in3,\n    tsh11,\n    tsh12,\n    tsh13,\n    out1,\n    out2,\n    out3,\n  ) => {\n    SplatBuffer.dot3(in1, in2, in3, tsh11, out1);\n    SplatBuffer.dot3(in1, in2, in3, tsh12, out2);\n    SplatBuffer.dot3(in1, in2, in3, tsh13, out3);\n  };\n\n  static rotateSphericalHarmonics5 = (\n    in1,\n    in2,\n    in3,\n    in4,\n    in5,\n    tsh11,\n    tsh12,\n    tsh13,\n    tsh21,\n    tsh22,\n    tsh23,\n    tsh24,\n    tsh25,\n    out1,\n    out2,\n    out3,\n    out4,\n    out5,\n  ) => {\n    const kSqrt0104 = Math.sqrt(1.0 / 4.0);\n    const kSqrt0304 = Math.sqrt(3.0 / 4.0);\n    const kSqrt0103 = Math.sqrt(1.0 / 3.0);\n    const kSqrt0403 = Math.sqrt(4.0 / 3.0);\n    const kSqrt0112 = Math.sqrt(1.0 / 12.0);\n\n    tsh21[0] =\n      kSqrt0104 *\n      (tsh13[2] * tsh11[0] +\n        tsh13[0] * tsh11[2] +\n        (tsh11[2] * tsh13[0] + tsh11[0] * tsh13[2]));\n    tsh21[1] = tsh13[1] * tsh11[0] + tsh11[1] * tsh13[0];\n    tsh21[2] = kSqrt0304 * (tsh13[1] * tsh11[1] + tsh11[1] * tsh13[1]);\n    tsh21[3] = tsh13[1] * tsh11[2] + tsh11[1] * tsh13[2];\n    tsh21[4] =\n      kSqrt0104 *\n      (tsh13[2] * tsh11[2] -\n        tsh13[0] * tsh11[0] +\n        (tsh11[2] * tsh13[2] - tsh11[0] * tsh13[0]));\n    SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh21, out1);\n\n    tsh22[0] =\n      kSqrt0104 *\n      (tsh12[2] * tsh11[0] +\n        tsh12[0] * tsh11[2] +\n        (tsh11[2] * tsh12[0] + tsh11[0] * tsh12[2]));\n    tsh22[1] = tsh12[1] * tsh11[0] + tsh11[1] * tsh12[0];\n    tsh22[2] = kSqrt0304 * (tsh12[1] * tsh11[1] + tsh11[1] * tsh12[1]);\n    tsh22[3] = tsh12[1] * tsh11[2] + tsh11[1] * tsh12[2];\n    tsh22[4] =\n      kSqrt0104 *\n      (tsh12[2] * tsh11[2] -\n        tsh12[0] * tsh11[0] +\n        (tsh11[2] * tsh12[2] - tsh11[0] * tsh12[0]));\n    SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh22, out2);\n\n    tsh23[0] =\n      kSqrt0103 * (tsh12[2] * tsh12[0] + tsh12[0] * tsh12[2]) +\n      -kSqrt0112 *\n        (tsh13[2] * tsh13[0] +\n          tsh13[0] * tsh13[2] +\n          (tsh11[2] * tsh11[0] + tsh11[0] * tsh11[2]));\n    tsh23[1] =\n      kSqrt0403 * tsh12[1] * tsh12[0] +\n      -kSqrt0103 * (tsh13[1] * tsh13[0] + tsh11[1] * tsh11[0]);\n    tsh23[2] =\n      tsh12[1] * tsh12[1] +\n      -kSqrt0104 * (tsh13[1] * tsh13[1] + tsh11[1] * tsh11[1]);\n    tsh23[3] =\n      kSqrt0403 * tsh12[1] * tsh12[2] +\n      -kSqrt0103 * (tsh13[1] * tsh13[2] + tsh11[1] * tsh11[2]);\n    tsh23[4] =\n      kSqrt0103 * (tsh12[2] * tsh12[2] - tsh12[0] * tsh12[0]) +\n      -kSqrt0112 *\n        (tsh13[2] * tsh13[2] -\n          tsh13[0] * tsh13[0] +\n          (tsh11[2] * tsh11[2] - tsh11[0] * tsh11[0]));\n    SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh23, out3);\n\n    tsh24[0] =\n      kSqrt0104 *\n      (tsh12[2] * tsh13[0] +\n        tsh12[0] * tsh13[2] +\n        (tsh13[2] * tsh12[0] + tsh13[0] * tsh12[2]));\n    tsh24[1] = tsh12[1] * tsh13[0] + tsh13[1] * tsh12[0];\n    tsh24[2] = kSqrt0304 * (tsh12[1] * tsh13[1] + tsh13[1] * tsh12[1]);\n    tsh24[3] = tsh12[1] * tsh13[2] + tsh13[1] * tsh12[2];\n    tsh24[4] =\n      kSqrt0104 *\n      (tsh12[2] * tsh13[2] -\n        tsh12[0] * tsh13[0] +\n        (tsh13[2] * tsh12[2] - tsh13[0] * tsh12[0]));\n    SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh24, out4);\n\n    tsh25[0] =\n      kSqrt0104 *\n      (tsh13[2] * tsh13[0] +\n        tsh13[0] * tsh13[2] -\n        (tsh11[2] * tsh11[0] + tsh11[0] * tsh11[2]));\n    tsh25[1] = tsh13[1] * tsh13[0] - tsh11[1] * tsh11[0];\n    tsh25[2] = kSqrt0304 * (tsh13[1] * tsh13[1] - tsh11[1] * tsh11[1]);\n    tsh25[3] = tsh13[1] * tsh13[2] - tsh11[1] * tsh11[2];\n    tsh25[4] =\n      kSqrt0104 *\n      (tsh13[2] * tsh13[2] -\n        tsh13[0] * tsh13[0] -\n        (tsh11[2] * tsh11[2] - tsh11[0] * tsh11[0]));\n    SplatBuffer.dot5(in1, in2, in3, in4, in5, tsh25, out5);\n  };\n\n  static parseHeader(buffer) {\n    const headerArrayUint8 = new Uint8Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes,\n    );\n    const headerArrayUint16 = new Uint16Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes / 2,\n    );\n    const headerArrayUint32 = new Uint32Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes / 4,\n    );\n    const headerArrayFloat32 = new Float32Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes / 4,\n    );\n    const versionMajor = headerArrayUint8[0];\n    const versionMinor = headerArrayUint8[1];\n    const maxSectionCount = headerArrayUint32[1];\n    const sectionCount = headerArrayUint32[2];\n    const maxSplatCount = headerArrayUint32[3];\n    const splatCount = headerArrayUint32[4];\n    const compressionLevel = headerArrayUint16[10];\n    const sceneCenter = new THREE.Vector3(\n      headerArrayFloat32[6],\n      headerArrayFloat32[7],\n      headerArrayFloat32[8],\n    );\n\n    const minSphericalHarmonicsCoeff =\n      headerArrayFloat32[9] ||\n      -DefaultSphericalHarmonics8BitCompressionHalfRange;\n    const maxSphericalHarmonicsCoeff =\n      headerArrayFloat32[10] ||\n      DefaultSphericalHarmonics8BitCompressionHalfRange;\n\n    return {\n      versionMajor,\n      versionMinor,\n      maxSectionCount,\n      sectionCount,\n      maxSplatCount,\n      splatCount,\n      compressionLevel,\n      sceneCenter,\n      minSphericalHarmonicsCoeff,\n      maxSphericalHarmonicsCoeff,\n    };\n  }\n\n  static writeHeaderCountsToBuffer(sectionCount, splatCount, buffer) {\n    const headerArrayUint32 = new Uint32Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes / 4,\n    );\n    headerArrayUint32[2] = sectionCount;\n    headerArrayUint32[4] = splatCount;\n  }\n\n  static writeHeaderToBuffer(header, buffer) {\n    const headerArrayUint8 = new Uint8Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes,\n    );\n    const headerArrayUint16 = new Uint16Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes / 2,\n    );\n    const headerArrayUint32 = new Uint32Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes / 4,\n    );\n    const headerArrayFloat32 = new Float32Array(\n      buffer,\n      0,\n      SplatBuffer.HeaderSizeBytes / 4,\n    );\n    headerArrayUint8[0] = header.versionMajor;\n    headerArrayUint8[1] = header.versionMinor;\n    headerArrayUint8[2] = 0; // unused for now\n    headerArrayUint8[3] = 0; // unused for now\n    headerArrayUint32[1] = header.maxSectionCount;\n    headerArrayUint32[2] = header.sectionCount;\n    headerArrayUint32[3] = header.maxSplatCount;\n    headerArrayUint32[4] = header.splatCount;\n    headerArrayUint16[10] = header.compressionLevel;\n    headerArrayFloat32[6] = header.sceneCenter.x;\n    headerArrayFloat32[7] = header.sceneCenter.y;\n    headerArrayFloat32[8] = header.sceneCenter.z;\n    headerArrayFloat32[9] =\n      header.minSphericalHarmonicsCoeff ||\n      -DefaultSphericalHarmonics8BitCompressionHalfRange;\n    headerArrayFloat32[10] =\n      header.maxSphericalHarmonicsCoeff ||\n      DefaultSphericalHarmonics8BitCompressionHalfRange;\n  }\n\n  static parseSectionHeaders(header, buffer, offset = 0, secLoadedCountsToMax) {\n    const compressionLevel = header.compressionLevel;\n\n    const maxSectionCount = header.maxSectionCount;\n    const sectionHeaderArrayUint16 = new Uint16Array(\n      buffer,\n      offset,\n      (maxSectionCount * SplatBuffer.SectionHeaderSizeBytes) / 2,\n    );\n    const sectionHeaderArrayUint32 = new Uint32Array(\n      buffer,\n      offset,\n      (maxSectionCount * SplatBuffer.SectionHeaderSizeBytes) / 4,\n    );\n    const sectionHeaderArrayFloat32 = new Float32Array(\n      buffer,\n      offset,\n      (maxSectionCount * SplatBuffer.SectionHeaderSizeBytes) / 4,\n    );\n\n    const sectionHeaders = [];\n    let sectionHeaderBase = 0;\n    let sectionHeaderBaseUint16 = sectionHeaderBase / 2;\n    let sectionHeaderBaseUint32 = sectionHeaderBase / 4;\n    let sectionBase =\n      SplatBuffer.HeaderSizeBytes +\n      header.maxSectionCount * SplatBuffer.SectionHeaderSizeBytes;\n    let splatCountOffset = 0;\n    for (let i = 0; i < maxSectionCount; i++) {\n      const maxSplatCount =\n        sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 1];\n      const bucketSize = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 2];\n      const bucketCount = sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 3];\n      const bucketBlockSize =\n        sectionHeaderArrayFloat32[sectionHeaderBaseUint32 + 4];\n      const halfBucketBlockSize = bucketBlockSize / 2.0;\n      const bucketStorageSizeBytes =\n        sectionHeaderArrayUint16[sectionHeaderBaseUint16 + 10];\n      const compressionScaleRange =\n        sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 6] ||\n        SplatBuffer.CompressionLevels[compressionLevel].ScaleRange;\n      const fullBucketCount =\n        sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 8];\n      const partiallyFilledBucketCount =\n        sectionHeaderArrayUint32[sectionHeaderBaseUint32 + 9];\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes =\n        bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n\n      const sphericalHarmonicsDegree =\n        sectionHeaderArrayUint16[sectionHeaderBaseUint16 + 20];\n      const { bytesPerSplat } = SplatBuffer.calculateComponentStorage(\n        compressionLevel,\n        sphericalHarmonicsDegree,\n      );\n\n      const splatDataStorageSizeBytes = bytesPerSplat * maxSplatCount;\n      const storageSizeBytes =\n        splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sectionHeader = {\n        bytesPerSplat: bytesPerSplat,\n        splatCountOffset: splatCountOffset,\n        splatCount: secLoadedCountsToMax ? maxSplatCount : 0,\n        maxSplatCount: maxSplatCount,\n        bucketSize: bucketSize,\n        bucketCount: bucketCount,\n        bucketBlockSize: bucketBlockSize,\n        halfBucketBlockSize: halfBucketBlockSize,\n        bucketStorageSizeBytes: bucketStorageSizeBytes,\n        bucketsStorageSizeBytes: bucketsStorageSizeBytes,\n        splatDataStorageSizeBytes: splatDataStorageSizeBytes,\n        storageSizeBytes: storageSizeBytes,\n        compressionScaleRange: compressionScaleRange,\n        compressionScaleFactor: halfBucketBlockSize / compressionScaleRange,\n        base: sectionBase,\n        bucketsBase: sectionBase + bucketsMetaDataSizeBytes,\n        dataBase: sectionBase + bucketsStorageSizeBytes,\n        fullBucketCount: fullBucketCount,\n        partiallyFilledBucketCount: partiallyFilledBucketCount,\n        sphericalHarmonicsDegree: sphericalHarmonicsDegree,\n      };\n      sectionHeaders[i] = sectionHeader;\n      sectionBase += storageSizeBytes;\n      sectionHeaderBase += SplatBuffer.SectionHeaderSizeBytes;\n      sectionHeaderBaseUint16 = sectionHeaderBase / 2;\n      sectionHeaderBaseUint32 = sectionHeaderBase / 4;\n      splatCountOffset += maxSplatCount;\n    }\n\n    return sectionHeaders;\n  }\n\n  static writeSectionHeaderToBuffer(\n    sectionHeader,\n    compressionLevel,\n    buffer,\n    offset = 0,\n  ) {\n    const sectionHeadeArrayUint16 = new Uint16Array(\n      buffer,\n      offset,\n      SplatBuffer.SectionHeaderSizeBytes / 2,\n    );\n    const sectionHeadeArrayUint32 = new Uint32Array(\n      buffer,\n      offset,\n      SplatBuffer.SectionHeaderSizeBytes / 4,\n    );\n    const sectionHeadeArrayFloat32 = new Float32Array(\n      buffer,\n      offset,\n      SplatBuffer.SectionHeaderSizeBytes / 4,\n    );\n\n    sectionHeadeArrayUint32[0] = sectionHeader.splatCount;\n    sectionHeadeArrayUint32[1] = sectionHeader.maxSplatCount;\n    sectionHeadeArrayUint32[2] =\n      compressionLevel >= 1 ? sectionHeader.bucketSize : 0;\n    sectionHeadeArrayUint32[3] =\n      compressionLevel >= 1 ? sectionHeader.bucketCount : 0;\n    sectionHeadeArrayFloat32[4] =\n      compressionLevel >= 1 ? sectionHeader.bucketBlockSize : 0.0;\n    sectionHeadeArrayUint16[10] =\n      compressionLevel >= 1 ? SplatBuffer.BucketStorageSizeBytes : 0;\n    sectionHeadeArrayUint32[6] =\n      compressionLevel >= 1 ? sectionHeader.compressionScaleRange : 0;\n    sectionHeadeArrayUint32[7] = sectionHeader.storageSizeBytes;\n    sectionHeadeArrayUint32[8] =\n      compressionLevel >= 1 ? sectionHeader.fullBucketCount : 0;\n    sectionHeadeArrayUint32[9] =\n      compressionLevel >= 1 ? sectionHeader.partiallyFilledBucketCount : 0;\n    sectionHeadeArrayUint16[20] = sectionHeader.sphericalHarmonicsDegree;\n  }\n\n  static writeSectionHeaderSplatCountToBuffer(splatCount, buffer, offset = 0) {\n    const sectionHeadeArrayUint32 = new Uint32Array(\n      buffer,\n      offset,\n      SplatBuffer.SectionHeaderSizeBytes / 4,\n    );\n    sectionHeadeArrayUint32[0] = splatCount;\n  }\n\n  constructFromBuffer(bufferData, secLoadedCountsToMax) {\n    this.bufferData = bufferData;\n\n    this.globalSplatIndexToLocalSplatIndexMap = [];\n    this.globalSplatIndexToSectionMap = [];\n\n    const header = SplatBuffer.parseHeader(this.bufferData);\n    this.versionMajor = header.versionMajor;\n    this.versionMinor = header.versionMinor;\n    this.maxSectionCount = header.maxSectionCount;\n    this.sectionCount = secLoadedCountsToMax ? header.maxSectionCount : 0;\n    this.maxSplatCount = header.maxSplatCount;\n    this.splatCount = secLoadedCountsToMax ? header.maxSplatCount : 0;\n    this.compressionLevel = header.compressionLevel;\n    this.sceneCenter = new THREE.Vector3().copy(header.sceneCenter);\n    this.minSphericalHarmonicsCoeff = header.minSphericalHarmonicsCoeff;\n    this.maxSphericalHarmonicsCoeff = header.maxSphericalHarmonicsCoeff;\n\n    this.sections = SplatBuffer.parseSectionHeaders(\n      header,\n      this.bufferData,\n      SplatBuffer.HeaderSizeBytes,\n      secLoadedCountsToMax,\n    );\n\n    this.linkBufferArrays();\n    this.buildMaps();\n  }\n\n  static calculateComponentStorage(compressionLevel, sphericalHarmonicsDegree) {\n    const bytesPerCenter =\n      SplatBuffer.CompressionLevels[compressionLevel].BytesPerCenter;\n    const bytesPerScale =\n      SplatBuffer.CompressionLevels[compressionLevel].BytesPerScale;\n    const bytesPerRotation =\n      SplatBuffer.CompressionLevels[compressionLevel].BytesPerRotation;\n    const bytesPerColor =\n      SplatBuffer.CompressionLevels[compressionLevel].BytesPerColor;\n    const sphericalHarmonicsComponentsPerSplat =\n      getSphericalHarmonicsComponentCountForDegree(sphericalHarmonicsDegree);\n    const sphericalHarmonicsBytesPerSplat =\n      SplatBuffer.CompressionLevels[compressionLevel]\n        .BytesPerSphericalHarmonicsComponent *\n      sphericalHarmonicsComponentsPerSplat;\n    const bytesPerSplat =\n      bytesPerCenter +\n      bytesPerScale +\n      bytesPerRotation +\n      bytesPerColor +\n      sphericalHarmonicsBytesPerSplat;\n    return {\n      bytesPerCenter,\n      bytesPerScale,\n      bytesPerRotation,\n      bytesPerColor,\n      sphericalHarmonicsComponentsPerSplat,\n      sphericalHarmonicsBytesPerSplat,\n      bytesPerSplat,\n    };\n  }\n\n  linkBufferArrays() {\n    for (let i = 0; i < this.maxSectionCount; i++) {\n      const section = this.sections[i];\n      section.bucketArray = new Float32Array(\n        this.bufferData,\n        section.bucketsBase,\n        section.bucketCount * SplatBuffer.BucketStorageSizeFloats,\n      );\n      if (section.partiallyFilledBucketCount > 0) {\n        section.partiallyFilledBucketLengths = new Uint32Array(\n          this.bufferData,\n          section.base,\n          section.partiallyFilledBucketCount,\n        );\n      }\n    }\n  }\n\n  buildMaps() {\n    let cumulativeSplatCount = 0;\n    for (let i = 0; i < this.maxSectionCount; i++) {\n      const section = this.sections[i];\n      for (let j = 0; j < section.maxSplatCount; j++) {\n        const globalSplatIndex = cumulativeSplatCount + j;\n        this.globalSplatIndexToLocalSplatIndexMap[globalSplatIndex] = j;\n        this.globalSplatIndexToSectionMap[globalSplatIndex] = i;\n      }\n      cumulativeSplatCount += section.maxSplatCount;\n    }\n  }\n\n  updateLoadedCounts(newSectionCount, newSplatCount) {\n    SplatBuffer.writeHeaderCountsToBuffer(\n      newSectionCount,\n      newSplatCount,\n      this.bufferData,\n    );\n    this.sectionCount = newSectionCount;\n    this.splatCount = newSplatCount;\n  }\n\n  updateSectionLoadedCounts(sectionIndex, newSplatCount) {\n    const sectionHeaderOffset =\n      SplatBuffer.HeaderSizeBytes +\n      SplatBuffer.SectionHeaderSizeBytes * sectionIndex;\n    SplatBuffer.writeSectionHeaderSplatCountToBuffer(\n      newSplatCount,\n      this.bufferData,\n      sectionHeaderOffset,\n    );\n    this.sections[sectionIndex].splatCount = newSplatCount;\n  }\n\n  static writeSplatDataToSectionBuffer = (function() {\n    const tempCenterBuffer = new ArrayBuffer(12);\n    const tempScaleBuffer = new ArrayBuffer(12);\n    const tempRotationBuffer = new ArrayBuffer(16);\n    const tempColorBuffer = new ArrayBuffer(4);\n    const tempSHBuffer = new ArrayBuffer(256);\n    const tempRot = new THREE.Quaternion();\n    const tempScale = new THREE.Vector3();\n    const bucketCenterDelta = new THREE.Vector3();\n\n    const {\n      X: OFFSET_X,\n      Y: OFFSET_Y,\n      Z: OFFSET_Z,\n      SCALE0: OFFSET_SCALE0,\n      SCALE1: OFFSET_SCALE1,\n      SCALE2: OFFSET_SCALE2,\n      ROTATION0: OFFSET_ROT0,\n      ROTATION1: OFFSET_ROT1,\n      ROTATION2: OFFSET_ROT2,\n      ROTATION3: OFFSET_ROT3,\n      FDC0: OFFSET_FDC0,\n      FDC1: OFFSET_FDC1,\n      FDC2: OFFSET_FDC2,\n      OPACITY: OFFSET_OPACITY,\n      FRC0: OFFSET_FRC0,\n      FRC9: OFFSET_FRC9,\n    } = UncompressedSplatArray.OFFSET;\n\n    const compressPositionOffset = (\n      v,\n      compressionScaleFactor,\n      compressionScaleRange,\n    ) => {\n      const doubleCompressionScaleRange = compressionScaleRange * 2 + 1;\n      v = Math.round(v * compressionScaleFactor) + compressionScaleRange;\n      return clamp(v, 0, doubleCompressionScaleRange);\n    };\n\n    return function(\n      targetSplat,\n      sectionBuffer,\n      bufferOffset,\n      compressionLevel,\n      sphericalHarmonicsDegree,\n      bucketCenter,\n      compressionScaleFactor,\n      compressionScaleRange,\n      minSphericalHarmonicsCoeff = -DefaultSphericalHarmonics8BitCompressionHalfRange,\n      maxSphericalHarmonicsCoeff = DefaultSphericalHarmonics8BitCompressionHalfRange,\n    ) {\n      const sphericalHarmonicsComponentsPerSplat =\n        getSphericalHarmonicsComponentCountForDegree(sphericalHarmonicsDegree);\n      const bytesPerCenter =\n        SplatBuffer.CompressionLevels[compressionLevel].BytesPerCenter;\n      const bytesPerScale =\n        SplatBuffer.CompressionLevels[compressionLevel].BytesPerScale;\n      const bytesPerRotation =\n        SplatBuffer.CompressionLevels[compressionLevel].BytesPerRotation;\n      const bytesPerColor =\n        SplatBuffer.CompressionLevels[compressionLevel].BytesPerColor;\n\n      const centerBase = bufferOffset;\n      const scaleBase = centerBase + bytesPerCenter;\n      const rotationBase = scaleBase + bytesPerScale;\n      const colorBase = rotationBase + bytesPerRotation;\n      const sphericalHarmonicsBase = colorBase + bytesPerColor;\n\n      if (targetSplat[OFFSET_ROT0] !== undefined) {\n        tempRot.set(\n          targetSplat[OFFSET_ROT0],\n          targetSplat[OFFSET_ROT1],\n          targetSplat[OFFSET_ROT2],\n          targetSplat[OFFSET_ROT3],\n        );\n        tempRot.normalize();\n      } else {\n        tempRot.set(1.0, 0.0, 0.0, 0.0);\n      }\n\n      if (targetSplat[OFFSET_SCALE0] !== undefined) {\n        tempScale.set(\n          targetSplat[OFFSET_SCALE0] || 0,\n          targetSplat[OFFSET_SCALE1] || 0,\n          targetSplat[OFFSET_SCALE2] || 0,\n        );\n      } else {\n        tempScale.set(0, 0, 0);\n      }\n\n      if (compressionLevel === 0) {\n        const center = new Float32Array(\n          sectionBuffer,\n          centerBase,\n          SplatBuffer.CenterComponentCount,\n        );\n        const rot = new Float32Array(\n          sectionBuffer,\n          rotationBase,\n          SplatBuffer.RotationComponentCount,\n        );\n        const scale = new Float32Array(\n          sectionBuffer,\n          scaleBase,\n          SplatBuffer.ScaleComponentCount,\n        );\n\n        rot.set([tempRot.x, tempRot.y, tempRot.z, tempRot.w]);\n        scale.set([tempScale.x, tempScale.y, tempScale.z]);\n        center.set([\n          targetSplat[OFFSET_X],\n          targetSplat[OFFSET_Y],\n          targetSplat[OFFSET_Z],\n        ]);\n\n        if (sphericalHarmonicsDegree > 0) {\n          const shOut = new Float32Array(\n            sectionBuffer,\n            sphericalHarmonicsBase,\n            sphericalHarmonicsComponentsPerSplat,\n          );\n          if (sphericalHarmonicsDegree >= 1) {\n            for (let s = 0; s < 9; s++) {\n              shOut[s] = targetSplat[OFFSET_FRC0 + s] || 0;\n            }\n            if (sphericalHarmonicsDegree >= 2) {\n              for (let s = 0; s < 15; s++) {\n                shOut[s + 9] = targetSplat[OFFSET_FRC9 + s] || 0;\n              }\n            }\n          }\n        }\n      } else {\n        const center = new Uint16Array(\n          tempCenterBuffer,\n          0,\n          SplatBuffer.CenterComponentCount,\n        );\n        const rot = new Uint16Array(\n          tempRotationBuffer,\n          0,\n          SplatBuffer.RotationComponentCount,\n        );\n        const scale = new Uint16Array(\n          tempScaleBuffer,\n          0,\n          SplatBuffer.ScaleComponentCount,\n        );\n\n        rot.set([\n          toHalfFloat(tempRot.x),\n          toHalfFloat(tempRot.y),\n          toHalfFloat(tempRot.z),\n          toHalfFloat(tempRot.w),\n        ]);\n        scale.set([\n          toHalfFloat(tempScale.x),\n          toHalfFloat(tempScale.y),\n          toHalfFloat(tempScale.z),\n        ]);\n\n        bucketCenterDelta\n          .set(\n            targetSplat[OFFSET_X],\n            targetSplat[OFFSET_Y],\n            targetSplat[OFFSET_Z],\n          )\n          .sub(bucketCenter);\n        bucketCenterDelta.x = compressPositionOffset(\n          bucketCenterDelta.x,\n          compressionScaleFactor,\n          compressionScaleRange,\n        );\n        bucketCenterDelta.y = compressPositionOffset(\n          bucketCenterDelta.y,\n          compressionScaleFactor,\n          compressionScaleRange,\n        );\n        bucketCenterDelta.z = compressPositionOffset(\n          bucketCenterDelta.z,\n          compressionScaleFactor,\n          compressionScaleRange,\n        );\n        center.set([\n          bucketCenterDelta.x,\n          bucketCenterDelta.y,\n          bucketCenterDelta.z,\n        ]);\n\n        if (sphericalHarmonicsDegree > 0) {\n          const SHArrayType = compressionLevel === 1 ? Uint16Array : Uint8Array;\n          const bytesPerSHComponent = compressionLevel === 1 ? 2 : 1;\n          const shOut = new SHArrayType(\n            tempSHBuffer,\n            0,\n            sphericalHarmonicsComponentsPerSplat,\n          );\n          if (sphericalHarmonicsDegree >= 1) {\n            for (let s = 0; s < 9; s++) {\n              const srcVal = targetSplat[OFFSET_FRC0 + s] || 0;\n              shOut[s] =\n                compressionLevel === 1 ?\n                  toHalfFloat(srcVal) :\n                  toUint8(\n                      srcVal,\n                      minSphericalHarmonicsCoeff,\n                      maxSphericalHarmonicsCoeff,\n                    );\n            }\n            const degree1ByteCount = 9 * bytesPerSHComponent;\n            copyBetweenBuffers(\n              shOut.buffer,\n              0,\n              sectionBuffer,\n              sphericalHarmonicsBase,\n              degree1ByteCount,\n            );\n            if (sphericalHarmonicsDegree >= 2) {\n              for (let s = 0; s < 15; s++) {\n                const srcVal = targetSplat[OFFSET_FRC9 + s] || 0;\n                shOut[s + 9] =\n                  compressionLevel === 1 ?\n                    toHalfFloat(srcVal) :\n                    toUint8(\n                        srcVal,\n                        minSphericalHarmonicsCoeff,\n                        maxSphericalHarmonicsCoeff,\n                      );\n              }\n              copyBetweenBuffers(\n                shOut.buffer,\n                degree1ByteCount,\n                sectionBuffer,\n                sphericalHarmonicsBase + degree1ByteCount,\n                15 * bytesPerSHComponent,\n              );\n            }\n          }\n        }\n\n        copyBetweenBuffers(center.buffer, 0, sectionBuffer, centerBase, 6);\n        copyBetweenBuffers(scale.buffer, 0, sectionBuffer, scaleBase, 6);\n        copyBetweenBuffers(rot.buffer, 0, sectionBuffer, rotationBase, 8);\n      }\n\n      const rgba = new Uint8ClampedArray(tempColorBuffer, 0, 4);\n      rgba.set([\n        targetSplat[OFFSET_FDC0] || 0,\n        targetSplat[OFFSET_FDC1] || 0,\n        targetSplat[OFFSET_FDC2] || 0,\n      ]);\n      rgba[3] = targetSplat[OFFSET_OPACITY] || 0;\n\n      copyBetweenBuffers(rgba.buffer, 0, sectionBuffer, colorBase, 4);\n    };\n  })();\n\n  static generateFromUncompressedSplatArrays(\n    splatArrays,\n    minimumAlpha,\n    compressionLevel,\n    sceneCenter,\n    blockSize,\n    bucketSize,\n    options = [],\n  ) {\n    let shDegree = 0;\n    for (let sa = 0; sa < splatArrays.length; sa++) {\n      const splatArray = splatArrays[sa];\n      shDegree = Math.max(splatArray.sphericalHarmonicsDegree, shDegree);\n    }\n\n    let minSphericalHarmonicsCoeff;\n    let maxSphericalHarmonicsCoeff;\n\n    for (let sa = 0; sa < splatArrays.length; sa++) {\n      const splatArray = splatArrays[sa];\n      for (let i = 0; i < splatArray.splats.length; i++) {\n        const splat = splatArray.splats[i];\n        for (\n          let sc = UncompressedSplatArray.OFFSET.FRC0;\n          sc < UncompressedSplatArray.OFFSET.FRC23 && sc < splat.length;\n          sc++\n        ) {\n          if (\n            !minSphericalHarmonicsCoeff ||\n            splat[sc] < minSphericalHarmonicsCoeff\n          ) {\n            minSphericalHarmonicsCoeff = splat[sc];\n          }\n          if (\n            !maxSphericalHarmonicsCoeff ||\n            splat[sc] > maxSphericalHarmonicsCoeff\n          ) {\n            maxSphericalHarmonicsCoeff = splat[sc];\n          }\n        }\n      }\n    }\n\n    minSphericalHarmonicsCoeff =\n      minSphericalHarmonicsCoeff ||\n      -DefaultSphericalHarmonics8BitCompressionHalfRange;\n    maxSphericalHarmonicsCoeff =\n      maxSphericalHarmonicsCoeff ||\n      DefaultSphericalHarmonics8BitCompressionHalfRange;\n\n    const { bytesPerSplat } = SplatBuffer.calculateComponentStorage(\n      compressionLevel,\n      shDegree,\n    );\n    const compressionScaleRange =\n      SplatBuffer.CompressionLevels[compressionLevel].ScaleRange;\n\n    const sectionBuffers = [];\n    const sectionHeaderBuffers = [];\n    let totalSplatCount = 0;\n\n    for (let sa = 0; sa < splatArrays.length; sa++) {\n      const splatArray = splatArrays[sa];\n      const validSplats = new UncompressedSplatArray(shDegree);\n      for (let i = 0; i < splatArray.splatCount; i++) {\n        const targetSplat = splatArray.splats[i];\n        if (\n          (targetSplat[UncompressedSplatArray.OFFSET.OPACITY] || 0) >=\n          minimumAlpha\n        ) {\n          validSplats.addSplat(targetSplat);\n        }\n      }\n\n      const sectionOptions = options[sa] || {};\n      const sectionBlockSize =\n        (sectionOptions.blockSizeFactor || 1) *\n        (blockSize || SplatBuffer.BucketBlockSize);\n      const sectionBucketSize = Math.ceil(\n        (sectionOptions.bucketSizeFactor || 1) *\n          (bucketSize || SplatBuffer.BucketSize),\n      );\n\n      const bucketInfo = SplatBuffer.computeBucketsForUncompressedSplatArray(\n        validSplats,\n        sectionBlockSize,\n        sectionBucketSize,\n      );\n      const fullBucketCount = bucketInfo.fullBuckets.length;\n      const partiallyFullBucketLengths = bucketInfo.partiallyFullBuckets.map(\n        (bucket) => bucket.splats.length,\n      );\n      const partiallyFilledBucketCount = partiallyFullBucketLengths.length;\n      const buckets = [\n        ...bucketInfo.fullBuckets,\n        ...bucketInfo.partiallyFullBuckets,\n      ];\n\n      const sectionDataSizeBytes = validSplats.splats.length * bytesPerSplat;\n      const bucketMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketDataBytes =\n        compressionLevel >= 1 ?\n          buckets.length * SplatBuffer.BucketStorageSizeBytes +\n            bucketMetaDataSizeBytes :\n          0;\n      const sectionSizeBytes = sectionDataSizeBytes + bucketDataBytes;\n      const sectionBuffer = new ArrayBuffer(sectionSizeBytes);\n\n      const compressionScaleFactor =\n        compressionScaleRange / (sectionBlockSize * 0.5);\n      const bucketCenter = new THREE.Vector3();\n\n      let outSplatCount = 0;\n      for (let b = 0; b < buckets.length; b++) {\n        const bucket = buckets[b];\n        bucketCenter.fromArray(bucket.center);\n        for (let i = 0; i < bucket.splats.length; i++) {\n          let row = bucket.splats[i];\n          const targetSplat = validSplats.splats[row];\n          const bufferOffset = bucketDataBytes + outSplatCount * bytesPerSplat;\n          SplatBuffer.writeSplatDataToSectionBuffer(\n            targetSplat,\n            sectionBuffer,\n            bufferOffset,\n            compressionLevel,\n            shDegree,\n            bucketCenter,\n            compressionScaleFactor,\n            compressionScaleRange,\n            minSphericalHarmonicsCoeff,\n            maxSphericalHarmonicsCoeff,\n          );\n          outSplatCount++;\n        }\n      }\n      totalSplatCount += outSplatCount;\n\n      if (compressionLevel >= 1) {\n        const bucketMetaDataArray = new Uint32Array(\n          sectionBuffer,\n          0,\n          partiallyFullBucketLengths.length * 4,\n        );\n        for (let pfb = 0; pfb < partiallyFullBucketLengths.length; pfb++) {\n          bucketMetaDataArray[pfb] = partiallyFullBucketLengths[pfb];\n        }\n        const bucketArray = new Float32Array(\n          sectionBuffer,\n          bucketMetaDataSizeBytes,\n          buckets.length * SplatBuffer.BucketStorageSizeFloats,\n        );\n        for (let b = 0; b < buckets.length; b++) {\n          const bucket = buckets[b];\n          const base = b * 3;\n          bucketArray[base] = bucket.center[0];\n          bucketArray[base + 1] = bucket.center[1];\n          bucketArray[base + 2] = bucket.center[2];\n        }\n      }\n      sectionBuffers.push(sectionBuffer);\n\n      const sectionHeaderBuffer = new ArrayBuffer(\n        SplatBuffer.SectionHeaderSizeBytes,\n      );\n      SplatBuffer.writeSectionHeaderToBuffer(\n        {\n          maxSplatCount: outSplatCount,\n          splatCount: outSplatCount,\n          bucketSize: sectionBucketSize,\n          bucketCount: buckets.length,\n          bucketBlockSize: sectionBlockSize,\n          compressionScaleRange: compressionScaleRange,\n          storageSizeBytes: sectionSizeBytes,\n          fullBucketCount: fullBucketCount,\n          partiallyFilledBucketCount: partiallyFilledBucketCount,\n          sphericalHarmonicsDegree: shDegree,\n        },\n        compressionLevel,\n        sectionHeaderBuffer,\n        0,\n      );\n      sectionHeaderBuffers.push(sectionHeaderBuffer);\n    }\n\n    let sectionsCumulativeSizeBytes = 0;\n    for (let sectionBuffer of sectionBuffers) {\n      sectionsCumulativeSizeBytes += sectionBuffer.byteLength;\n    }\n    const unifiedBufferSize =\n      SplatBuffer.HeaderSizeBytes +\n      SplatBuffer.SectionHeaderSizeBytes * sectionBuffers.length +\n      sectionsCumulativeSizeBytes;\n    const unifiedBuffer = new ArrayBuffer(unifiedBufferSize);\n\n    SplatBuffer.writeHeaderToBuffer(\n      {\n        versionMajor: 0,\n        versionMinor: 1,\n        maxSectionCount: sectionBuffers.length,\n        sectionCount: sectionBuffers.length,\n        maxSplatCount: totalSplatCount,\n        splatCount: totalSplatCount,\n        compressionLevel: compressionLevel,\n        sceneCenter: sceneCenter,\n        minSphericalHarmonicsCoeff: minSphericalHarmonicsCoeff,\n        maxSphericalHarmonicsCoeff: maxSphericalHarmonicsCoeff,\n      },\n      unifiedBuffer,\n    );\n\n    let currentUnifiedBase = SplatBuffer.HeaderSizeBytes;\n    for (let sectionHeaderBuffer of sectionHeaderBuffers) {\n      new Uint8Array(\n        unifiedBuffer,\n        currentUnifiedBase,\n        SplatBuffer.SectionHeaderSizeBytes,\n      ).set(new Uint8Array(sectionHeaderBuffer));\n      currentUnifiedBase += SplatBuffer.SectionHeaderSizeBytes;\n    }\n\n    for (let sectionBuffer of sectionBuffers) {\n      new Uint8Array(\n        unifiedBuffer,\n        currentUnifiedBase,\n        sectionBuffer.byteLength,\n      ).set(new Uint8Array(sectionBuffer));\n      currentUnifiedBase += sectionBuffer.byteLength;\n    }\n\n    const splatBuffer = new SplatBuffer(unifiedBuffer);\n    return splatBuffer;\n  }\n\n  static computeBucketsForUncompressedSplatArray(\n    splatArray,\n    blockSize,\n    bucketSize,\n  ) {\n    let splatCount = splatArray.splatCount;\n    const halfBlockSize = blockSize / 2.0;\n\n    const min = new THREE.Vector3();\n    const max = new THREE.Vector3();\n\n    for (let i = 0; i < splatCount; i++) {\n      const targetSplat = splatArray.splats[i];\n      const center = [\n        targetSplat[UncompressedSplatArray.OFFSET.X],\n        targetSplat[UncompressedSplatArray.OFFSET.Y],\n        targetSplat[UncompressedSplatArray.OFFSET.Z],\n      ];\n      if (i === 0 || center[0] < min.x) min.x = center[0];\n      if (i === 0 || center[0] > max.x) max.x = center[0];\n      if (i === 0 || center[1] < min.y) min.y = center[1];\n      if (i === 0 || center[1] > max.y) max.y = center[1];\n      if (i === 0 || center[2] < min.z) min.z = center[2];\n      if (i === 0 || center[2] > max.z) max.z = center[2];\n    }\n\n    const dimensions = new THREE.Vector3().copy(max).sub(min);\n    const yBlocks = Math.ceil(dimensions.y / blockSize);\n    const zBlocks = Math.ceil(dimensions.z / blockSize);\n\n    const blockCenter = new THREE.Vector3();\n    const fullBuckets = [];\n    const partiallyFullBuckets = {};\n\n    for (let i = 0; i < splatCount; i++) {\n      const targetSplat = splatArray.splats[i];\n      const center = [\n        targetSplat[UncompressedSplatArray.OFFSET.X],\n        targetSplat[UncompressedSplatArray.OFFSET.Y],\n        targetSplat[UncompressedSplatArray.OFFSET.Z],\n      ];\n      const xBlock = Math.floor((center[0] - min.x) / blockSize);\n      const yBlock = Math.floor((center[1] - min.y) / blockSize);\n      const zBlock = Math.floor((center[2] - min.z) / blockSize);\n\n      blockCenter.x = xBlock * blockSize + min.x + halfBlockSize;\n      blockCenter.y = yBlock * blockSize + min.y + halfBlockSize;\n      blockCenter.z = zBlock * blockSize + min.z + halfBlockSize;\n\n      const bucketId = xBlock * (yBlocks * zBlocks) + yBlock * zBlocks + zBlock;\n      let bucket = partiallyFullBuckets[bucketId];\n      if (!bucket) {\n        partiallyFullBuckets[bucketId] = bucket = {\n          splats: [],\n          center: blockCenter.toArray(),\n        };\n      }\n\n      bucket.splats.push(i);\n      if (bucket.splats.length >= bucketSize) {\n        fullBuckets.push(bucket);\n        partiallyFullBuckets[bucketId] = null;\n      }\n    }\n\n    const partiallyFullBucketArray = [];\n    for (let bucketId in partiallyFullBuckets) {\n      if (partiallyFullBuckets.hasOwnProperty(bucketId)) {\n        const bucket = partiallyFullBuckets[bucketId];\n        if (bucket) {\n          partiallyFullBucketArray.push(bucket);\n        }\n      }\n    }\n\n    return {\n      fullBuckets: fullBuckets,\n      partiallyFullBuckets: partiallyFullBucketArray,\n    };\n  }\n}\n","import { UncompressedSplatArray } from '../UncompressedSplatArray.js';\nimport { SplatBuffer } from '../SplatBuffer.js';\nimport { clamp } from '../../Util.js';\nimport * as THREE from 'three';\n\nconst HeaderMagicBytes = new Uint8Array([112, 108, 121, 10]);\nconst HeaderEndTokenBytes = new Uint8Array([\n  10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10,\n]);\nconst HeaderEndToken = 'end_header';\n\nconst DataTypeMap = new Map([\n  ['char', Int8Array],\n  ['uchar', Uint8Array],\n  ['short', Int16Array],\n  ['ushort', Uint16Array],\n  ['int', Int32Array],\n  ['uint', Uint32Array],\n  ['float', Float32Array],\n  ['double', Float64Array],\n]);\n\nconst unpackUnorm = (value, bits) => {\n  const t = (1 << bits) - 1;\n  return (value & t) / t;\n};\n\nconst unpack111011 = (result, value) => {\n  result.x = unpackUnorm(value >>> 21, 11);\n  result.y = unpackUnorm(value >>> 11, 10);\n  result.z = unpackUnorm(value, 11);\n};\n\nconst unpack8888 = (result, value) => {\n  result.x = unpackUnorm(value >>> 24, 8);\n  result.y = unpackUnorm(value >>> 16, 8);\n  result.z = unpackUnorm(value >>> 8, 8);\n  result.w = unpackUnorm(value, 8);\n};\n\n// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)\nconst unpackRot = (result, value) => {\n  const norm = 1.0 / (Math.sqrt(2) * 0.5);\n  const a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;\n  const b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;\n  const c = (unpackUnorm(value, 10) - 0.5) * norm;\n  const m = Math.sqrt(1.0 - (a * a + b * b + c * c));\n\n  switch (value >>> 30) {\n    case 0:\n      result.set(m, a, b, c);\n      break;\n    case 1:\n      result.set(a, m, b, c);\n      break;\n    case 2:\n      result.set(a, b, m, c);\n      break;\n    case 3:\n      result.set(a, b, c, m);\n      break;\n  }\n};\n\nconst lerp = (a, b, t) => {\n  return a * (1 - t) + b * t;\n};\n\nconst getElementPropStorage = (element, name) => {\n  return element.properties.find((p) => p.name === name && p.storage)?.storage;\n};\n\nexport class PlayCanvasCompressedPlyParser {\n  static decodeHeaderText(headerText) {\n    let element;\n    let chunkElement;\n    let vertexElement;\n\n    const headerLines = headerText\n      .split('\\n')\n      .filter((line) => !line.startsWith('comment '));\n\n    let bytesPerSplat = 0;\n    let done = false;\n    for (let i = 1; i < headerLines.length; ++i) {\n      const words = headerLines[i].split(' ');\n\n      switch (words[0]) {\n        case 'format':\n          if (words[1] !== 'binary_little_endian') {\n            throw new Error('Unsupported ply format');\n          }\n          break;\n        case 'element':\n          element = {\n            name: words[1],\n            count: parseInt(words[2], 10),\n            properties: [],\n            storageSizeBytes: 0,\n          };\n          if (element.name === 'chunk') chunkElement = element;\n          else if (element.name === 'vertex') vertexElement = element;\n          break;\n        case 'property': {\n          if (!DataTypeMap.has(words[1])) {\n            throw new Error(\n              `Unrecognized property data type '${words[1]}' in ply header`,\n            );\n          }\n          const StorageType = DataTypeMap.get(words[1]);\n          const storageSizeByes = StorageType.BYTES_PER_ELEMENT * element.count;\n          if (element.name === 'vertex') {\n            bytesPerSplat += StorageType.BYTES_PER_ELEMENT;\n          }\n          element.properties.push({\n            type: words[1],\n            name: words[2],\n            storage: null,\n            byteSize: StorageType.BYTES_PER_ELEMENT,\n            storageSizeByes: storageSizeByes,\n          });\n          element.storageSizeBytes += storageSizeByes;\n          break;\n        }\n        case HeaderEndToken:\n          done = true;\n          break;\n        default:\n          throw new Error(\n            `Unrecognized header value '${words[0]}' in ply header`,\n          );\n      }\n      if (done) break;\n    }\n\n    return {\n      chunkElement: chunkElement,\n      vertexElement: vertexElement,\n      bytesPerSplat: bytesPerSplat,\n      headerSizeBytes:\n        headerText.indexOf(HeaderEndToken) + HeaderEndToken.length + 1,\n      sphericalHarmonicsDegree: 0,\n    };\n  }\n\n  static decodeHeader(plyBuffer) {\n    /**\n     * Searches for the first occurrence of a sequence within a buffer.\n     * @example\n     * find(new Uint8Array([1, 2, 3, 4]), new Uint8Array([3, 4])); // 2\n     * @param {Uint8Array} buf - The buffer in which to search.\n     * @param {Uint8Array} search - The sequence to search for.\n     * @return {number} The index of the first occurrence of the search sequence in the buffer, or -1 if not found.\n     */\n    const find = (buf, search) => {\n      const endIndex = buf.length - search.length;\n      let i;\n      let j;\n      for (i = 0; i <= endIndex; ++i) {\n        for (j = 0; j < search.length; ++j) {\n          if (buf[i + j] !== search[j]) {\n            break;\n          }\n        }\n        if (j === search.length) {\n          return i;\n        }\n      }\n      return -1;\n    };\n\n    /**\n     * Checks if array 'a' starts with the same elements as array 'b'.\n     * @example\n     * startsWith(new Uint8Array([1, 2, 3, 4]), new Uint8Array([1, 2])); // true\n     * @param {Uint8Array} a - The array to check against.\n     * @param {Uint8Array} b - The array of elements to look for at the start of 'a'.\n     * @return {boolean} - True if 'a' starts with all elements of 'b', otherwise false.\n     */\n    const startsWith = (a, b) => {\n      if (a.length < b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < b.length; ++i) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    let buf = new Uint8Array(plyBuffer);\n    let endHeaderTokenOffset;\n\n    if (\n      buf.length >= HeaderMagicBytes.length &&\n      !startsWith(buf, HeaderMagicBytes)\n    ) {\n      throw new Error('Invalid PLY header');\n    }\n\n    endHeaderTokenOffset = find(buf, HeaderEndTokenBytes);\n    if (endHeaderTokenOffset === -1) {\n      throw new Error('End of PLY header not found');\n    }\n\n    const headerText = new TextDecoder('ascii').decode(\n      buf.slice(0, endHeaderTokenOffset),\n    );\n\n    const { chunkElement, vertexElement, bytesPerSplat } =\n      PlayCanvasCompressedPlyParser.decodeHeaderText(headerText);\n\n    return {\n      headerSizeBytes: endHeaderTokenOffset + HeaderEndTokenBytes.length,\n      bytesPerSplat: bytesPerSplat,\n      chunkElement: chunkElement,\n      vertexElement: vertexElement,\n    };\n  }\n\n  static readElementData(\n    element,\n    readBuffer,\n    readOffset,\n    fromIndex,\n    toIndex,\n    propertyFilter = null,\n  ) {\n    let dataView =\n      readBuffer instanceof DataView ? readBuffer : new DataView(readBuffer);\n\n    fromIndex = fromIndex || 0;\n    toIndex = toIndex || element.count - 1;\n    for (let e = fromIndex; e <= toIndex; ++e) {\n      for (let j = 0; j < element.properties.length; ++j) {\n        const property = element.properties[j];\n\n        const StorageType = DataTypeMap.get(property.type);\n        const requiredStorageSizeBytes =\n          StorageType.BYTES_PER_ELEMENT * element.count;\n        if (\n          (!property.storage ||\n            property.storage.byteLength < requiredStorageSizeBytes) &&\n          (!propertyFilter || propertyFilter(property.name))\n        ) {\n          property.storage = new StorageType(element.count);\n        }\n\n        if (property.storage) {\n          switch (property.type) {\n            case 'char':\n              property.storage[e] = dataView.getInt8(readOffset);\n              break;\n            case 'uchar':\n              property.storage[e] = dataView.getUint8(readOffset);\n              break;\n            case 'short':\n              property.storage[e] = dataView.getInt16(readOffset, true);\n              break;\n            case 'ushort':\n              property.storage[e] = dataView.getUint16(readOffset, true);\n              break;\n            case 'int':\n              property.storage[e] = dataView.getInt32(readOffset, true);\n              break;\n            case 'uint':\n              property.storage[e] = dataView.getUint32(readOffset, true);\n              break;\n            case 'float':\n              property.storage[e] = dataView.getFloat32(readOffset, true);\n              break;\n            case 'double':\n              property.storage[e] = dataView.getFloat64(readOffset, true);\n              break;\n          }\n        }\n\n        readOffset += property.byteSize;\n      }\n    }\n\n    return readOffset;\n  }\n\n  static readPly(plyBuffer, propertyFilter = null) {\n    const header = PlayCanvasCompressedPlyParser.decodeHeader(plyBuffer);\n\n    let readIndex = PlayCanvasCompressedPlyParser.readElementData(\n      header.chunkElement,\n      plyBuffer,\n      header.headerSizeBytes,\n      null,\n      null,\n      propertyFilter,\n    );\n    PlayCanvasCompressedPlyParser.readElementData(\n      header.vertexElement,\n      plyBuffer,\n      readIndex,\n      null,\n      null,\n      propertyFilter,\n    );\n\n    return {\n      chunkElement: header.chunkElement,\n      vertexElement: header.vertexElement,\n    };\n  }\n\n  static getElementStorageArrays(chunkElement, vertexElement) {\n    const minX = getElementPropStorage(chunkElement, 'min_x');\n    const minY = getElementPropStorage(chunkElement, 'min_y');\n    const minZ = getElementPropStorage(chunkElement, 'min_z');\n    const maxX = getElementPropStorage(chunkElement, 'max_x');\n    const maxY = getElementPropStorage(chunkElement, 'max_y');\n    const maxZ = getElementPropStorage(chunkElement, 'max_z');\n    const minScaleX = getElementPropStorage(chunkElement, 'min_scale_x');\n    const minScaleY = getElementPropStorage(chunkElement, 'min_scale_y');\n    const minScaleZ = getElementPropStorage(chunkElement, 'min_scale_z');\n    const maxScaleX = getElementPropStorage(chunkElement, 'max_scale_x');\n    const maxScaleY = getElementPropStorage(chunkElement, 'max_scale_y');\n    const maxScaleZ = getElementPropStorage(chunkElement, 'max_scale_z');\n    const position = getElementPropStorage(vertexElement, 'packed_position');\n    const rotation = getElementPropStorage(vertexElement, 'packed_rotation');\n    const scale = getElementPropStorage(vertexElement, 'packed_scale');\n    const color = getElementPropStorage(vertexElement, 'packed_color');\n    return {\n      positionExtremes: {\n        minX,\n        maxX,\n        minY,\n        maxY,\n        minZ,\n        maxZ,\n      },\n      scaleExtremes: {\n        minScaleX,\n        maxScaleX,\n        minScaleY,\n        maxScaleY,\n        minScaleZ,\n        maxScaleZ,\n      },\n      position,\n      rotation,\n      scale,\n      color,\n    };\n  }\n\n  static decompressSplat = (function() {\n    const p = new THREE.Vector3();\n    const r = new THREE.Quaternion();\n    const s = new THREE.Vector3();\n    const c = new THREE.Vector4();\n\n    const OFFSET = UncompressedSplatArray.OFFSET;\n\n    return function(\n      index,\n      chunkSplatIndexOffset,\n      positionArray,\n      positionExtremes,\n      scaleArray,\n      scaleExtremes,\n      rotationArray,\n      colorArray,\n      outSplat,\n    ) {\n      outSplat = outSplat || UncompressedSplatArray.createSplat();\n\n      const chunkIndex = Math.floor((chunkSplatIndexOffset + index) / 256);\n\n      unpack111011(p, positionArray[index]);\n      unpackRot(r, rotationArray[index]);\n      unpack111011(s, scaleArray[index]);\n      unpack8888(c, colorArray[index]);\n\n      outSplat[OFFSET.X] = lerp(\n        positionExtremes.minX[chunkIndex],\n        positionExtremes.maxX[chunkIndex],\n        p.x,\n      );\n      outSplat[OFFSET.Y] = lerp(\n        positionExtremes.minY[chunkIndex],\n        positionExtremes.maxY[chunkIndex],\n        p.y,\n      );\n      outSplat[OFFSET.Z] = lerp(\n        positionExtremes.minZ[chunkIndex],\n        positionExtremes.maxZ[chunkIndex],\n        p.z,\n      );\n\n      outSplat[OFFSET.ROTATION0] = r.x;\n      outSplat[OFFSET.ROTATION1] = r.y;\n      outSplat[OFFSET.ROTATION2] = r.z;\n      outSplat[OFFSET.ROTATION3] = r.w;\n\n      outSplat[OFFSET.SCALE0] = Math.exp(\n        lerp(\n          scaleExtremes.minScaleX[chunkIndex],\n          scaleExtremes.maxScaleX[chunkIndex],\n          s.x,\n        ),\n      );\n      outSplat[OFFSET.SCALE1] = Math.exp(\n        lerp(\n          scaleExtremes.minScaleY[chunkIndex],\n          scaleExtremes.maxScaleY[chunkIndex],\n          s.y,\n        ),\n      );\n      outSplat[OFFSET.SCALE2] = Math.exp(\n        lerp(\n          scaleExtremes.minScaleZ[chunkIndex],\n          scaleExtremes.maxScaleZ[chunkIndex],\n          s.z,\n        ),\n      );\n\n      outSplat[OFFSET.FDC0] = clamp(Math.floor(c.x * 255), 0, 255);\n      outSplat[OFFSET.FDC1] = clamp(Math.floor(c.y * 255), 0, 255);\n      outSplat[OFFSET.FDC2] = clamp(Math.floor(c.z * 255), 0, 255);\n      outSplat[OFFSET.OPACITY] = clamp(Math.floor(c.w * 255), 0, 255);\n\n      return outSplat;\n    };\n  })();\n\n  static parseToUncompressedSplatBufferSection(\n    chunkElement,\n    vertexElement,\n    fromIndex,\n    toIndex,\n    chunkSplatIndexOffset,\n    vertexDataBuffer,\n    veretxReadOffset,\n    outBuffer,\n    outOffset,\n    propertyFilter = null,\n  ) {\n    PlayCanvasCompressedPlyParser.readElementData(\n      vertexElement,\n      vertexDataBuffer,\n      veretxReadOffset,\n      fromIndex,\n      toIndex,\n      propertyFilter,\n    );\n\n    const outBytesPerSplat =\n      SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[0]\n        .BytesPerSplat;\n\n    const {\n      positionExtremes,\n      scaleExtremes,\n      position,\n      rotation,\n      scale,\n      color,\n    } = PlayCanvasCompressedPlyParser.getElementStorageArrays(\n      chunkElement,\n      vertexElement,\n    );\n\n    const tempSplat = UncompressedSplatArray.createSplat();\n\n    for (let i = fromIndex; i <= toIndex; ++i) {\n      PlayCanvasCompressedPlyParser.decompressSplat(\n        i,\n        chunkSplatIndexOffset,\n        position,\n        positionExtremes,\n        scale,\n        scaleExtremes,\n        rotation,\n        color,\n        tempSplat,\n      );\n      const outBase = i * outBytesPerSplat + outOffset;\n      SplatBuffer.writeSplatDataToSectionBuffer(\n        tempSplat,\n        outBuffer,\n        outBase,\n        0,\n        0,\n      );\n    }\n  }\n\n  static parseToUncompressedSplatArraySection(\n    chunkElement,\n    vertexElement,\n    fromIndex,\n    toIndex,\n    chunkSplatIndexOffset,\n    vertexDataBuffer,\n    veretxReadOffset,\n    splatArray,\n    propertyFilter = null,\n  ) {\n    PlayCanvasCompressedPlyParser.readElementData(\n      vertexElement,\n      vertexDataBuffer,\n      veretxReadOffset,\n      fromIndex,\n      toIndex,\n      propertyFilter,\n    );\n\n    const {\n      positionExtremes,\n      scaleExtremes,\n      position,\n      rotation,\n      scale,\n      color,\n    } = PlayCanvasCompressedPlyParser.getElementStorageArrays(\n      chunkElement,\n      vertexElement,\n    );\n\n    for (let i = fromIndex; i <= toIndex; ++i) {\n      const tempSplat = UncompressedSplatArray.createSplat();\n      PlayCanvasCompressedPlyParser.decompressSplat(\n        i,\n        chunkSplatIndexOffset,\n        position,\n        positionExtremes,\n        scale,\n        scaleExtremes,\n        rotation,\n        color,\n        tempSplat,\n      );\n      splatArray.addSplat(tempSplat);\n    }\n  }\n\n  static parseToUncompressedSplatArray(plyBuffer) {\n    const { chunkElement, vertexElement } =\n      PlayCanvasCompressedPlyParser.readPly(plyBuffer);\n\n    const splatArray = new UncompressedSplatArray();\n\n    const {\n      positionExtremes,\n      scaleExtremes,\n      position,\n      rotation,\n      scale,\n      color,\n    } = PlayCanvasCompressedPlyParser.getElementStorageArrays(\n      chunkElement,\n      vertexElement,\n    );\n\n    for (let i = 0; i < vertexElement.count; ++i) {\n      splatArray.addDefaultSplat();\n      const newSplat = splatArray.getSplat(splatArray.splatCount - 1);\n\n      PlayCanvasCompressedPlyParser.decompressSplat(\n        i,\n        0,\n        position,\n        positionExtremes,\n        scale,\n        scaleExtremes,\n        rotation,\n        color,\n        newSplat,\n      );\n    }\n\n    const mat = new THREE.Matrix4();\n    mat.identity();\n\n    return splatArray;\n  }\n}\n","export const PlyFormat = {\n  INRIAV1: 0,\n  INRIAV2: 1,\n  PlayCanvasCompressed: 2,\n};\n","import { PlyFormat } from './PlyFormat.js';\n\nconst [\n  FieldSizeIdDouble,\n  FieldSizeIdInt,\n  FieldSizeIdUInt,\n  FieldSizeIdFloat,\n  FieldSizeIdShort,\n  FieldSizeIdUShort,\n  FieldSizeIdUChar,\n] = [0, 1, 2, 3, 4, 5, 6];\n\nconst FieldSizeStringMap = {\n  double: FieldSizeIdDouble,\n  int: FieldSizeIdInt,\n  uint: FieldSizeIdUInt,\n  float: FieldSizeIdFloat,\n  short: FieldSizeIdShort,\n  ushort: FieldSizeIdUShort,\n  uchar: FieldSizeIdUChar,\n};\n\nconst FieldSize = {\n  [FieldSizeIdDouble]: 8,\n  [FieldSizeIdInt]: 4,\n  [FieldSizeIdUInt]: 4,\n  [FieldSizeIdFloat]: 4,\n  [FieldSizeIdShort]: 2,\n  [FieldSizeIdUShort]: 2,\n  [FieldSizeIdUChar]: 1,\n};\n\nexport class PlyParserUtils {\n  static HeaderEndToken = 'end_header';\n\n  constructor() {}\n\n  decodeSectionHeader(headerLines, fieldNameIdMap, headerStartLine = 0) {\n    const extractedLines = [];\n\n    let processingSection = false;\n    let headerEndLine = -1;\n    let vertexCount = 0;\n    let endOfHeader = false;\n    let sectionName = null;\n\n    const fieldIds = [];\n    const fieldTypes = [];\n    const allFieldNames = [];\n    const usedFieldNames = [];\n    const fieldTypesByName = {};\n\n    for (let i = headerStartLine; i < headerLines.length; i++) {\n      const line = headerLines[i].trim();\n      if (line.startsWith('element')) {\n        if (processingSection) {\n          headerEndLine--;\n          break;\n        } else {\n          processingSection = true;\n          headerStartLine = i;\n          headerEndLine = i;\n          const lineComponents = line.split(' ');\n          let validComponents = 0;\n          for (let lineComponent of lineComponents) {\n            const trimmedComponent = lineComponent.trim();\n            if (trimmedComponent.length > 0) {\n              validComponents++;\n              if (validComponents === 2) {\n                sectionName = trimmedComponent;\n              } else if (validComponents === 3) {\n                vertexCount = parseInt(trimmedComponent);\n              }\n            }\n          }\n        }\n      } else if (line.startsWith('property')) {\n        const fieldMatch = line.match(/(\\w+)\\s+(\\w+)\\s+(\\w+)/);\n        if (fieldMatch) {\n          const fieldTypeStr = fieldMatch[2];\n          const fieldName = fieldMatch[3];\n          allFieldNames.push(fieldName);\n          const fieldId = fieldNameIdMap[fieldName];\n          fieldTypesByName[fieldName] = fieldTypeStr;\n          const fieldType = FieldSizeStringMap[fieldTypeStr];\n          if (fieldId !== undefined) {\n            usedFieldNames.push(fieldName);\n            fieldIds.push(fieldId);\n            fieldTypes[fieldId] = fieldType;\n          }\n        }\n      }\n      if (line === PlyParserUtils.HeaderEndToken) {\n        endOfHeader = true;\n        break;\n      }\n      if (processingSection) {\n        extractedLines.push(line);\n        headerEndLine++;\n      }\n    }\n\n    const fieldOffsets = [];\n    let bytesPerVertex = 0;\n    for (let fieldName of allFieldNames) {\n      const fieldType = fieldTypesByName[fieldName];\n      if (fieldTypesByName.hasOwnProperty(fieldName)) {\n        const fieldId = fieldNameIdMap[fieldName];\n        if (fieldId !== undefined) {\n          fieldOffsets[fieldId] = bytesPerVertex;\n        }\n      }\n      bytesPerVertex += FieldSize[FieldSizeStringMap[fieldType]];\n    }\n\n    const sphericalHarmonics = this.decodeSphericalHarmonicsFromSectionHeader(\n      allFieldNames,\n      fieldNameIdMap,\n    );\n\n    return {\n      headerLines: extractedLines,\n      headerStartLine: headerStartLine,\n      headerEndLine: headerEndLine,\n      fieldTypes: fieldTypes,\n      fieldIds: fieldIds,\n      fieldOffsets: fieldOffsets,\n      bytesPerVertex: bytesPerVertex,\n      vertexCount: vertexCount,\n      dataSizeBytes: bytesPerVertex * vertexCount,\n      endOfHeader: endOfHeader,\n      sectionName: sectionName,\n      sphericalHarmonicsDegree: sphericalHarmonics.degree,\n      sphericalHarmonicsCoefficientsPerChannel:\n        sphericalHarmonics.coefficientsPerChannel,\n      sphericalHarmonicsDegree1Fields: sphericalHarmonics.degree1Fields,\n      sphericalHarmonicsDegree2Fields: sphericalHarmonics.degree2Fields,\n    };\n  }\n\n  decodeSphericalHarmonicsFromSectionHeader(fieldNames, fieldNameIdMap) {\n    let sphericalHarmonicsFieldCount = 0;\n    let coefficientsPerChannel = 0;\n    for (let fieldName of fieldNames) {\n      if (fieldName.startsWith('f_rest')) sphericalHarmonicsFieldCount++;\n    }\n    coefficientsPerChannel = sphericalHarmonicsFieldCount / 3;\n    let degree = 0;\n    if (coefficientsPerChannel >= 3) degree = 1;\n    if (coefficientsPerChannel >= 8) degree = 2;\n\n    let degree1Fields = [];\n    let degree2Fields = [];\n\n    for (let rgb = 0; rgb < 3; rgb++) {\n      if (degree >= 1) {\n        for (let i = 0; i < 3; i++) {\n          degree1Fields.push(\n            fieldNameIdMap['f_rest_' + (i + coefficientsPerChannel * rgb)],\n          );\n        }\n      }\n      if (degree >= 2) {\n        for (let i = 0; i < 5; i++) {\n          degree2Fields.push(\n            fieldNameIdMap['f_rest_' + (i + coefficientsPerChannel * rgb + 3)],\n          );\n        }\n      }\n    }\n\n    return {\n      degree: degree,\n      coefficientsPerChannel: coefficientsPerChannel,\n      degree1Fields: degree1Fields,\n      degree2Fields: degree2Fields,\n    };\n  }\n\n  static getHeaderSectionNames(headerLines) {\n    const sectionNames = [];\n    for (let headerLine of headerLines) {\n      if (headerLine.startsWith('element')) {\n        const lineComponents = headerLine.split(' ');\n        let validComponents = 0;\n        for (let lineComponent of lineComponents) {\n          const trimmedComponent = lineComponent.trim();\n          if (trimmedComponent.length > 0) {\n            validComponents++;\n            if (validComponents === 2) {\n              sectionNames.push(trimmedComponent);\n            }\n          }\n        }\n      }\n    }\n    return sectionNames;\n  }\n\n  static checkTextForEndHeader(endHeaderTestText) {\n    if (endHeaderTestText.includes(PlyParserUtils.HeaderEndToken)) {\n      return true;\n    }\n    return false;\n  }\n\n  static checkBufferForEndHeader(buffer, searchOfset, chunkSize, decoder) {\n    const endHeaderTestChunk = new Uint8Array(\n      buffer,\n      Math.max(0, searchOfset - chunkSize),\n      chunkSize,\n    );\n    const endHeaderTestText = decoder.decode(endHeaderTestChunk);\n    return PlyParserUtils.checkTextForEndHeader(endHeaderTestText);\n  }\n\n  static extractHeaderFromBufferToText(plyBuffer) {\n    const decoder = new TextDecoder();\n    let headerOffset = 0;\n    let headerText = '';\n    const readChunkSize = 100;\n\n    while (true) {\n      if (headerOffset + readChunkSize >= plyBuffer.byteLength) {\n        throw new Error(\n          'End of file reached while searching for end of header',\n        );\n      }\n      const headerChunk = new Uint8Array(\n        plyBuffer,\n        headerOffset,\n        readChunkSize,\n      );\n      headerText += decoder.decode(headerChunk);\n      headerOffset += readChunkSize;\n\n      if (\n        PlyParserUtils.checkBufferForEndHeader(\n          plyBuffer,\n          headerOffset,\n          readChunkSize * 2,\n          decoder,\n        )\n      ) {\n        break;\n      }\n    }\n\n    return headerText;\n  }\n\n  readHeaderFromBuffer(plyBuffer) {\n    const decoder = new TextDecoder();\n    let headerOffset = 0;\n    let headerText = '';\n    const readChunkSize = 100;\n\n    while (true) {\n      if (headerOffset + readChunkSize >= plyBuffer.byteLength) {\n        throw new Error(\n          'End of file reached while searching for end of header',\n        );\n      }\n      const headerChunk = new Uint8Array(\n        plyBuffer,\n        headerOffset,\n        readChunkSize,\n      );\n      headerText += decoder.decode(headerChunk);\n      headerOffset += readChunkSize;\n\n      if (\n        PlyParserUtils.checkBufferForEndHeader(\n          plyBuffer,\n          headerOffset,\n          readChunkSize * 2,\n          decoder,\n        )\n      ) {\n        break;\n      }\n    }\n\n    return headerText;\n  }\n\n  static convertHeaderTextToLines(headerText) {\n    const headerLines = headerText.split('\\n');\n    const prunedLines = [];\n    for (let i = 0; i < headerLines.length; i++) {\n      const line = headerLines[i].trim();\n      prunedLines.push(line);\n      if (line === PlyParserUtils.HeaderEndToken) {\n        break;\n      }\n    }\n    return prunedLines;\n  }\n\n  static determineHeaderFormatFromHeaderText(headertText) {\n    const headerLines = PlyParserUtils.convertHeaderTextToLines(headertText);\n    let format = PlyFormat.INRIAV1;\n    for (let i = 0; i < headerLines.length; i++) {\n      const line = headerLines[i].trim();\n      if (\n        line.startsWith('element chunk') ||\n        line.match(/[A-Za-z]*packed_[A-Za-z]*/)\n      ) {\n        format = PlyFormat.PlayCanvasCompressed;\n      } else if (line.startsWith('element codebook_centers')) {\n        format = PlyFormat.INRIAV2;\n      } else if (line === PlyParserUtils.HeaderEndToken) {\n        break;\n      }\n    }\n    return format;\n  }\n\n  static determineHeaderFormatFromPlyBuffer(plyBuffer) {\n    const headertText = PlyParserUtils.extractHeaderFromBufferToText(plyBuffer);\n    return PlyParserUtils.determineHeaderFormatFromHeaderText(headertText);\n  }\n\n  static readVertex(\n    vertexData,\n    header,\n    row,\n    dataOffset,\n    fieldsToRead,\n    rawVertex,\n    normalize = true,\n  ) {\n    const offset = row * header.bytesPerVertex + dataOffset;\n    const fieldOffsets = header.fieldOffsets;\n    const fieldTypes = header.fieldTypes;\n    for (let fieldId of fieldsToRead) {\n      const fieldType = fieldTypes[fieldId];\n      if (fieldType === FieldSizeIdFloat) {\n        rawVertex[fieldId] = vertexData.getFloat32(\n          offset + fieldOffsets[fieldId],\n          true,\n        );\n      } else if (fieldType === FieldSizeIdShort) {\n        rawVertex[fieldId] = vertexData.getInt16(\n          offset + fieldOffsets[fieldId],\n          true,\n        );\n      } else if (fieldType === FieldSizeIdUShort) {\n        rawVertex[fieldId] = vertexData.getUint16(\n          offset + fieldOffsets[fieldId],\n          true,\n        );\n      } else if (fieldType === FieldSizeIdInt) {\n        rawVertex[fieldId] = vertexData.getInt32(\n          offset + fieldOffsets[fieldId],\n          true,\n        );\n      } else if (fieldType === FieldSizeIdUInt) {\n        rawVertex[fieldId] = vertexData.getUint32(\n          offset + fieldOffsets[fieldId],\n          true,\n        );\n      } else if (fieldType === FieldSizeIdUChar) {\n        if (normalize) {\n          rawVertex[fieldId] =\n            vertexData.getUint8(offset + fieldOffsets[fieldId]) / 255.0;\n        } else {\n          rawVertex[fieldId] = vertexData.getUint8(\n            offset + fieldOffsets[fieldId],\n          );\n        }\n      }\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { clamp } from '../../Util.js';\nimport { UncompressedSplatArray } from '../UncompressedSplatArray.js';\nimport { SplatBuffer } from '../SplatBuffer.js';\nimport { PlyParserUtils } from './PlyParserUtils.js';\n\nconst BaseFieldNamesToRead = [\n  'scale_0',\n  'scale_1',\n  'scale_2',\n  'rot_0',\n  'rot_1',\n  'rot_2',\n  'rot_3',\n  'x',\n  'y',\n  'z',\n  'f_dc_0',\n  'f_dc_1',\n  'f_dc_2',\n  'opacity',\n  'red',\n  'green',\n  'blue',\n  'f_rest_0',\n];\n\nconst BaseFieldsToReadIndexes = BaseFieldNamesToRead.map((e, i) => i);\n\nconst [\n  SCALE_0,\n  SCALE_1,\n  SCALE_2,\n  ROT_0,\n  ROT_1,\n  ROT_2,\n  ROT_3,\n  X,\n  Y,\n  Z,\n  F_DC_0,\n  F_DC_1,\n  F_DC_2,\n  OPACITY,\n  RED,\n  GREEN,\n  BLUE,\n  F_REST_0,\n] = BaseFieldsToReadIndexes;\n\nexport class INRIAV1PlyParser {\n  constructor() {\n    this.plyParserutils = new PlyParserUtils();\n  }\n\n  decodeHeaderLines(headerLines) {\n    let shLineCount = 0;\n    headerLines.forEach((line) => {\n      if (line.includes('f_rest_')) shLineCount++;\n    });\n\n    let shFieldsToReadCount = 0;\n    if (shLineCount >= 45) {\n      shFieldsToReadCount = 45;\n    } else if (shLineCount >= 24) {\n      shFieldsToReadCount = 24;\n    } else if (shLineCount >= 9) {\n      shFieldsToReadCount = 9;\n    }\n\n    const shFieldIndexesToMap = Array.from(\n      Array(Math.max(shFieldsToReadCount - 1, 0)),\n    );\n    let shRemainingFieldNamesToRead = shFieldIndexesToMap.map(\n      (element, index) => `f_rest_${index + 1}`,\n    );\n\n    const fieldNamesToRead = [\n      ...BaseFieldNamesToRead,\n      ...shRemainingFieldNamesToRead,\n    ];\n    const fieldsToReadIndexes = fieldNamesToRead.map((e, i) => i);\n\n    const fieldNameIdMap = fieldsToReadIndexes.reduce((acc, element) => {\n      acc[fieldNamesToRead[element]] = element;\n      return acc;\n    }, {});\n    const header = this.plyParserutils.decodeSectionHeader(\n      headerLines,\n      fieldNameIdMap,\n      0,\n    );\n    header.splatCount = header.vertexCount;\n    header.bytesPerSplat = header.bytesPerVertex;\n    header.fieldsToReadIndexes = fieldsToReadIndexes;\n    return header;\n  }\n\n  decodeHeaderText(headerText) {\n    const headerLines = PlyParserUtils.convertHeaderTextToLines(headerText);\n    const header = this.decodeHeaderLines(headerLines);\n    header.headerText = headerText;\n    header.headerSizeBytes =\n      headerText.indexOf(PlyParserUtils.HeaderEndToken) +\n      PlyParserUtils.HeaderEndToken.length +\n      1;\n    return header;\n  }\n\n  decodeHeaderFromBuffer(plyBuffer) {\n    const headerText = this.plyParserutils.readHeaderFromBuffer(plyBuffer);\n    return this.decodeHeaderText(headerText);\n  }\n\n  findSplatData(plyBuffer, header) {\n    return new DataView(plyBuffer, header.headerSizeBytes);\n  }\n\n  parseToUncompressedSplatBufferSection(\n    header,\n    fromSplat,\n    toSplat,\n    splatData,\n    splatDataOffset,\n    toBuffer,\n    toOffset,\n    outSphericalHarmonicsDegree = 0,\n  ) {\n    outSphericalHarmonicsDegree = Math.min(\n      outSphericalHarmonicsDegree,\n      header.sphericalHarmonicsDegree,\n    );\n    const outBytesPerSplat =\n      SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[\n        outSphericalHarmonicsDegree\n      ].BytesPerSplat;\n\n    for (let i = fromSplat; i <= toSplat; i++) {\n      const parsedSplat = INRIAV1PlyParser.parseToUncompressedSplat(\n        splatData,\n        i,\n        header,\n        splatDataOffset,\n        outSphericalHarmonicsDegree,\n      );\n      const outBase = i * outBytesPerSplat + toOffset;\n      SplatBuffer.writeSplatDataToSectionBuffer(\n        parsedSplat,\n        toBuffer,\n        outBase,\n        0,\n        outSphericalHarmonicsDegree,\n      );\n    }\n  }\n\n  parseToUncompressedSplatArraySection(\n    header,\n    fromSplat,\n    toSplat,\n    splatData,\n    splatDataOffset,\n    splatArray,\n    outSphericalHarmonicsDegree = 0,\n  ) {\n    outSphericalHarmonicsDegree = Math.min(\n      outSphericalHarmonicsDegree,\n      header.sphericalHarmonicsDegree,\n    );\n    for (let i = fromSplat; i <= toSplat; i++) {\n      const parsedSplat = INRIAV1PlyParser.parseToUncompressedSplat(\n        splatData,\n        i,\n        header,\n        splatDataOffset,\n        outSphericalHarmonicsDegree,\n      );\n      splatArray.addSplat(parsedSplat);\n    }\n  }\n\n  decodeSectionSplatData(\n    sectionSplatData,\n    splatCount,\n    sectionHeader,\n    outSphericalHarmonicsDegree,\n  ) {\n    outSphericalHarmonicsDegree = Math.min(\n      outSphericalHarmonicsDegree,\n      sectionHeader.sphericalHarmonicsDegree,\n    );\n    const splatArray = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n    for (let row = 0; row < splatCount; row++) {\n      const newSplat = INRIAV1PlyParser.parseToUncompressedSplat(\n        sectionSplatData,\n        row,\n        sectionHeader,\n        0,\n        outSphericalHarmonicsDegree,\n      );\n      splatArray.addSplat(newSplat);\n    }\n    return splatArray;\n  }\n\n  static parseToUncompressedSplat = (function() {\n    let rawSplat = [];\n    const tempRotation = new THREE.Quaternion();\n\n    const OFFSET_X = UncompressedSplatArray.OFFSET.X;\n    const OFFSET_Y = UncompressedSplatArray.OFFSET.Y;\n    const OFFSET_Z = UncompressedSplatArray.OFFSET.Z;\n\n    const OFFSET_SCALE0 = UncompressedSplatArray.OFFSET.SCALE0;\n    const OFFSET_SCALE1 = UncompressedSplatArray.OFFSET.SCALE1;\n    const OFFSET_SCALE2 = UncompressedSplatArray.OFFSET.SCALE2;\n\n    const OFFSET_ROTATION0 = UncompressedSplatArray.OFFSET.ROTATION0;\n    const OFFSET_ROTATION1 = UncompressedSplatArray.OFFSET.ROTATION1;\n    const OFFSET_ROTATION2 = UncompressedSplatArray.OFFSET.ROTATION2;\n    const OFFSET_ROTATION3 = UncompressedSplatArray.OFFSET.ROTATION3;\n\n    const OFFSET_FDC0 = UncompressedSplatArray.OFFSET.FDC0;\n    const OFFSET_FDC1 = UncompressedSplatArray.OFFSET.FDC1;\n    const OFFSET_FDC2 = UncompressedSplatArray.OFFSET.FDC2;\n    const OFFSET_OPACITY = UncompressedSplatArray.OFFSET.OPACITY;\n\n    const OFFSET_FRC = [];\n\n    for (let i = 0; i < 45; i++) {\n      OFFSET_FRC[i] = UncompressedSplatArray.OFFSET.FRC0 + i;\n    }\n\n    return function(\n      splatData,\n      row,\n      header,\n      splatDataOffset = 0,\n      outSphericalHarmonicsDegree = 0,\n    ) {\n      outSphericalHarmonicsDegree = Math.min(\n        outSphericalHarmonicsDegree,\n        header.sphericalHarmonicsDegree,\n      );\n      INRIAV1PlyParser.readSplat(\n        splatData,\n        header,\n        row,\n        splatDataOffset,\n        rawSplat,\n      );\n      const newSplat = UncompressedSplatArray.createSplat(\n        outSphericalHarmonicsDegree,\n      );\n      if (rawSplat[SCALE_0] !== undefined) {\n        newSplat[OFFSET_SCALE0] = Math.exp(rawSplat[SCALE_0]);\n        newSplat[OFFSET_SCALE1] = Math.exp(rawSplat[SCALE_1]);\n        newSplat[OFFSET_SCALE2] = Math.exp(rawSplat[SCALE_2]);\n      } else {\n        newSplat[OFFSET_SCALE0] = 0.01;\n        newSplat[OFFSET_SCALE1] = 0.01;\n        newSplat[OFFSET_SCALE2] = 0.01;\n      }\n\n      if (rawSplat[F_DC_0] !== undefined) {\n        const SH_C0 = 0.28209479177387814;\n        newSplat[OFFSET_FDC0] = (0.5 + SH_C0 * rawSplat[F_DC_0]) * 255;\n        newSplat[OFFSET_FDC1] = (0.5 + SH_C0 * rawSplat[F_DC_1]) * 255;\n        newSplat[OFFSET_FDC2] = (0.5 + SH_C0 * rawSplat[F_DC_2]) * 255;\n      } else if (rawSplat[RED] !== undefined) {\n        newSplat[OFFSET_FDC0] = rawSplat[RED] * 255;\n        newSplat[OFFSET_FDC1] = rawSplat[GREEN] * 255;\n        newSplat[OFFSET_FDC2] = rawSplat[BLUE] * 255;\n      } else {\n        newSplat[OFFSET_FDC0] = 0;\n        newSplat[OFFSET_FDC1] = 0;\n        newSplat[OFFSET_FDC2] = 0;\n      }\n\n      if (rawSplat[OPACITY] !== undefined) {\n        newSplat[OFFSET_OPACITY] =\n          (1 / (1 + Math.exp(-rawSplat[OPACITY]))) * 255;\n      }\n\n      newSplat[OFFSET_FDC0] = clamp(Math.floor(newSplat[OFFSET_FDC0]), 0, 255);\n      newSplat[OFFSET_FDC1] = clamp(Math.floor(newSplat[OFFSET_FDC1]), 0, 255);\n      newSplat[OFFSET_FDC2] = clamp(Math.floor(newSplat[OFFSET_FDC2]), 0, 255);\n      newSplat[OFFSET_OPACITY] = clamp(\n        Math.floor(newSplat[OFFSET_OPACITY]),\n        0,\n        255,\n      );\n\n      if (outSphericalHarmonicsDegree >= 1) {\n        if (rawSplat[F_REST_0] !== undefined) {\n          for (let i = 0; i < 9; i++) {\n            newSplat[OFFSET_FRC[i]] =\n              rawSplat[header.sphericalHarmonicsDegree1Fields[i]];\n          }\n          if (outSphericalHarmonicsDegree >= 2) {\n            for (let i = 0; i < 15; i++) {\n              newSplat[OFFSET_FRC[9 + i]] =\n                rawSplat[header.sphericalHarmonicsDegree2Fields[i]];\n            }\n          }\n        }\n      }\n\n      tempRotation.set(\n        rawSplat[ROT_0],\n        rawSplat[ROT_1],\n        rawSplat[ROT_2],\n        rawSplat[ROT_3],\n      );\n      tempRotation.normalize();\n\n      newSplat[OFFSET_ROTATION0] = tempRotation.x;\n      newSplat[OFFSET_ROTATION1] = tempRotation.y;\n      newSplat[OFFSET_ROTATION2] = tempRotation.z;\n      newSplat[OFFSET_ROTATION3] = tempRotation.w;\n\n      newSplat[OFFSET_X] = rawSplat[X];\n      newSplat[OFFSET_Y] = rawSplat[Y];\n      newSplat[OFFSET_Z] = rawSplat[Z];\n\n      return newSplat;\n    };\n  })();\n\n  static readSplat(splatData, header, row, dataOffset, rawSplat) {\n    return PlyParserUtils.readVertex(\n      splatData,\n      header,\n      row,\n      dataOffset,\n      header.fieldsToReadIndexes,\n      rawSplat,\n      true,\n    );\n  }\n\n  parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree = 0) {\n    const header = this.decodeHeaderFromBuffer(plyBuffer);\n    const splatCount = header.splatCount;\n    const splatData = this.findSplatData(plyBuffer, header);\n    const splatArray = this.decodeSectionSplatData(\n      splatData,\n      splatCount,\n      header,\n      outSphericalHarmonicsDegree,\n    );\n    return splatArray;\n  }\n}\n","import * as THREE from 'three';\nimport { PlyParserUtils } from './PlyParserUtils.js';\nimport { UncompressedSplatArray } from '../UncompressedSplatArray.js';\nimport { clamp } from '../../Util.js';\n\nconst CodeBookEntryNamesToRead = [\n  'features_dc',\n  'features_rest_0',\n  'features_rest_1',\n  'features_rest_2',\n  'features_rest_3',\n  'features_rest_4',\n  'features_rest_5',\n  'features_rest_6',\n  'features_rest_7',\n  'features_rest_8',\n  'features_rest_9',\n  'features_rest_10',\n  'features_rest_11',\n  'features_rest_12',\n  'features_rest_13',\n  'features_rest_14',\n  'opacity',\n  'scaling',\n  'rotation_re',\n  'rotation_im',\n];\nconst CodeBookEntriesToReadIndexes = CodeBookEntryNamesToRead.map((e, i) => i);\n\nconst [\n  CB_FEATURES_DC,\n  CB_FEATURES_REST_0,\n  CB_FEATURES_REST_3,\n  CB_OPACITY,\n  CB_SCALING,\n  CB_ROTATION_RE,\n  CB_ROTATION_IM,\n] = [0, 1, 4, 16, 17, 18, 19];\n\nconst FieldNamesToRead = [\n  'scale_0',\n  'scale_1',\n  'scale_2',\n  'rot_0',\n  'rot_1',\n  'rot_2',\n  'rot_3',\n  'x',\n  'y',\n  'z',\n  'f_dc_0',\n  'f_dc_1',\n  'f_dc_2',\n  'opacity',\n  'red',\n  'green',\n  'blue',\n  'f_rest_0',\n  'f_rest_1',\n  'f_rest_2',\n  'f_rest_3',\n  'f_rest_4',\n  'f_rest_5',\n  'f_rest_6',\n  'f_rest_7',\n  'f_rest_8',\n  'f_rest_9',\n  'f_rest_10',\n  'f_rest_11',\n  'f_rest_12',\n  'f_rest_13',\n  'f_rest_14',\n  'f_rest_15',\n  'f_rest_16',\n  'f_rest_17',\n  'f_rest_18',\n  'f_rest_19',\n  'f_rest_20',\n  'f_rest_21',\n  'f_rest_22',\n  'f_rest_23',\n  'f_rest_24',\n  'f_rest_25',\n  'f_rest_26',\n  'f_rest_27',\n  'f_rest_28',\n  'f_rest_29',\n  'f_rest_30',\n  'f_rest_31',\n  'f_rest_32',\n  'f_rest_33',\n  'f_rest_34',\n  'f_rest_35',\n  'f_rest_36',\n  'f_rest_37',\n  'f_rest_38',\n  'f_rest_39',\n  'f_rest_40',\n  'f_rest_41',\n  'f_rest_42',\n  'f_rest_43',\n  'f_rest_44',\n  'f_rest_45',\n];\nconst FieldsToReadIndexes = FieldNamesToRead.map((e, i) => i);\n\nconst [\n  PLY_SCALE_0,\n  PLY_SCALE_1,\n  PLY_SCALE_2,\n  PLY_ROT_0,\n  PLY_ROT_1,\n  PLY_ROT_2,\n  PLY_ROT_3,\n  PLY_X,\n  PLY_Y,\n  PLY_Z,\n  PLY_F_DC_0,\n  PLY_F_DC_1,\n  PLY_F_DC_2,\n  PLY_OPACITY,\n] = FieldsToReadIndexes;\n\nconst PLY_RED = PLY_F_DC_0;\nconst PLY_GREEN = PLY_F_DC_1;\nconst PLY_BLUE = PLY_F_DC_2;\n\nconst fromHalfFloat = (hf) => {\n  const t = (31744 & hf) >> 10;\n  const a = 1023 & hf;\n  return (\n    (hf >> 15 ? -1 : 1) *\n    (t ?\n      t === 31 ?\n        a ?\n          NaN :\n          1 / 0 :\n        Math.pow(2, t - 15) * (1 + a / 1024) :\n      (a / 1024) * 6103515625e-14)\n  );\n};\n\nexport class INRIAV2PlyParser {\n  constructor() {\n    this.plyParserutils = new PlyParserUtils();\n  }\n\n  decodeSectionHeadersFromHeaderLines(headerLines) {\n    const fieldNameIdMap = FieldsToReadIndexes.reduce((acc, element) => {\n      acc[FieldNamesToRead[element]] = element;\n      return acc;\n    }, {});\n\n    const codeBookEntriesToReadIdMap = CodeBookEntriesToReadIndexes.reduce(\n      (acc, element) => {\n        acc[CodeBookEntryNamesToRead[element]] = element;\n        return acc;\n      },\n      {},\n    );\n\n    const sectionNames = PlyParserUtils.getHeaderSectionNames(headerLines);\n    let codeBookSectionIndex;\n    for (let s = 0; s < sectionNames.length; s++) {\n      const sectionName = sectionNames[s];\n      if (sectionName === 'codebook_centers') {\n        codeBookSectionIndex = s;\n      }\n    }\n\n    let currentStartLine = 0;\n    let lastSectionFound = false;\n    const sectionHeaders = [];\n    let sectionIndex = 0;\n    while (!lastSectionFound) {\n      let sectionHeader;\n      if (sectionIndex === codeBookSectionIndex) {\n        sectionHeader = this.plyParserutils.decodeSectionHeader(\n          headerLines,\n          codeBookEntriesToReadIdMap,\n          currentStartLine,\n        );\n      } else {\n        sectionHeader = this.plyParserutils.decodeSectionHeader(\n          headerLines,\n          fieldNameIdMap,\n          currentStartLine,\n        );\n      }\n      lastSectionFound = sectionHeader.endOfHeader;\n      currentStartLine = sectionHeader.headerEndLine + 1;\n      if (!lastSectionFound) {\n        sectionHeader.splatCount = sectionHeader.vertexCount;\n        sectionHeader.bytesPerSplat = sectionHeader.bytesPerVertex;\n      }\n      sectionHeaders.push(sectionHeader);\n      sectionIndex++;\n    }\n    return sectionHeaders;\n  }\n\n  decodeSectionHeadersFromHeaderText(headerText) {\n    const headerLines = PlyParserUtils.convertHeaderTextToLines(headerText);\n    return this.decodeSectionHeadersFromHeaderLines(headerLines);\n  }\n\n  getSplatCountFromSectionHeaders(sectionHeaders) {\n    let splatCount = 0;\n    for (let sectionHeader of sectionHeaders) {\n      if (sectionHeader.sectionName !== 'codebook_centers') {\n        splatCount += sectionHeader.vertexCount;\n      }\n    }\n    return splatCount;\n  }\n\n  decodeHeaderFromHeaderText(headerText) {\n    const headerSizeBytes =\n      headerText.indexOf(PlyParserUtils.HeaderEndToken) +\n      PlyParserUtils.HeaderEndToken.length +\n      1;\n    const sectionHeaders = this.decodeSectionHeadersFromHeaderText(headerText);\n    const splatCount = this.getSplatCountFromSectionHeaders(sectionHeaders);\n    return {\n      headerSizeBytes: headerSizeBytes,\n      sectionHeaders: sectionHeaders,\n      splatCount: splatCount,\n    };\n  }\n\n  decodeHeaderFromBuffer(plyBuffer) {\n    const headerText = this.plyParserutils.readHeaderFromBuffer(plyBuffer);\n    return this.decodeHeaderFromHeaderText(headerText);\n  }\n\n  findVertexData(plyBuffer, header, targetSection) {\n    let byteOffset = header.headerSizeBytes;\n    for (\n      let s = 0;\n      s < targetSection && s < header.sectionHeaders.length;\n      s++\n    ) {\n      const sectionHeader = header.sectionHeaders[s];\n      byteOffset += sectionHeader.dataSizeBytes;\n    }\n    return new DataView(\n      plyBuffer,\n      byteOffset,\n      header.sectionHeaders[targetSection].dataSizeBytes,\n    );\n  }\n\n  decodeCodeBook(codeBookData, sectionHeader) {\n    const rawVertex = [];\n    const codeBook = [];\n    for (let row = 0; row < sectionHeader.vertexCount; row++) {\n      PlyParserUtils.readVertex(\n        codeBookData,\n        sectionHeader,\n        row,\n        0,\n        CodeBookEntriesToReadIndexes,\n        rawVertex,\n      );\n      for (let index of CodeBookEntriesToReadIndexes) {\n        const codeBookElementOffset = CodeBookEntriesToReadIndexes[index];\n        let codeBookPage = codeBook[codeBookElementOffset];\n        if (!codeBookPage) {\n          codeBook[codeBookElementOffset] = codeBookPage = [];\n        }\n        codeBookPage.push(rawVertex[index]);\n      }\n    }\n    for (let page = 0; page < codeBook.length; page++) {\n      const codeBookPage = codeBook[page];\n      const SH_C0 = 0.28209479177387814;\n      for (let i = 0; i < codeBookPage.length; i++) {\n        const baseValue = fromHalfFloat(codeBookPage[i]);\n        if (page === CB_OPACITY) {\n          codeBookPage[i] = Math.round((1 / (1 + Math.exp(-baseValue))) * 255);\n        } else if (page === CB_FEATURES_DC) {\n          codeBookPage[i] = Math.round((0.5 + SH_C0 * baseValue) * 255);\n        } else if (page === CB_SCALING) {\n          codeBookPage[i] = Math.exp(baseValue);\n        } else {\n          codeBookPage[i] = baseValue;\n        }\n      }\n    }\n    return codeBook;\n  }\n\n  decodeSectionSplatData(\n    sectionSplatData,\n    splatCount,\n    sectionHeader,\n    codeBook,\n    outSphericalHarmonicsDegree,\n  ) {\n    outSphericalHarmonicsDegree = Math.min(\n      outSphericalHarmonicsDegree,\n      sectionHeader.sphericalHarmonicsDegree,\n    );\n    const splatArray = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n    for (let row = 0; row < splatCount; row++) {\n      const newSplat = INRIAV2PlyParser.parseToUncompressedSplat(\n        sectionSplatData,\n        row,\n        sectionHeader,\n        codeBook,\n        0,\n        outSphericalHarmonicsDegree,\n      );\n      splatArray.addSplat(newSplat);\n    }\n    return splatArray;\n  }\n\n  static parseToUncompressedSplat = (function() {\n    let rawSplat = [];\n    const tempRotation = new THREE.Quaternion();\n\n    const OFFSET_X = UncompressedSplatArray.OFFSET.X;\n    const OFFSET_Y = UncompressedSplatArray.OFFSET.Y;\n    const OFFSET_Z = UncompressedSplatArray.OFFSET.Z;\n\n    const OFFSET_SCALE0 = UncompressedSplatArray.OFFSET.SCALE0;\n    const OFFSET_SCALE1 = UncompressedSplatArray.OFFSET.SCALE1;\n    const OFFSET_SCALE2 = UncompressedSplatArray.OFFSET.SCALE2;\n\n    const OFFSET_ROTATION0 = UncompressedSplatArray.OFFSET.ROTATION0;\n    const OFFSET_ROTATION1 = UncompressedSplatArray.OFFSET.ROTATION1;\n    const OFFSET_ROTATION2 = UncompressedSplatArray.OFFSET.ROTATION2;\n    const OFFSET_ROTATION3 = UncompressedSplatArray.OFFSET.ROTATION3;\n\n    const OFFSET_FDC0 = UncompressedSplatArray.OFFSET.FDC0;\n    const OFFSET_FDC1 = UncompressedSplatArray.OFFSET.FDC1;\n    const OFFSET_FDC2 = UncompressedSplatArray.OFFSET.FDC2;\n    const OFFSET_OPACITY = UncompressedSplatArray.OFFSET.OPACITY;\n\n    const OFFSET_FRC = [];\n\n    for (let i = 0; i < 45; i++) {\n      OFFSET_FRC[i] = UncompressedSplatArray.OFFSET.FRC0 + i;\n    }\n\n    return function(\n      splatData,\n      row,\n      header,\n      codeBook,\n      splatDataOffset = 0,\n      outSphericalHarmonicsDegree = 0,\n    ) {\n      outSphericalHarmonicsDegree = Math.min(\n        outSphericalHarmonicsDegree,\n        header.sphericalHarmonicsDegree,\n      );\n      INRIAV2PlyParser.readSplat(\n        splatData,\n        header,\n        row,\n        splatDataOffset,\n        rawSplat,\n      );\n      const newSplat = UncompressedSplatArray.createSplat(\n        outSphericalHarmonicsDegree,\n      );\n      if (rawSplat[PLY_SCALE_0] !== undefined) {\n        newSplat[OFFSET_SCALE0] = codeBook[CB_SCALING][rawSplat[PLY_SCALE_0]];\n        newSplat[OFFSET_SCALE1] = codeBook[CB_SCALING][rawSplat[PLY_SCALE_1]];\n        newSplat[OFFSET_SCALE2] = codeBook[CB_SCALING][rawSplat[PLY_SCALE_2]];\n      } else {\n        newSplat[OFFSET_SCALE0] = 0.01;\n        newSplat[OFFSET_SCALE1] = 0.01;\n        newSplat[OFFSET_SCALE2] = 0.01;\n      }\n\n      if (rawSplat[PLY_F_DC_0] !== undefined) {\n        newSplat[OFFSET_FDC0] = codeBook[CB_FEATURES_DC][rawSplat[PLY_F_DC_0]];\n        newSplat[OFFSET_FDC1] = codeBook[CB_FEATURES_DC][rawSplat[PLY_F_DC_1]];\n        newSplat[OFFSET_FDC2] = codeBook[CB_FEATURES_DC][rawSplat[PLY_F_DC_2]];\n      } else if (rawSplat[PLY_RED] !== undefined) {\n        newSplat[OFFSET_FDC0] = rawSplat[PLY_RED] * 255;\n        newSplat[OFFSET_FDC1] = rawSplat[PLY_GREEN] * 255;\n        newSplat[OFFSET_FDC2] = rawSplat[PLY_BLUE] * 255;\n      } else {\n        newSplat[OFFSET_FDC0] = 0;\n        newSplat[OFFSET_FDC1] = 0;\n        newSplat[OFFSET_FDC2] = 0;\n      }\n\n      if (rawSplat[PLY_OPACITY] !== undefined) {\n        newSplat[OFFSET_OPACITY] = codeBook[CB_OPACITY][rawSplat[PLY_OPACITY]];\n      }\n\n      newSplat[OFFSET_FDC0] = clamp(Math.floor(newSplat[OFFSET_FDC0]), 0, 255);\n      newSplat[OFFSET_FDC1] = clamp(Math.floor(newSplat[OFFSET_FDC1]), 0, 255);\n      newSplat[OFFSET_FDC2] = clamp(Math.floor(newSplat[OFFSET_FDC2]), 0, 255);\n      newSplat[OFFSET_OPACITY] = clamp(\n        Math.floor(newSplat[OFFSET_OPACITY]),\n        0,\n        255,\n      );\n\n      if (\n        outSphericalHarmonicsDegree >= 1 &&\n        header.sphericalHarmonicsDegree >= 1\n      ) {\n        for (let i = 0; i < 9; i++) {\n          const codeBookPage = codeBook[CB_FEATURES_REST_0 + (i % 3)];\n          newSplat[OFFSET_FRC[i]] =\n            codeBookPage[rawSplat[header.sphericalHarmonicsDegree1Fields[i]]];\n        }\n        if (\n          outSphericalHarmonicsDegree >= 2 &&\n          header.sphericalHarmonicsDegree >= 2\n        ) {\n          for (let i = 0; i < 15; i++) {\n            const codeBookPage = codeBook[CB_FEATURES_REST_3 + (i % 5)];\n            newSplat[OFFSET_FRC[9 + i]] =\n              codeBookPage[rawSplat[header.sphericalHarmonicsDegree2Fields[i]]];\n          }\n        }\n      }\n\n      const rot0 = codeBook[CB_ROTATION_RE][rawSplat[PLY_ROT_0]];\n      const rot1 = codeBook[CB_ROTATION_IM][rawSplat[PLY_ROT_1]];\n      const rot2 = codeBook[CB_ROTATION_IM][rawSplat[PLY_ROT_2]];\n      const rot3 = codeBook[CB_ROTATION_IM][rawSplat[PLY_ROT_3]];\n      tempRotation.set(rot0, rot1, rot2, rot3);\n      tempRotation.normalize();\n\n      newSplat[OFFSET_ROTATION0] = tempRotation.x;\n      newSplat[OFFSET_ROTATION1] = tempRotation.y;\n      newSplat[OFFSET_ROTATION2] = tempRotation.z;\n      newSplat[OFFSET_ROTATION3] = tempRotation.w;\n\n      newSplat[OFFSET_X] = fromHalfFloat(rawSplat[PLY_X]);\n      newSplat[OFFSET_Y] = fromHalfFloat(rawSplat[PLY_Y]);\n      newSplat[OFFSET_Z] = fromHalfFloat(rawSplat[PLY_Z]);\n\n      return newSplat;\n    };\n  })();\n\n  static readSplat(splatData, header, row, dataOffset, rawSplat) {\n    return PlyParserUtils.readVertex(\n      splatData,\n      header,\n      row,\n      dataOffset,\n      FieldsToReadIndexes,\n      rawSplat,\n      false,\n    );\n  }\n\n  parseToUncompressedSplatArray(plyBuffer, outSphericalHarmonicsDegree = 0) {\n    const splatArrays = [];\n    const header = this.decodeHeaderFromBuffer(\n      plyBuffer,\n      outSphericalHarmonicsDegree,\n    );\n    let codeBook;\n\n    for (let s = 0; s < header.sectionHeaders.length; s++) {\n      const sectionHeader = header.sectionHeaders[s];\n      if (sectionHeader.sectionName === 'codebook_centers') {\n        const codeBookData = this.findVertexData(plyBuffer, header, s);\n        codeBook = this.decodeCodeBook(codeBookData, sectionHeader);\n      }\n    }\n    for (let s = 0; s < header.sectionHeaders.length; s++) {\n      const sectionHeader = header.sectionHeaders[s];\n      if (sectionHeader.sectionName !== 'codebook_centers') {\n        const splatCount = sectionHeader.vertexCount;\n        const vertexData = this.findVertexData(plyBuffer, header, s);\n        const splatArray = this.decodeSectionSplatData(\n          vertexData,\n          splatCount,\n          sectionHeader,\n          codeBook,\n          outSphericalHarmonicsDegree,\n        );\n        splatArrays.push(splatArray);\n      }\n    }\n\n    const unified = new UncompressedSplatArray(outSphericalHarmonicsDegree);\n    for (let splatArray of splatArrays) {\n      for (let splat of splatArray.splats) {\n        unified.addSplat(splat);\n      }\n    }\n\n    return unified;\n  }\n}\n","import { PlayCanvasCompressedPlyParser } from './PlayCanvasCompressedPlyParser.js';\nimport { INRIAV1PlyParser } from './INRIAV1PlyParser.js';\nimport { INRIAV2PlyParser } from './INRIAV2PlyParser.js';\nimport { PlyParserUtils } from './PlyParserUtils.js';\nimport { PlyFormat } from './PlyFormat.js';\n\nexport class PlyParser {\n  static parseToUncompressedSplatArray(\n    plyBuffer,\n    outSphericalHarmonicsDegree = 0,\n  ) {\n    const plyFormat =\n      PlyParserUtils.determineHeaderFormatFromPlyBuffer(plyBuffer);\n\n    if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n      return PlayCanvasCompressedPlyParser.parseToUncompressedSplatArray(\n        plyBuffer,\n      );\n    } else if (plyFormat === PlyFormat.INRIAV1) {\n      return new INRIAV1PlyParser().parseToUncompressedSplatArray(\n        plyBuffer,\n        outSphericalHarmonicsDegree,\n      );\n    } else if (plyFormat === PlyFormat.INRIAV2) {\n      return new INRIAV2PlyParser().parseToUncompressedSplatArray(\n        plyBuffer,\n        outSphericalHarmonicsDegree,\n      );\n    }\n  }\n}\n","export class DirectLoadError extends Error {\n  constructor(msg) {\n    super(msg);\n  }\n}\n","export const InternalLoadType = {\n  DirectToSplatBuffer: 0,\n  DirectToSplatArray: 1,\n  DownloadBeforeProcessing: 2,\n};\n","export const LoaderStatus = {\n  Downloading: 0,\n  Processing: 1,\n  Done: 2,\n};\n","import * as THREE from 'three';\nimport { UncompressedSplatArray } from './UncompressedSplatArray.js';\nimport { SplatBuffer } from './SplatBuffer.js';\n\nexport class SplatPartitioner {\n  constructor(\n    sectionCount,\n    sectionFilters,\n    groupingParameters,\n    partitionGenerator,\n  ) {\n    this.sectionCount = sectionCount;\n    this.sectionFilters = sectionFilters;\n    this.groupingParameters = groupingParameters;\n    this.partitionGenerator = partitionGenerator;\n  }\n\n  partitionUncompressedSplatArray(splatArray) {\n    let groupingParameters;\n    let sectionCount;\n    let sectionFilters;\n    if (this.partitionGenerator) {\n      const results = this.partitionGenerator(splatArray);\n      groupingParameters = results.groupingParameters;\n      sectionCount = results.sectionCount;\n      sectionFilters = results.sectionFilters;\n    } else {\n      groupingParameters = this.groupingParameters;\n      sectionCount = this.sectionCount;\n      sectionFilters = this.sectionFilters;\n    }\n\n    const newArrays = [];\n    for (let s = 0; s < sectionCount; s++) {\n      const sectionSplats = new UncompressedSplatArray(\n        splatArray.sphericalHarmonicsDegree,\n      );\n      const sectionFilter = sectionFilters[s];\n      for (let i = 0; i < splatArray.splatCount; i++) {\n        if (sectionFilter(i)) {\n          sectionSplats.addSplat(splatArray.splats[i]);\n        }\n      }\n      newArrays.push(sectionSplats);\n    }\n    return {\n      splatArrays: newArrays,\n      parameters: groupingParameters,\n    };\n  }\n\n  static getStandardPartitioner(\n    partitionSize = 0,\n    sceneCenter = new THREE.Vector3(),\n    blockSize = SplatBuffer.BucketBlockSize,\n    bucketSize = SplatBuffer.BucketSize,\n  ) {\n    const partitionGenerator = (splatArray) => {\n      const OFFSET_X = UncompressedSplatArray.OFFSET.X;\n      const OFFSET_Y = UncompressedSplatArray.OFFSET.Y;\n      const OFFSET_Z = UncompressedSplatArray.OFFSET.Z;\n\n      if (partitionSize <= 0) partitionSize = splatArray.splatCount;\n\n      const center = new THREE.Vector3();\n      const clampDistance = 0.5;\n      const clampPoint = (point) => {\n        point.x = Math.floor(point.x / clampDistance) * clampDistance;\n        point.y = Math.floor(point.y / clampDistance) * clampDistance;\n        point.z = Math.floor(point.z / clampDistance) * clampDistance;\n      };\n      splatArray.splats.forEach((splat) => {\n        center\n          .set(splat[OFFSET_X], splat[OFFSET_Y], splat[OFFSET_Z])\n          .sub(sceneCenter);\n        clampPoint(center);\n        splat.centerDist = center.lengthSq();\n      });\n      splatArray.splats.sort((a, b) => {\n        let centerADist = a.centerDist;\n        let centerBDist = b.centerDist;\n        if (centerADist > centerBDist) return 1;\n        else return -1;\n      });\n\n      const sectionFilters = [];\n      const groupingParameters = [];\n      partitionSize = Math.min(splatArray.splatCount, partitionSize);\n      const patitionCount = Math.ceil(splatArray.splatCount / partitionSize);\n      let currentStartSplat = 0;\n      for (let i = 0; i < patitionCount; i++) {\n        let startSplat = currentStartSplat;\n        sectionFilters.push((splatIndex) => {\n          return (\n            splatIndex >= startSplat && splatIndex < startSplat + partitionSize\n          );\n        });\n        groupingParameters.push({\n          blocksSize: blockSize,\n          bucketSize: bucketSize,\n        });\n        currentStartSplat += partitionSize;\n      }\n      return {\n        sectionCount: sectionFilters.length,\n        sectionFilters,\n        groupingParameters,\n      };\n    };\n    return new SplatPartitioner(\n      undefined,\n      undefined,\n      undefined,\n      partitionGenerator,\n    );\n  }\n}\n","import * as THREE from 'three';\nimport { SplatPartitioner } from './SplatPartitioner.js';\nimport { SplatBuffer } from './SplatBuffer.js';\n\nexport class SplatBufferGenerator {\n  constructor(\n    splatPartitioner,\n    alphaRemovalThreshold,\n    compressionLevel,\n    sectionSize,\n    sceneCenter,\n    blockSize,\n    bucketSize,\n  ) {\n    this.splatPartitioner = splatPartitioner;\n    this.alphaRemovalThreshold = alphaRemovalThreshold;\n    this.compressionLevel = compressionLevel;\n    this.sectionSize = sectionSize;\n    this.sceneCenter = sceneCenter ?\n      new THREE.Vector3().copy(sceneCenter) :\n      undefined;\n    this.blockSize = blockSize;\n    this.bucketSize = bucketSize;\n  }\n\n  generateFromUncompressedSplatArray(splatArray) {\n    const partitionResults =\n      this.splatPartitioner.partitionUncompressedSplatArray(splatArray);\n    return SplatBuffer.generateFromUncompressedSplatArrays(\n      partitionResults.splatArrays,\n      this.alphaRemovalThreshold,\n      this.compressionLevel,\n      this.sceneCenter,\n      this.blockSize,\n      this.bucketSize,\n      partitionResults.parameters,\n    );\n  }\n\n  static getStandardGenerator(\n    alphaRemovalThreshold = 1,\n    compressionLevel = 1,\n    sectionSize = 0,\n    sceneCenter = new THREE.Vector3(),\n    blockSize = SplatBuffer.BucketBlockSize,\n    bucketSize = SplatBuffer.BucketSize,\n  ) {\n    const splatPartitioner = SplatPartitioner.getStandardPartitioner(\n      sectionSize,\n      sceneCenter,\n      blockSize,\n      bucketSize,\n    );\n    return new SplatBufferGenerator(\n      splatPartitioner,\n      alphaRemovalThreshold,\n      compressionLevel,\n      sectionSize,\n      sceneCenter,\n      blockSize,\n      bucketSize,\n    );\n  }\n}\n","import * as THREE from 'three';\nimport { Constants } from '../../Constants.js';\nimport {\n  fetchWithProgress as defaultFetchWithProgress,\n  delayedExecute,\n  nativePromiseWithExtractedComponents,\n} from '../../Util.js';\nimport { DirectLoadError } from '../DirectLoadError.js';\nimport { InternalLoadType } from '../InternalLoadType.js';\nimport { LoaderStatus } from '../LoaderStatus.js';\nimport { SplatBuffer } from '../SplatBuffer.js';\nimport { SplatBufferGenerator } from '../SplatBufferGenerator.js';\nimport { UncompressedSplatArray } from '../UncompressedSplatArray.js';\nimport { INRIAV1PlyParser } from './INRIAV1PlyParser.js';\nimport { PlayCanvasCompressedPlyParser } from './PlayCanvasCompressedPlyParser.js';\nimport { PlyFormat } from './PlyFormat.js';\nimport { PlyParser } from './PlyParser.js';\nimport { PlyParserUtils } from './PlyParserUtils.js';\n\nfunction storeChunksInBuffer(chunks, buffer) {\n  let inBytes = 0;\n  for (let chunk of chunks) inBytes += chunk.sizeBytes;\n\n  if (!buffer || buffer.byteLength < inBytes) {\n    buffer = new ArrayBuffer(inBytes);\n  }\n\n  let offset = 0;\n  for (let chunk of chunks) {\n    new Uint8Array(buffer, offset, chunk.sizeBytes).set(chunk.data);\n    offset += chunk.sizeBytes;\n  }\n\n  return buffer;\n}\n\nfunction finalize(\n  splatData,\n  optimizeSplatData,\n  minimumAlpha,\n  compressionLevel,\n  sectionSize,\n  sceneCenter,\n  blockSize,\n  bucketSize,\n) {\n  if (optimizeSplatData) {\n    const splatBufferGenerator = SplatBufferGenerator.getStandardGenerator(\n      minimumAlpha,\n      compressionLevel,\n      sectionSize,\n      sceneCenter,\n      blockSize,\n      bucketSize,\n    );\n    return splatBufferGenerator.generateFromUncompressedSplatArray(splatData);\n  } else {\n    return SplatBuffer.generateFromUncompressedSplatArrays(\n      [splatData],\n      minimumAlpha,\n      0,\n      new THREE.Vector3(),\n    );\n  }\n}\n\nexport class PlyLoader {\n  static loadFromURL(\n    fileName,\n    onProgress,\n    loadDirectoToSplatBuffer,\n    onProgressiveLoadSectionProgress,\n    minimumAlpha,\n    compressionLevel,\n    optimizeSplatData = true,\n    outSphericalHarmonicsDegree = 0,\n    sectionSize,\n    sceneCenter,\n    blockSize,\n    bucketSize,\n    fetchWithProgress = defaultFetchWithProgress,\n  ) {\n    let internalLoadType = loadDirectoToSplatBuffer ?\n      InternalLoadType.DirectToSplatBuffer :\n      InternalLoadType.DirectToSplatArray;\n    if (optimizeSplatData) {\n      internalLoadType = InternalLoadType.DirectToSplatArray;\n    }\n\n    const directLoadSectionSizeBytes = Constants.ProgressiveLoadSectionSize;\n    const splatDataOffsetBytes =\n      SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes;\n    const sectionCount = 1;\n\n    let directLoadBufferIn;\n    let directLoadBufferOut;\n    let directLoadSplatBuffer;\n    let compressedPlyHeaderChunksBuffer;\n    let maxSplatCount = 0;\n    let splatCount = 0;\n\n    let headerLoaded = false;\n    let readyToLoadSplatData = false;\n    let compressed = false;\n\n    const loadPromise = nativePromiseWithExtractedComponents();\n\n    let numBytesStreamed = 0;\n    let numBytesParsed = 0;\n    let numBytesDownloaded = 0;\n    let headerText = '';\n    let header = null;\n    let chunks = [];\n\n    let standardLoadUncompressedSplatArray;\n\n    const textDecoder = new TextDecoder();\n    const inriaV1PlyParser = new INRIAV1PlyParser();\n\n    const localOnProgress = (percent, percentLabel, chunkData) => {\n      const loadComplete = percent >= 100;\n\n      if (chunkData) {\n        chunks.push({\n          data: chunkData,\n          sizeBytes: chunkData.byteLength,\n          startBytes: numBytesDownloaded,\n          endBytes: numBytesDownloaded + chunkData.byteLength,\n        });\n        numBytesDownloaded += chunkData.byteLength;\n      }\n\n      if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n        if (loadComplete) {\n          loadPromise.resolve(chunks);\n        }\n      } else {\n        if (!headerLoaded) {\n          headerText += textDecoder.decode(chunkData);\n          if (PlyParserUtils.checkTextForEndHeader(headerText)) {\n            const plyFormat =\n              PlyParserUtils.determineHeaderFormatFromHeaderText(headerText);\n            if (plyFormat === PlyFormat.INRIAV1) {\n              header = inriaV1PlyParser.decodeHeaderText(headerText);\n              maxSplatCount = header.splatCount;\n              readyToLoadSplatData = true;\n              compressed = false;\n            } else if (plyFormat === PlyFormat.PlayCanvasCompressed) {\n              header =\n                PlayCanvasCompressedPlyParser.decodeHeaderText(headerText);\n              maxSplatCount = header.vertexElement.count;\n              compressed = true;\n            } else {\n              if (loadDirectoToSplatBuffer) {\n                throw new DirectLoadError(\n                  'PlyLoader.loadFromURL() -> Selected Ply format cannot be directly loaded.',\n                );\n              } else {\n                internalLoadType = InternalLoadType.DownloadBeforeProcessing;\n                return;\n              }\n            }\n            outSphericalHarmonicsDegree = Math.min(\n              outSphericalHarmonicsDegree,\n              header.sphericalHarmonicsDegree,\n            );\n\n            const shDescriptor =\n              SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[\n                outSphericalHarmonicsDegree\n              ];\n            const splatBufferSizeBytes =\n              splatDataOffsetBytes + shDescriptor.BytesPerSplat * maxSplatCount;\n\n            if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n              directLoadBufferOut = new ArrayBuffer(splatBufferSizeBytes);\n              SplatBuffer.writeHeaderToBuffer(\n                {\n                  versionMajor: SplatBuffer.CurrentMajorVersion,\n                  versionMinor: SplatBuffer.CurrentMinorVersion,\n                  maxSectionCount: sectionCount,\n                  sectionCount: sectionCount,\n                  maxSplatCount: maxSplatCount,\n                  splatCount: splatCount,\n                  compressionLevel: 0,\n                  sceneCenter: new THREE.Vector3(),\n                },\n                directLoadBufferOut,\n              );\n            } else {\n              standardLoadUncompressedSplatArray = new UncompressedSplatArray(\n                outSphericalHarmonicsDegree,\n              );\n            }\n\n            numBytesStreamed = header.headerSizeBytes;\n            numBytesParsed = header.headerSizeBytes;\n            headerLoaded = true;\n          }\n        } else if (compressed && !readyToLoadSplatData) {\n          const sizeRequiredForHeaderAndChunks =\n            header.headerSizeBytes + header.chunkElement.storageSizeBytes;\n          compressedPlyHeaderChunksBuffer = storeChunksInBuffer(\n            chunks,\n            compressedPlyHeaderChunksBuffer,\n          );\n          if (\n            compressedPlyHeaderChunksBuffer.byteLength >=\n            sizeRequiredForHeaderAndChunks\n          ) {\n            PlayCanvasCompressedPlyParser.readElementData(\n              header.chunkElement,\n              compressedPlyHeaderChunksBuffer,\n              header.headerSizeBytes,\n            );\n            numBytesStreamed = sizeRequiredForHeaderAndChunks;\n            numBytesParsed = sizeRequiredForHeaderAndChunks;\n            readyToLoadSplatData = true;\n          }\n        }\n\n        if (headerLoaded && readyToLoadSplatData) {\n          if (chunks.length > 0) {\n            directLoadBufferIn = storeChunksInBuffer(\n              chunks,\n              directLoadBufferIn,\n            );\n\n            const bytesLoadedSinceLastStreamedSection =\n              numBytesDownloaded - numBytesStreamed;\n            if (\n              bytesLoadedSinceLastStreamedSection >\n                directLoadSectionSizeBytes ||\n              loadComplete\n            ) {\n              const numBytesToProcess = numBytesDownloaded - numBytesParsed;\n              const addedSplatCount = Math.floor(\n                numBytesToProcess / header.bytesPerSplat,\n              );\n              const numBytesToParse = addedSplatCount * header.bytesPerSplat;\n              const numBytesLeftOver = numBytesToProcess - numBytesToParse;\n              const newSplatCount = splatCount + addedSplatCount;\n              const parsedDataViewOffset =\n                numBytesParsed - chunks[0].startBytes;\n              const dataToParse = new DataView(\n                directLoadBufferIn,\n                parsedDataViewOffset,\n                numBytesToParse,\n              );\n\n              const shDescriptor =\n                SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[\n                  outSphericalHarmonicsDegree\n                ];\n              const outOffset =\n                splatCount * shDescriptor.BytesPerSplat + splatDataOffsetBytes;\n\n              if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n                if (compressed) {\n                  PlayCanvasCompressedPlyParser.parseToUncompressedSplatBufferSection(\n                    header.chunkElement,\n                    header.vertexElement,\n                    0,\n                    addedSplatCount - 1,\n                    splatCount,\n                    dataToParse,\n                    0,\n                    directLoadBufferOut,\n                    outOffset,\n                  );\n                } else {\n                  inriaV1PlyParser.parseToUncompressedSplatBufferSection(\n                    header,\n                    0,\n                    addedSplatCount - 1,\n                    dataToParse,\n                    0,\n                    directLoadBufferOut,\n                    outOffset,\n                    outSphericalHarmonicsDegree,\n                  );\n                }\n              } else {\n                if (compressed) {\n                  PlayCanvasCompressedPlyParser.parseToUncompressedSplatArraySection(\n                    header.chunkElement,\n                    header.vertexElement,\n                    0,\n                    addedSplatCount - 1,\n                    splatCount,\n                    dataToParse,\n                    0,\n                    standardLoadUncompressedSplatArray,\n                  );\n                } else {\n                  inriaV1PlyParser.parseToUncompressedSplatArraySection(\n                    header,\n                    0,\n                    addedSplatCount - 1,\n                    dataToParse,\n                    0,\n                    standardLoadUncompressedSplatArray,\n                    outSphericalHarmonicsDegree,\n                  );\n                }\n              }\n\n              splatCount = newSplatCount;\n\n              if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n                if (!directLoadSplatBuffer) {\n                  SplatBuffer.writeSectionHeaderToBuffer(\n                    {\n                      maxSplatCount: maxSplatCount,\n                      splatCount: splatCount,\n                      bucketSize: 0,\n                      bucketCount: 0,\n                      bucketBlockSize: 0,\n                      compressionScaleRange: 0,\n                      storageSizeBytes: 0,\n                      fullBucketCount: 0,\n                      partiallyFilledBucketCount: 0,\n                      sphericalHarmonicsDegree: outSphericalHarmonicsDegree,\n                    },\n                    0,\n                    directLoadBufferOut,\n                    SplatBuffer.HeaderSizeBytes,\n                  );\n                  directLoadSplatBuffer = new SplatBuffer(\n                    directLoadBufferOut,\n                    false,\n                  );\n                }\n                directLoadSplatBuffer.updateLoadedCounts(1, splatCount);\n                if (onProgressiveLoadSectionProgress) {\n                  onProgressiveLoadSectionProgress(\n                    directLoadSplatBuffer,\n                    loadComplete,\n                  );\n                }\n              }\n\n              numBytesStreamed += directLoadSectionSizeBytes;\n              numBytesParsed += numBytesToParse;\n\n              if (numBytesLeftOver === 0) {\n                chunks = [];\n              } else {\n                let keepChunks = [];\n                let keepSize = 0;\n                for (let i = chunks.length - 1; i >= 0; i--) {\n                  const chunk = chunks[i];\n                  keepSize += chunk.sizeBytes;\n                  keepChunks.unshift(chunk);\n                  if (keepSize >= numBytesLeftOver) break;\n                }\n                chunks = keepChunks;\n              }\n            }\n          }\n\n          if (loadComplete) {\n            if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n              loadPromise.resolve(directLoadSplatBuffer);\n            } else {\n              loadPromise.resolve(standardLoadUncompressedSplatArray);\n            }\n          }\n        }\n      }\n\n      if (onProgress) {\n        onProgress(percent, percentLabel, LoaderStatus.Downloading);\n      }\n    };\n\n    if (onProgress) onProgress(0, '0%', LoaderStatus.Downloading);\n    return fetchWithProgress(fileName, localOnProgress, false).then(() => {\n      if (onProgress) onProgress(0, '0%', LoaderStatus.Processing);\n      return loadPromise.promise.then((splatData) => {\n        if (onProgress) onProgress(100, '100%', LoaderStatus.Done);\n        if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n          const chunkDatas = chunks.map((chunk) => chunk.data);\n          return new Blob(chunkDatas).arrayBuffer().then((plyFileData) => {\n            return PlyLoader.loadFromFileData(\n              plyFileData,\n              minimumAlpha,\n              compressionLevel,\n              optimizeSplatData,\n              outSphericalHarmonicsDegree,\n              sectionSize,\n              sceneCenter,\n              blockSize,\n              bucketSize,\n            );\n          });\n        } else if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n          return splatData;\n        } else {\n          return delayedExecute(() => {\n            return finalize(\n              splatData,\n              optimizeSplatData,\n              minimumAlpha,\n              compressionLevel,\n              sectionSize,\n              sceneCenter,\n              blockSize,\n              bucketSize,\n            );\n          });\n        }\n      });\n    });\n  }\n\n  static loadFromFileData(\n    plyFileData,\n    minimumAlpha,\n    compressionLevel,\n    optimizeSplatData,\n    outSphericalHarmonicsDegree = 0,\n    sectionSize,\n    sceneCenter,\n    blockSize,\n    bucketSize,\n  ) {\n    return delayedExecute(() => {\n      return PlyParser.parseToUncompressedSplatArray(\n        plyFileData,\n        outSphericalHarmonicsDegree,\n      );\n    }).then((splatArray) => {\n      return finalize(\n        splatArray,\n        optimizeSplatData,\n        minimumAlpha,\n        compressionLevel,\n        sectionSize,\n        sceneCenter,\n        blockSize,\n        bucketSize,\n      );\n    });\n  }\n}\n","import * as THREE from 'three';\nimport { SplatBuffer } from '../SplatBuffer.js';\nimport { UncompressedSplatArray } from '../UncompressedSplatArray.js';\n\nexport class SplatParser {\n  static RowSizeBytes = 32;\n  static CenterSizeBytes = 12;\n  static ScaleSizeBytes = 12;\n  static RotationSizeBytes = 4;\n  static ColorSizeBytes = 4;\n\n  static parseToUncompressedSplatBufferSection(\n    fromSplat,\n    toSplat,\n    fromBuffer,\n    fromOffset,\n    toBuffer,\n    toOffset,\n  ) {\n    const outBytesPerCenter = SplatBuffer.CompressionLevels[0].BytesPerCenter;\n    const outBytesPerScale = SplatBuffer.CompressionLevels[0].BytesPerScale;\n    const outBytesPerRotation =\n      SplatBuffer.CompressionLevels[0].BytesPerRotation;\n    const outBytesPerSplat =\n      SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[0]\n        .BytesPerSplat;\n\n    for (let i = fromSplat; i <= toSplat; i++) {\n      const inBase = i * SplatParser.RowSizeBytes + fromOffset;\n      const inCenter = new Float32Array(fromBuffer, inBase, 3);\n      const inScale = new Float32Array(\n        fromBuffer,\n        inBase + SplatParser.CenterSizeBytes,\n        3,\n      );\n      const inColor = new Uint8Array(\n        fromBuffer,\n        inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes,\n        4,\n      );\n      const inRotation = new Uint8Array(\n        fromBuffer,\n        inBase +\n          SplatParser.CenterSizeBytes +\n          SplatParser.ScaleSizeBytes +\n          SplatParser.RotationSizeBytes,\n        4,\n      );\n\n      const quat = new THREE.Quaternion(\n        (inRotation[1] - 128) / 128,\n        (inRotation[2] - 128) / 128,\n        (inRotation[3] - 128) / 128,\n        (inRotation[0] - 128) / 128,\n      );\n      quat.normalize();\n\n      const outBase = i * outBytesPerSplat + toOffset;\n      const outCenter = new Float32Array(toBuffer, outBase, 3);\n      const outScale = new Float32Array(\n        toBuffer,\n        outBase + outBytesPerCenter,\n        3,\n      );\n      const outRotation = new Float32Array(\n        toBuffer,\n        outBase + outBytesPerCenter + outBytesPerScale,\n        4,\n      );\n      const outColor = new Uint8Array(\n        toBuffer,\n        outBase + outBytesPerCenter + outBytesPerScale + outBytesPerRotation,\n        4,\n      );\n\n      outCenter[0] = inCenter[0];\n      outCenter[1] = inCenter[1];\n      outCenter[2] = inCenter[2];\n\n      outScale[0] = inScale[0];\n      outScale[1] = inScale[1];\n      outScale[2] = inScale[2];\n\n      outRotation[0] = quat.w;\n      outRotation[1] = quat.x;\n      outRotation[2] = quat.y;\n      outRotation[3] = quat.z;\n\n      outColor[0] = inColor[0];\n      outColor[1] = inColor[1];\n      outColor[2] = inColor[2];\n      outColor[3] = inColor[3];\n    }\n  }\n\n  static parseToUncompressedSplatArraySection(\n    fromSplat,\n    toSplat,\n    fromBuffer,\n    fromOffset,\n    splatArray,\n  ) {\n    for (let i = fromSplat; i <= toSplat; i++) {\n      const inBase = i * SplatParser.RowSizeBytes + fromOffset;\n      const inCenter = new Float32Array(fromBuffer, inBase, 3);\n      const inScale = new Float32Array(\n        fromBuffer,\n        inBase + SplatParser.CenterSizeBytes,\n        3,\n      );\n      const inColor = new Uint8Array(\n        fromBuffer,\n        inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes,\n        4,\n      );\n      const inRotation = new Uint8Array(\n        fromBuffer,\n        inBase +\n          SplatParser.CenterSizeBytes +\n          SplatParser.ScaleSizeBytes +\n          SplatParser.RotationSizeBytes,\n        4,\n      );\n\n      const quat = new THREE.Quaternion(\n        (inRotation[1] - 128) / 128,\n        (inRotation[2] - 128) / 128,\n        (inRotation[3] - 128) / 128,\n        (inRotation[0] - 128) / 128,\n      );\n      quat.normalize();\n\n      splatArray.addSplatFromComonents(\n        inCenter[0],\n        inCenter[1],\n        inCenter[2],\n        inScale[0],\n        inScale[1],\n        inScale[2],\n        quat.w,\n        quat.x,\n        quat.y,\n        quat.z,\n        inColor[0],\n        inColor[1],\n        inColor[2],\n        inColor[3],\n      );\n    }\n  }\n\n  static parseStandardSplatToUncompressedSplatArray(inBuffer) {\n    // Standard .splat row layout:\n    // XYZ - Position (Float32)\n    // XYZ - Scale (Float32)\n    // RGBA - colors (uint8)\n    // IJKL - quaternion/rot (uint8)\n\n    const splatCount = inBuffer.byteLength / SplatParser.RowSizeBytes;\n\n    const splatArray = new UncompressedSplatArray();\n\n    for (let i = 0; i < splatCount; i++) {\n      const inBase = i * SplatParser.RowSizeBytes;\n      const inCenter = new Float32Array(inBuffer, inBase, 3);\n      const inScale = new Float32Array(\n        inBuffer,\n        inBase + SplatParser.CenterSizeBytes,\n        3,\n      );\n      const inColor = new Uint8Array(\n        inBuffer,\n        inBase + SplatParser.CenterSizeBytes + SplatParser.ScaleSizeBytes,\n        4,\n      );\n      const inRotation = new Uint8Array(\n        inBuffer,\n        inBase +\n          SplatParser.CenterSizeBytes +\n          SplatParser.ScaleSizeBytes +\n          SplatParser.ColorSizeBytes,\n        4,\n      );\n\n      const quat = new THREE.Quaternion(\n        (inRotation[1] - 128) / 128,\n        (inRotation[2] - 128) / 128,\n        (inRotation[3] - 128) / 128,\n        (inRotation[0] - 128) / 128,\n      );\n      quat.normalize();\n\n      splatArray.addSplatFromComonents(\n        inCenter[0],\n        inCenter[1],\n        inCenter[2],\n        inScale[0],\n        inScale[1],\n        inScale[2],\n        quat.w,\n        quat.x,\n        quat.y,\n        quat.z,\n        inColor[0],\n        inColor[1],\n        inColor[2],\n        inColor[3],\n      );\n    }\n\n    return splatArray;\n  }\n}\n","import * as THREE from 'three';\nimport { Constants } from '../../Constants.js';\nimport {\n  fetchWithProgress as defaultFetchWithProgress,\n  delayedExecute,\n  nativePromiseWithExtractedComponents,\n} from '../../Util.js';\nimport { DirectLoadError } from '../DirectLoadError.js';\nimport { InternalLoadType } from '../InternalLoadType.js';\nimport { LoaderStatus } from '../LoaderStatus.js';\nimport { SplatBuffer } from '../SplatBuffer.js';\nimport { SplatBufferGenerator } from '../SplatBufferGenerator.js';\nimport { UncompressedSplatArray } from '../UncompressedSplatArray.js';\nimport { SplatParser } from './SplatParser.js';\n\nfunction finalize(\n  splatData,\n  optimizeSplatData,\n  minimumAlpha,\n  compressionLevel,\n  sectionSize,\n  sceneCenter,\n  blockSize,\n  bucketSize,\n) {\n  if (optimizeSplatData) {\n    const splatBufferGenerator = SplatBufferGenerator.getStandardGenerator(\n      minimumAlpha,\n      compressionLevel,\n      sectionSize,\n      sceneCenter,\n      blockSize,\n      bucketSize,\n    );\n    return splatBufferGenerator.generateFromUncompressedSplatArray(splatData);\n  } else {\n    return SplatBuffer.generateFromUncompressedSplatArrays(\n      [splatData],\n      minimumAlpha,\n      0,\n      new THREE.Vector3(),\n    );\n  }\n}\n\nexport class SplatLoader {\n  static loadFromURL(\n    fileName,\n    onProgress,\n    loadDirectoToSplatBuffer,\n    onProgressiveLoadSectionProgress,\n    minimumAlpha,\n    compressionLevel,\n    optimizeSplatData = true,\n    sectionSize,\n    sceneCenter,\n    blockSize,\n    bucketSize,\n    fetchWithProgress = defaultFetchWithProgress,\n  ) {\n    let internalLoadType = loadDirectoToSplatBuffer ?\n      InternalLoadType.DirectToSplatBuffer :\n      InternalLoadType.DirectToSplatArray;\n    if (optimizeSplatData) {\n      internalLoadType = InternalLoadType.DirectToSplatArray;\n    }\n\n    const splatDataOffsetBytes =\n      SplatBuffer.HeaderSizeBytes + SplatBuffer.SectionHeaderSizeBytes;\n    const directLoadSectionSizeBytes = Constants.ProgressiveLoadSectionSize;\n    const sectionCount = 1;\n\n    let directLoadBufferIn;\n    let directLoadBufferOut;\n    let directLoadSplatBuffer;\n    let maxSplatCount = 0;\n    let splatCount = 0;\n\n    let standardLoadUncompressedSplatArray;\n\n    const loadPromise = nativePromiseWithExtractedComponents();\n\n    let numBytesStreamed = 0;\n    let numBytesLoaded = 0;\n    let chunks = [];\n\n    const localOnProgress = (percent, percentStr, chunk, fileSize) => {\n      const loadComplete = percent >= 100;\n\n      if (chunk) {\n        chunks.push(chunk);\n      }\n\n      if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n        if (loadComplete) {\n          loadPromise.resolve(chunks);\n        }\n        return;\n      }\n\n      if (!fileSize) {\n        if (loadDirectoToSplatBuffer) {\n          throw new DirectLoadError(\n            'Cannon directly load .splat because no file size info is available.',\n          );\n        } else {\n          internalLoadType = InternalLoadType.DownloadBeforeProcessing;\n          return;\n        }\n      }\n\n      if (!directLoadBufferIn) {\n        maxSplatCount = fileSize / SplatParser.RowSizeBytes;\n        directLoadBufferIn = new ArrayBuffer(fileSize);\n        const bytesPerSplat =\n          SplatBuffer.CompressionLevels[0].SphericalHarmonicsDegrees[0]\n            .BytesPerSplat;\n        const splatBufferSizeBytes =\n          splatDataOffsetBytes + bytesPerSplat * maxSplatCount;\n\n        if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n          directLoadBufferOut = new ArrayBuffer(splatBufferSizeBytes);\n          SplatBuffer.writeHeaderToBuffer(\n            {\n              versionMajor: SplatBuffer.CurrentMajorVersion,\n              versionMinor: SplatBuffer.CurrentMinorVersion,\n              maxSectionCount: sectionCount,\n              sectionCount: sectionCount,\n              maxSplatCount: maxSplatCount,\n              splatCount: splatCount,\n              compressionLevel: 0,\n              sceneCenter: new THREE.Vector3(),\n            },\n            directLoadBufferOut,\n          );\n        } else {\n          standardLoadUncompressedSplatArray = new UncompressedSplatArray(0);\n        }\n      }\n\n      if (chunk) {\n        new Uint8Array(\n          directLoadBufferIn,\n          numBytesLoaded,\n          chunk.byteLength,\n        ).set(new Uint8Array(chunk));\n        numBytesLoaded += chunk.byteLength;\n\n        const bytesLoadedSinceLastSection = numBytesLoaded - numBytesStreamed;\n        if (\n          bytesLoadedSinceLastSection > directLoadSectionSizeBytes ||\n          loadComplete\n        ) {\n          const bytesToUpdate = loadComplete ?\n            bytesLoadedSinceLastSection :\n            directLoadSectionSizeBytes;\n          const addedSplatCount = bytesToUpdate / SplatParser.RowSizeBytes;\n          const newSplatCount = splatCount + addedSplatCount;\n\n          if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n            SplatParser.parseToUncompressedSplatBufferSection(\n              splatCount,\n              newSplatCount - 1,\n              directLoadBufferIn,\n              0,\n              directLoadBufferOut,\n              splatDataOffsetBytes,\n            );\n          } else {\n            SplatParser.parseToUncompressedSplatArraySection(\n              splatCount,\n              newSplatCount - 1,\n              directLoadBufferIn,\n              0,\n              standardLoadUncompressedSplatArray,\n            );\n          }\n\n          splatCount = newSplatCount;\n\n          if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n            if (!directLoadSplatBuffer) {\n              SplatBuffer.writeSectionHeaderToBuffer(\n                {\n                  maxSplatCount: maxSplatCount,\n                  splatCount: splatCount,\n                  bucketSize: 0,\n                  bucketCount: 0,\n                  bucketBlockSize: 0,\n                  compressionScaleRange: 0,\n                  storageSizeBytes: 0,\n                  fullBucketCount: 0,\n                  partiallyFilledBucketCount: 0,\n                },\n                0,\n                directLoadBufferOut,\n                SplatBuffer.HeaderSizeBytes,\n              );\n              directLoadSplatBuffer = new SplatBuffer(\n                directLoadBufferOut,\n                false,\n              );\n            }\n            directLoadSplatBuffer.updateLoadedCounts(1, splatCount);\n            if (onProgressiveLoadSectionProgress) {\n              onProgressiveLoadSectionProgress(\n                directLoadSplatBuffer,\n                loadComplete,\n              );\n            }\n          }\n\n          numBytesStreamed += directLoadSectionSizeBytes;\n        }\n      }\n\n      if (loadComplete) {\n        if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n          loadPromise.resolve(directLoadSplatBuffer);\n        } else {\n          loadPromise.resolve(standardLoadUncompressedSplatArray);\n        }\n      }\n\n      if (onProgress) onProgress(percent, percentStr, LoaderStatus.Downloading);\n    };\n\n    if (onProgress) onProgress(0, '0%', LoaderStatus.Downloading);\n    return fetchWithProgress(fileName, localOnProgress, false).then(() => {\n      if (onProgress) onProgress(0, '0%', LoaderStatus.Processing);\n      return loadPromise.promise.then((splatData) => {\n        if (onProgress) onProgress(100, '100%', LoaderStatus.Done);\n        if (internalLoadType === InternalLoadType.DownloadBeforeProcessing) {\n          return new Blob(chunks).arrayBuffer().then((splatData) => {\n            return SplatLoader.loadFromFileData(\n              splatData,\n              minimumAlpha,\n              compressionLevel,\n              optimizeSplatData,\n              sectionSize,\n              sceneCenter,\n              blockSize,\n              bucketSize,\n            );\n          });\n        } else if (internalLoadType === InternalLoadType.DirectToSplatBuffer) {\n          return splatData;\n        } else {\n          return delayedExecute(() => {\n            return finalize(\n              splatData,\n              optimizeSplatData,\n              minimumAlpha,\n              compressionLevel,\n              sectionSize,\n              sceneCenter,\n              blockSize,\n              bucketSize,\n            );\n          });\n        }\n      });\n    });\n  }\n\n  static loadFromFileData(\n    splatFileData,\n    minimumAlpha,\n    compressionLevel,\n    optimizeSplatData,\n    sectionSize,\n    sceneCenter,\n    blockSize,\n    bucketSize,\n  ) {\n    return delayedExecute(() => {\n      const splatArray =\n        SplatParser.parseStandardSplatToUncompressedSplatArray(splatFileData);\n      return finalize(\n        splatArray,\n        optimizeSplatData,\n        minimumAlpha,\n        compressionLevel,\n        sectionSize,\n        sceneCenter,\n        blockSize,\n        bucketSize,\n      );\n    });\n  }\n}\n","import { Constants } from '../../Constants.js';\nimport {\n  fetchWithProgress as defaultFetchWithProgress,\n  delayedExecute,\n  nativePromiseWithExtractedComponents,\n} from '../../Util.js';\nimport { LoaderStatus } from '../LoaderStatus.js';\nimport { SplatBuffer } from '../SplatBuffer.js';\n\nexport class KSplatLoader {\n  static checkVersion(buffer) {\n    const minVersionMajor = SplatBuffer.CurrentMajorVersion;\n    const minVersionMinor = SplatBuffer.CurrentMinorVersion;\n    const header = SplatBuffer.parseHeader(buffer);\n    if (\n      (header.versionMajor === minVersionMajor &&\n        header.versionMinor >= minVersionMinor) ||\n      header.versionMajor > minVersionMajor\n    ) {\n      return true;\n    } else {\n      throw new Error(\n        `KSplat version not supported: v${header.versionMajor}.${header.versionMinor}. ` +\n          `Minimum required: v${minVersionMajor}.${minVersionMinor}`,\n      );\n    }\n  }\n\n  static loadFromURL(\n    fileName,\n    externalOnProgress,\n    loadDirectoToSplatBuffer,\n    onSectionBuilt,\n    fetchWithProgress = defaultFetchWithProgress,\n  ) {\n    let directLoadBuffer;\n    let directLoadSplatBuffer;\n\n    let headerBuffer;\n    let header;\n    let headerLoaded = false;\n    let headerLoading = false;\n\n    let sectionHeadersBuffer;\n    let sectionHeaders = [];\n    let sectionHeadersLoaded = false;\n    let sectionHeadersLoading = false;\n\n    let numBytesLoaded = 0;\n    let numBytesProgressivelyLoaded = 0;\n    let totalBytesToDownload = 0;\n\n    let downloadComplete = false;\n    let loadComplete = false;\n    let loadSectionQueued = false;\n\n    let chunks = [];\n\n    const directLoadPromise = nativePromiseWithExtractedComponents();\n\n    const checkAndLoadHeader = () => {\n      if (\n        !headerLoaded &&\n        !headerLoading &&\n        numBytesLoaded >= SplatBuffer.HeaderSizeBytes\n      ) {\n        headerLoading = true;\n        const headerAssemblyPromise = new Blob(chunks).arrayBuffer();\n        headerAssemblyPromise.then((bufferData) => {\n          headerBuffer = new ArrayBuffer(SplatBuffer.HeaderSizeBytes);\n          new Uint8Array(headerBuffer).set(\n            new Uint8Array(bufferData, 0, SplatBuffer.HeaderSizeBytes),\n          );\n          KSplatLoader.checkVersion(headerBuffer);\n          headerLoading = false;\n          headerLoaded = true;\n          header = SplatBuffer.parseHeader(headerBuffer);\n          window.setTimeout(() => {\n            checkAndLoadSectionHeaders();\n          }, 1);\n        });\n      }\n    };\n\n    let queuedCheckAndLoadSectionsCount = 0;\n    const queueCheckAndLoadSections = () => {\n      if (queuedCheckAndLoadSectionsCount === 0) {\n        queuedCheckAndLoadSectionsCount++;\n        window.setTimeout(() => {\n          queuedCheckAndLoadSectionsCount--;\n          checkAndLoadSections();\n        }, 1);\n      }\n    };\n\n    const checkAndLoadSectionHeaders = () => {\n      const performLoad = () => {\n        sectionHeadersLoading = true;\n        const sectionHeadersAssemblyPromise = new Blob(chunks).arrayBuffer();\n        sectionHeadersAssemblyPromise.then((bufferData) => {\n          sectionHeadersLoading = false;\n          sectionHeadersLoaded = true;\n          sectionHeadersBuffer = new ArrayBuffer(\n            header.maxSectionCount * SplatBuffer.SectionHeaderSizeBytes,\n          );\n          new Uint8Array(sectionHeadersBuffer).set(\n            new Uint8Array(\n              bufferData,\n              SplatBuffer.HeaderSizeBytes,\n              header.maxSectionCount * SplatBuffer.SectionHeaderSizeBytes,\n            ),\n          );\n          sectionHeaders = SplatBuffer.parseSectionHeaders(\n            header,\n            sectionHeadersBuffer,\n            0,\n            false,\n          );\n          let totalSectionStorageStorageByes = 0;\n          for (let i = 0; i < header.maxSectionCount; i++) {\n            totalSectionStorageStorageByes +=\n              sectionHeaders[i].storageSizeBytes;\n          }\n          const totalStorageSizeBytes =\n            SplatBuffer.HeaderSizeBytes +\n            header.maxSectionCount * SplatBuffer.SectionHeaderSizeBytes +\n            totalSectionStorageStorageByes;\n          if (!directLoadBuffer) {\n            directLoadBuffer = new ArrayBuffer(totalStorageSizeBytes);\n            let offset = 0;\n            for (let i = 0; i < chunks.length; i++) {\n              const chunk = chunks[i];\n              new Uint8Array(directLoadBuffer, offset, chunk.byteLength).set(\n                new Uint8Array(chunk),\n              );\n              offset += chunk.byteLength;\n            }\n          }\n\n          totalBytesToDownload =\n            SplatBuffer.HeaderSizeBytes +\n            SplatBuffer.SectionHeaderSizeBytes * header.maxSectionCount;\n          for (\n            let i = 0;\n            i <= sectionHeaders.length && i < header.maxSectionCount;\n            i++\n          ) {\n            totalBytesToDownload += sectionHeaders[i].storageSizeBytes;\n          }\n\n          queueCheckAndLoadSections();\n        });\n      };\n\n      if (\n        !sectionHeadersLoading &&\n        !sectionHeadersLoaded &&\n        headerLoaded &&\n        numBytesLoaded >=\n          SplatBuffer.HeaderSizeBytes +\n            SplatBuffer.SectionHeaderSizeBytes * header.maxSectionCount\n      ) {\n        performLoad();\n      }\n    };\n\n    const checkAndLoadSections = () => {\n      if (loadSectionQueued) return;\n      loadSectionQueued = true;\n      const checkAndLoadFunc = () => {\n        loadSectionQueued = false;\n        if (sectionHeadersLoaded) {\n          if (loadComplete) return;\n\n          downloadComplete = numBytesLoaded >= totalBytesToDownload;\n\n          let bytesLoadedSinceLastSection =\n            numBytesLoaded - numBytesProgressivelyLoaded;\n          if (\n            bytesLoadedSinceLastSection >\n              Constants.ProgressiveLoadSectionSize ||\n            downloadComplete\n          ) {\n            numBytesProgressivelyLoaded += Constants.ProgressiveLoadSectionSize;\n            loadComplete = numBytesProgressivelyLoaded >= totalBytesToDownload;\n\n            if (!directLoadSplatBuffer) {\n              directLoadSplatBuffer = new SplatBuffer(directLoadBuffer, false);\n            }\n\n            const baseDataOffset =\n              SplatBuffer.HeaderSizeBytes +\n              SplatBuffer.SectionHeaderSizeBytes * header.maxSectionCount;\n            let sectionBase = 0;\n            let reachedSections = 0;\n            let loadedSplatCount = 0;\n            for (let i = 0; i < header.maxSectionCount; i++) {\n              const sectionHeader = sectionHeaders[i];\n              const bucketsDataOffset =\n                sectionBase +\n                sectionHeader.partiallyFilledBucketCount * 4 +\n                sectionHeader.bucketStorageSizeBytes *\n                  sectionHeader.bucketCount;\n              const bytesRequiredToReachSectionSplatData =\n                baseDataOffset + bucketsDataOffset;\n              if (\n                numBytesProgressivelyLoaded >=\n                bytesRequiredToReachSectionSplatData\n              ) {\n                reachedSections++;\n                const bytesPastSSectionSplatDataStart =\n                  numBytesProgressivelyLoaded -\n                  bytesRequiredToReachSectionSplatData;\n                const baseDescriptor =\n                  SplatBuffer.CompressionLevels[header.compressionLevel];\n                const shDesc =\n                  baseDescriptor.SphericalHarmonicsDegrees[\n                    sectionHeader.sphericalHarmonicsDegree\n                  ];\n                const bytesPerSplat = shDesc.BytesPerSplat;\n                let loadedSplatsForSection = Math.floor(\n                  bytesPastSSectionSplatDataStart / bytesPerSplat,\n                );\n                loadedSplatsForSection = Math.min(\n                  loadedSplatsForSection,\n                  sectionHeader.maxSplatCount,\n                );\n                loadedSplatCount += loadedSplatsForSection;\n                directLoadSplatBuffer.updateLoadedCounts(\n                  reachedSections,\n                  loadedSplatCount,\n                );\n                directLoadSplatBuffer.updateSectionLoadedCounts(\n                  i,\n                  loadedSplatsForSection,\n                );\n              } else {\n                break;\n              }\n              sectionBase += sectionHeader.storageSizeBytes;\n            }\n\n            onSectionBuilt(directLoadSplatBuffer, loadComplete);\n\n            const percentComplete =\n              (numBytesProgressivelyLoaded / totalBytesToDownload) * 100;\n            const percentLabel = percentComplete.toFixed(2) + '%';\n\n            if (externalOnProgress) {\n              externalOnProgress(\n                percentComplete,\n                percentLabel,\n                LoaderStatus.Downloading,\n              );\n            }\n\n            if (loadComplete) {\n              directLoadPromise.resolve(directLoadSplatBuffer);\n            } else {\n              checkAndLoadSections();\n            }\n          }\n        }\n      };\n      window.setTimeout(\n        checkAndLoadFunc,\n        Constants.ProgressiveLoadSectionDelayDuration,\n      );\n    };\n\n    const localOnProgress = (percent, percentStr, chunk) => {\n      if (chunk) {\n        chunks.push(chunk);\n        if (directLoadBuffer) {\n          new Uint8Array(\n            directLoadBuffer,\n            numBytesLoaded,\n            chunk.byteLength,\n          ).set(new Uint8Array(chunk));\n        }\n        numBytesLoaded += chunk.byteLength;\n      }\n      if (loadDirectoToSplatBuffer) {\n        checkAndLoadHeader();\n        checkAndLoadSectionHeaders();\n        checkAndLoadSections();\n      } else {\n        if (externalOnProgress) {\n          externalOnProgress(percent, percentStr, LoaderStatus.Downloading);\n        }\n      }\n    };\n\n    return fetchWithProgress(\n      fileName,\n      localOnProgress,\n      !loadDirectoToSplatBuffer,\n    ).then((fullBuffer) => {\n      if (externalOnProgress) {\n        externalOnProgress(0, '0%', LoaderStatus.Processing);\n      }\n      const loadPromise = loadDirectoToSplatBuffer ?\n        directLoadPromise.promise :\n        KSplatLoader.loadFromFileData(fullBuffer);\n      return loadPromise.then((splatBuffer) => {\n        if (externalOnProgress) {\n          externalOnProgress(100, '100%', LoaderStatus.Done);\n        }\n        return splatBuffer;\n      });\n    });\n  }\n\n  static loadFromFileData(fileData) {\n    return delayedExecute(() => {\n      KSplatLoader.checkVersion(fileData);\n      return new SplatBuffer(fileData);\n    });\n  }\n\n  static downloadFile = (function() {\n    let downLoadLink;\n\n    return function(splatBuffer, fileName) {\n      const blob = new Blob([splatBuffer.bufferData], {\n        type: 'application/octet-stream',\n      });\n\n      if (!downLoadLink) {\n        downLoadLink = document.createElement('a');\n        document.body.appendChild(downLoadLink);\n      }\n      downLoadLink.download = fileName;\n      downLoadLink.href = URL.createObjectURL(blob);\n      downLoadLink.click();\n    };\n  })();\n}\n","export const SceneFormat = {\n  Splat: 0,\n  KSplat: 1,\n  Ply: 2,\n  GLTF: 3,\n};\n","import { SceneFormat } from './SceneFormat.js';\n\nexport const sceneFormatFromPath = (path) => {\n  if (path.endsWith('.ply')) return SceneFormat.Ply;\n  else if (path.endsWith('.splat')) return SceneFormat.Splat;\n  else if (path.endsWith('.ksplat')) return SceneFormat.KSplat;\n  else if (path.endsWith('.gltf')) return SceneFormat.GLTF;\n  return null;\n};\n","export const LogLevel = {\n  None: 0,\n  Error: 1,\n  Warning: 2,\n  Info: 3,\n  Debug: 4,\n};\n","/*\nCopyright  2010-2024 three.js authors & Mark Kellogg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n*/\n\nimport {\n  EventDispatcher,\n  MOUSE,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Plane,\n  Ray,\n  MathUtils,\n} from 'three';\n\n// OrbitControls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst _changeEvent = { type: 'change' };\nconst _startEvent = { type: 'start' };\nconst _endEvent = { type: 'end' };\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);\n\nclass OrbitControls extends EventDispatcher {\n  constructor(object, domElement) {\n    super();\n\n    this.object = object;\n    this.domElement = domElement;\n    this.domElement.style.touchAction = 'none'; // disable touch scroll\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // \"target\" sets the location of focus, where the object orbits around\n    this.target = new Vector3();\n\n    // How far you can dolly in and out ( PerspectiveCamera only )\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // How far you can zoom in and out ( OrthographicCamera only )\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, the interval [min, max] must be a sub-interval of [- 2 PI, 2 PI], with ( max - min < 2 PI )\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    this.enableDamping = false;\n    this.dampingFactor = 0.05;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n    // Set to false to disable zooming\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0;\n\n    // Set to false to disable rotating\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0;\n\n    // Set to false to disable panning\n    this.enablePan = true;\n    this.panSpeed = 1.0;\n    this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n    this.zoomToCursor = false;\n\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60\n\n    // The four arrow keys\n    this.keys = { LEFT: 'KeyA', UP: 'KeyW', RIGHT: 'KeyD', BOTTOM: 'KeyS' };\n\n    // Mouse buttons\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN,\n    };\n\n    // Touch fingers\n    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n\n    // for reset\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n\n    // the target DOM element for key events\n    this._domElementKeyEvents = null;\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = function() {\n      return spherical.phi;\n    };\n\n    this.getAzimuthalAngle = function() {\n      return spherical.theta;\n    };\n\n    this.getDistance = function() {\n      return this.object.position.distanceTo(this.target);\n    };\n\n    this.listenToKeyEvents = function(domElement) {\n      domElement.addEventListener('keydown', onKeyDown);\n      this._domElementKeyEvents = domElement;\n    };\n\n    this.stopListenToKeyEvents = function() {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown);\n      this._domElementKeyEvents = null;\n    };\n\n    this.saveState = function() {\n      scope.target0.copy(scope.target);\n      scope.position0.copy(scope.object.position);\n      scope.zoom0 = scope.object.zoom;\n    };\n\n    this.reset = function() {\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.zoom = scope.zoom0;\n      this.clearDampedRotation();\n      this.clearDampedPan();\n\n      scope.object.updateProjectionMatrix();\n      scope.dispatchEvent(_changeEvent);\n\n      scope.update();\n\n      state = STATE.NONE;\n    };\n\n    this.clearDampedRotation = function() {\n      sphericalDelta.theta = 0.0;\n      sphericalDelta.phi = 0.0;\n    };\n\n    this.clearDampedPan = function() {\n      panOffset.set(0, 0, 0);\n    };\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = (function() {\n      const offset = new Vector3();\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(\n        object.up,\n        new Vector3(0, 1, 0),\n      );\n      const quatInverse = quat.clone().invert();\n\n      const lastPosition = new Vector3();\n      const lastQuaternion = new Quaternion();\n      const lastTargetPosition = new Vector3();\n\n      const twoPI = 2 * Math.PI;\n\n      return function update() {\n        quat.setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n        quatInverse.copy(quat).invert();\n\n        const position = scope.object.position;\n\n        offset.copy(position).sub(scope.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset);\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle());\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n        } else {\n          spherical.theta += sphericalDelta.theta;\n          spherical.phi += sphericalDelta.phi;\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle;\n        let max = scope.maxAzimuthAngle;\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI;\n          else if (min > Math.PI) min -= twoPI;\n\n          if (max < -Math.PI) max += twoPI;\n          else if (max > Math.PI) max -= twoPI;\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ?\n                Math.max(min, spherical.theta) :\n                Math.min(max, spherical.theta);\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(\n          scope.minPolarAngle,\n          Math.min(scope.maxPolarAngle, spherical.phi),\n        );\n\n        spherical.makeSafe();\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor);\n        } else {\n          scope.target.add(panOffset);\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if (\n          (scope.zoomToCursor && performCursorZoom) ||\n          scope.object.isOrthographicCamera\n        ) {\n          spherical.radius = clampDistance(spherical.radius);\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale);\n        }\n\n        offset.setFromSpherical(spherical);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(scope.target).add(offset);\n\n        scope.object.lookAt(scope.target);\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor;\n          sphericalDelta.phi *= 1 - scope.dampingFactor;\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor);\n        } else {\n          sphericalDelta.set(0, 0, 0);\n\n          panOffset.set(0, 0, 0);\n        }\n\n        // adjust camera position\n        let zoomChanged = false;\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null;\n          if (scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length();\n            newRadius = clampDistance(prevRadius * scale);\n\n            const radiusDelta = prevRadius - newRadius;\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n            scope.object.updateMatrixWorld();\n          } else if (scope.object.isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0);\n            mouseBefore.unproject(scope.object);\n\n            scope.object.zoom = Math.max(\n              scope.minZoom,\n              Math.min(scope.maxZoom, scope.object.zoom / scale),\n            );\n            scope.object.updateProjectionMatrix();\n            zoomChanged = true;\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0);\n            mouseAfter.unproject(scope.object);\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore);\n            scope.object.updateMatrixWorld();\n\n            newRadius = offset.length();\n          } else {\n            console.warn(\n              'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.',\n            );\n            scope.zoomToCursor = false;\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (this.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position);\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position);\n              _ray.direction\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix);\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target);\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(\n                  scope.object.up,\n                  scope.target,\n                );\n                _ray.intersectPlane(_plane, scope.target);\n              }\n            }\n          }\n        } else if (scope.object.isOrthographicCamera) {\n          scope.object.zoom = Math.max(\n            scope.minZoom,\n            Math.min(scope.maxZoom, scope.object.zoom / scale),\n          );\n          scope.object.updateProjectionMatrix();\n          zoomChanged = true;\n        }\n\n        scale = 1;\n        performCursorZoom = false;\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS ||\n          lastTargetPosition.distanceToSquared(scope.target) > 0\n        ) {\n          scope.dispatchEvent(_changeEvent);\n\n          lastPosition.copy(scope.object.position);\n          lastQuaternion.copy(scope.object.quaternion);\n          lastTargetPosition.copy(scope.target);\n\n          zoomChanged = false;\n\n          return true;\n        }\n\n        return false;\n      };\n    })();\n\n    this.dispose = function() {\n      scope.domElement.removeEventListener('contextmenu', onContextMenu);\n\n      scope.domElement.removeEventListener('pointerdown', onPointerDown);\n      scope.domElement.removeEventListener('pointercancel', onPointerUp);\n      scope.domElement.removeEventListener('wheel', onMouseWheel);\n\n      scope.domElement.removeEventListener('pointermove', onPointerMove);\n      scope.domElement.removeEventListener('pointerup', onPointerUp);\n\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);\n        scope._domElementKeyEvents = null;\n      }\n    };\n\n    //\n    // internals\n    //\n\n    const scope = this;\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    };\n\n    let state = STATE.NONE;\n\n    const EPS = 0.000001;\n\n    // current position in spherical coordinates\n    const spherical = new Spherical();\n    const sphericalDelta = new Spherical();\n\n    let scale = 1;\n    const panOffset = new Vector3();\n\n    const rotateStart = new Vector2();\n    const rotateEnd = new Vector2();\n    const rotateDelta = new Vector2();\n\n    const panStart = new Vector2();\n    const panEnd = new Vector2();\n    const panDelta = new Vector2();\n\n    const dollyStart = new Vector2();\n    const dollyEnd = new Vector2();\n    const dollyDelta = new Vector2();\n\n    const dollyDirection = new Vector3();\n    const mouse = new Vector2();\n    let performCursorZoom = false;\n\n    const pointers = [];\n    const pointerPositions = {};\n\n    function getAutoRotationAngle() {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;\n    }\n\n    function getZoomScale() {\n      return Math.pow(0.95, scope.zoomSpeed);\n    }\n\n    function rotateLeft(angle) {\n      sphericalDelta.theta -= angle;\n    }\n\n    function rotateUp(angle) {\n      sphericalDelta.phi -= angle;\n    }\n\n    const panLeft = (function() {\n      const v = new Vector3();\n\n      return function panLeft(distance, objectMatrix) {\n        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n        v.multiplyScalar(-distance);\n\n        panOffset.add(v);\n      };\n    })();\n\n    const panUp = (function() {\n      const v = new Vector3();\n\n      return function panUp(distance, objectMatrix) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1);\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0);\n          v.crossVectors(scope.object.up, v);\n        }\n\n        v.multiplyScalar(distance);\n\n        panOffset.add(v);\n      };\n    })();\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (function() {\n      const offset = new Vector3();\n\n      return function pan(deltaX, deltaY) {\n        const element = scope.domElement;\n\n        if (scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position;\n          offset.copy(position).sub(scope.target);\n          let targetDistance = offset.length();\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(\n            ((scope.object.fov / 2) * Math.PI) / 180.0,\n          );\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft(\n            (2 * deltaX * targetDistance) / element.clientHeight,\n            scope.object.matrix,\n          );\n          panUp(\n            (2 * deltaY * targetDistance) / element.clientHeight,\n            scope.object.matrix,\n          );\n        } else if (scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) /\n              scope.object.zoom /\n              element.clientWidth,\n            scope.object.matrix,\n          );\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) /\n              scope.object.zoom /\n              element.clientHeight,\n            scope.object.matrix,\n          );\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn(\n            'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.',\n          );\n          scope.enablePan = false;\n        }\n      };\n    })();\n\n    function dollyOut(dollyScale) {\n      if (\n        scope.object.isPerspectiveCamera ||\n        scope.object.isOrthographicCamera\n      ) {\n        scale /= dollyScale;\n      } else {\n        console.warn(\n          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',\n        );\n        scope.enableZoom = false;\n      }\n    }\n\n    function dollyIn(dollyScale) {\n      if (\n        scope.object.isPerspectiveCamera ||\n        scope.object.isOrthographicCamera\n      ) {\n        scale *= dollyScale;\n      } else {\n        console.warn(\n          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',\n        );\n        scope.enableZoom = false;\n      }\n    }\n\n    function updateMouseParameters(event) {\n      if (!scope.zoomToCursor) {\n        return;\n      }\n\n      performCursorZoom = true;\n\n      const rect = scope.domElement.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n      const w = rect.width;\n      const h = rect.height;\n\n      mouse.x = (x / w) * 2 - 1;\n      mouse.y = -(y / h) * 2 + 1;\n\n      dollyDirection\n        .set(mouse.x, mouse.y, 1)\n        .unproject(object)\n        .sub(object.position)\n        .normalize();\n    }\n\n    function clampDistance(dist) {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event) {\n      rotateStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownDolly(event) {\n      updateMouseParameters(event);\n      dollyStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseDownPan(event) {\n      panStart.set(event.clientX, event.clientY);\n    }\n\n    function handleMouseMoveRotate(event) {\n      rotateEnd.set(event.clientX, event.clientY);\n\n      rotateDelta\n        .subVectors(rotateEnd, rotateStart)\n        .multiplyScalar(scope.rotateSpeed);\n\n      const element = scope.domElement;\n\n      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n      rotateStart.copy(rotateEnd);\n\n      scope.update();\n    }\n\n    function handleMouseMoveDolly(event) {\n      dollyEnd.set(event.clientX, event.clientY);\n\n      dollyDelta.subVectors(dollyEnd, dollyStart);\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale());\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale());\n      }\n\n      dollyStart.copy(dollyEnd);\n\n      scope.update();\n    }\n\n    function handleMouseMovePan(event) {\n      panEnd.set(event.clientX, event.clientY);\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n      pan(panDelta.x, panDelta.y);\n\n      panStart.copy(panEnd);\n\n      scope.update();\n    }\n\n    function handleMouseWheel(event) {\n      updateMouseParameters(event);\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale());\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale());\n      }\n\n      scope.update();\n    }\n\n    function handleKeyDown(event) {\n      let needsUpdate = false;\n\n      switch (event.code) {\n        case scope.keys.UP:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            rotateUp(\n              (2 * Math.PI * scope.rotateSpeed) / scope.domElement.clientHeight,\n            );\n          } else {\n            pan(0, scope.keyPanSpeed);\n          }\n\n          needsUpdate = true;\n          break;\n\n        case scope.keys.BOTTOM:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            rotateUp(\n              (-2 * Math.PI * scope.rotateSpeed) /\n                scope.domElement.clientHeight,\n            );\n          } else {\n            pan(0, -scope.keyPanSpeed);\n          }\n\n          needsUpdate = true;\n          break;\n\n        case scope.keys.LEFT:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            rotateLeft(\n              (2 * Math.PI * scope.rotateSpeed) / scope.domElement.clientHeight,\n            );\n          } else {\n            pan(scope.keyPanSpeed, 0);\n          }\n\n          needsUpdate = true;\n          break;\n\n        case scope.keys.RIGHT:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            rotateLeft(\n              (-2 * Math.PI * scope.rotateSpeed) /\n                scope.domElement.clientHeight,\n            );\n          } else {\n            pan(-scope.keyPanSpeed, 0);\n          }\n\n          needsUpdate = true;\n          break;\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault();\n\n        scope.update();\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length === 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n\n        rotateStart.set(x, y);\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length === 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY);\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n\n        panStart.set(x, y);\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX;\n      const dy = pointers[0].pageY - pointers[1].pageY;\n\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      dollyStart.set(0, distance);\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly();\n\n      if (scope.enablePan) handleTouchStartPan();\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly();\n\n      if (scope.enableRotate) handleTouchStartRotate();\n    }\n\n    function handleTouchMoveRotate(event) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n\n        rotateEnd.set(x, y);\n      }\n\n      rotateDelta\n        .subVectors(rotateEnd, rotateStart)\n        .multiplyScalar(scope.rotateSpeed);\n\n      const element = scope.domElement;\n\n      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n      rotateStart.copy(rotateEnd);\n    }\n\n    function handleTouchMovePan(event) {\n      if (pointers.length === 1) {\n        panEnd.set(event.pageX, event.pageY);\n      } else {\n        const position = getSecondPointerPosition(event);\n\n        const x = 0.5 * (event.pageX + position.x);\n        const y = 0.5 * (event.pageY + position.y);\n\n        panEnd.set(x, y);\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n      pan(panDelta.x, panDelta.y);\n\n      panStart.copy(panEnd);\n    }\n\n    function handleTouchMoveDolly(event) {\n      const position = getSecondPointerPosition(event);\n\n      const dx = event.pageX - position.x;\n      const dy = event.pageY - position.y;\n\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      dollyEnd.set(0, distance);\n\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n      dollyOut(dollyDelta.y);\n\n      dollyStart.copy(dollyEnd);\n    }\n\n    function handleTouchMoveDollyPan(event) {\n      if (scope.enableZoom) handleTouchMoveDolly(event);\n\n      if (scope.enablePan) handleTouchMovePan(event);\n    }\n\n    function handleTouchMoveDollyRotate(event) {\n      if (scope.enableZoom) handleTouchMoveDolly(event);\n\n      if (scope.enableRotate) handleTouchMoveRotate(event);\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event) {\n      if (scope.enabled === false) return;\n\n      if (pointers.length === 0) {\n        scope.domElement.setPointerCapture(event.pointerId);\n\n        scope.domElement.addEventListener('pointermove', onPointerMove);\n        scope.domElement.addEventListener('pointerup', onPointerUp);\n      }\n\n      //\n\n      addPointer(event);\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event);\n      } else {\n        onMouseDown(event);\n      }\n    }\n\n    function onPointerMove(event) {\n      if (scope.enabled === false) return;\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event);\n      } else {\n        onMouseMove(event);\n      }\n    }\n\n    function onPointerUp(event) {\n      removePointer(event);\n\n      if (pointers.length === 0) {\n        scope.domElement.releasePointerCapture(event.pointerId);\n\n        scope.domElement.removeEventListener('pointermove', onPointerMove);\n        scope.domElement.removeEventListener('pointerup', onPointerUp);\n      }\n\n      scope.dispatchEvent(_endEvent);\n\n      state = STATE.NONE;\n    }\n\n    function onMouseDown(event) {\n      let mouseAction;\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT;\n          break;\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE;\n          break;\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT;\n          break;\n\n        default:\n          mouseAction = -1;\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return;\n\n          handleMouseDownDolly(event);\n\n          state = STATE.DOLLY;\n\n          break;\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return;\n\n            handleMouseDownPan(event);\n\n            state = STATE.PAN;\n          } else {\n            if (scope.enableRotate === false) return;\n\n            handleMouseDownRotate(event);\n\n            state = STATE.ROTATE;\n          }\n\n          break;\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return;\n\n            handleMouseDownRotate(event);\n\n            state = STATE.ROTATE;\n          } else {\n            if (scope.enablePan === false) return;\n\n            handleMouseDownPan(event);\n\n            state = STATE.PAN;\n          }\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(_startEvent);\n      }\n    }\n\n    function onMouseMove(event) {\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return;\n\n          handleMouseMoveRotate(event);\n\n          break;\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return;\n\n          handleMouseMoveDolly(event);\n\n          break;\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return;\n\n          handleMouseMovePan(event);\n\n          break;\n      }\n    }\n\n    function onMouseWheel(event) {\n      if (\n        scope.enabled === false ||\n        scope.enableZoom === false ||\n        state !== STATE.NONE\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      scope.dispatchEvent(_startEvent);\n\n      handleMouseWheel(event);\n\n      scope.dispatchEvent(_endEvent);\n    }\n\n    function onKeyDown(event) {\n      if (scope.enabled === false || scope.enablePan === false) return;\n\n      handleKeyDown(event);\n    }\n\n    function onTouchStart(event) {\n      trackPointer(event);\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return;\n\n              handleTouchStartRotate();\n\n              state = STATE.TOUCH_ROTATE;\n\n              break;\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return;\n\n              handleTouchStartPan();\n\n              state = STATE.TOUCH_PAN;\n\n              break;\n\n            default:\n              state = STATE.NONE;\n          }\n\n          break;\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) {\n                return;\n              }\n\n              handleTouchStartDollyPan();\n\n              state = STATE.TOUCH_DOLLY_PAN;\n\n              break;\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) {\n                return;\n              }\n\n              handleTouchStartDollyRotate();\n\n              state = STATE.TOUCH_DOLLY_ROTATE;\n\n              break;\n\n            default:\n              state = STATE.NONE;\n          }\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n\n      if (state !== STATE.NONE) {\n        scope.dispatchEvent(_startEvent);\n      }\n    }\n\n    function onTouchMove(event) {\n      trackPointer(event);\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return;\n\n          handleTouchMoveRotate(event);\n\n          scope.update();\n\n          break;\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return;\n\n          handleTouchMovePan(event);\n\n          scope.update();\n\n          break;\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return;\n\n          handleTouchMoveDollyPan(event);\n\n          scope.update();\n\n          break;\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) {\n            return;\n          }\n\n          handleTouchMoveDollyRotate(event);\n\n          scope.update();\n\n          break;\n\n        default:\n          state = STATE.NONE;\n      }\n    }\n\n    function onContextMenu(event) {\n      if (scope.enabled === false) return;\n\n      event.preventDefault();\n    }\n\n    function addPointer(event) {\n      pointers.push(event);\n    }\n\n    function removePointer(event) {\n      delete pointerPositions[event.pointerId];\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1);\n          return;\n        }\n      }\n    }\n\n    function trackPointer(event) {\n      let position = pointerPositions[event.pointerId];\n\n      if (position === undefined) {\n        position = new Vector2();\n        pointerPositions[event.pointerId] = position;\n      }\n\n      position.set(event.pageX, event.pageY);\n    }\n\n    function getSecondPointerPosition(event) {\n      const pointer =\n        event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n\n      return pointerPositions[pointer.pointerId];\n    }\n\n    //\n\n    scope.domElement.addEventListener('contextmenu', onContextMenu);\n\n    scope.domElement.addEventListener('pointerdown', onPointerDown);\n    scope.domElement.addEventListener('pointercancel', onPointerUp);\n    scope.domElement.addEventListener('wheel', onMouseWheel, {\n      passive: false,\n    });\n\n    // force an update at start\n\n    this.update();\n  }\n}\n\nexport { OrbitControls };\n","export const RenderMode = {\n  Always: 0,\n  OnChange: 1,\n  Never: 2,\n};\n","import * as THREE from 'three';\n\nconst _axis = new THREE.Vector3();\n\nexport class ArrowHelper extends THREE.Object3D {\n  constructor(\n    dir = new THREE.Vector3(0, 0, 1),\n    origin = new THREE.Vector3(0, 0, 0),\n    length = 1,\n    radius = 0.1,\n    color = 0xffff00,\n    headLength = length * 0.2,\n    headRadius = headLength * 0.2,\n  ) {\n    super();\n\n    this.type = 'ArrowHelper';\n\n    const lineGeometry = new THREE.CylinderGeometry(radius, radius, length, 32);\n    lineGeometry.translate(0, length / 2.0, 0);\n    const coneGeometry = new THREE.CylinderGeometry(\n      0,\n      headRadius,\n      headLength,\n      32,\n    );\n    coneGeometry.translate(0, length, 0);\n\n    this.position.copy(origin);\n\n    this.line = new THREE.Mesh(\n      lineGeometry,\n      new THREE.MeshBasicMaterial({ color: color, toneMapped: false }),\n    );\n    this.line.matrixAutoUpdate = false;\n    this.add(this.line);\n\n    this.cone = new THREE.Mesh(\n      coneGeometry,\n      new THREE.MeshBasicMaterial({ color: color, toneMapped: false }),\n    );\n    this.cone.matrixAutoUpdate = false;\n    this.add(this.cone);\n\n    this.setDirection(dir);\n  }\n\n  setDirection(dir) {\n    if (dir.y > 0.99999) {\n      this.quaternion.set(0, 0, 0, 1);\n    } else if (dir.y < -0.99999) {\n      this.quaternion.set(1, 0, 0, 0);\n    } else {\n      _axis.set(dir.z, 0, -dir.x).normalize();\n      const radians = Math.acos(dir.y);\n      this.quaternion.setFromAxisAngle(_axis, radians);\n    }\n  }\n\n  setColor(color) {\n    this.line.material.color.set(color);\n    this.cone.material.color.set(color);\n  }\n\n  copy(source) {\n    super.copy(source, false);\n    this.line.copy(source.line);\n    this.cone.copy(source.cone);\n    return this;\n  }\n\n  dispose() {\n    this.line.geometry.dispose();\n    this.line.material.dispose();\n    this.cone.geometry.dispose();\n    this.cone.material.dispose();\n  }\n}\n","import * as THREE from 'three';\nimport { ArrowHelper } from './ArrowHelper.js';\nimport { disposeAllMeshes } from './Util.js';\n\nexport class SceneHelper {\n  constructor(threeScene) {\n    this.threeScene = threeScene;\n    this.splatRenderTarget = null;\n    this.renderTargetCopyQuad = null;\n    this.renderTargetCopyCamera = null;\n    this.meshCursor = null;\n    this.focusMarker = null;\n    this.controlPlane = null;\n    this.debugRoot = null;\n    this.secondaryDebugRoot = null;\n  }\n\n  updateSplatRenderTargetForRenderDimensions(width, height) {\n    this.destroySplatRendertarget();\n    this.splatRenderTarget = new THREE.WebGLRenderTarget(width, height, {\n      format: THREE.RGBAFormat,\n      stencilBuffer: false,\n      depthBuffer: true,\n    });\n    this.splatRenderTarget.depthTexture = new THREE.DepthTexture(width, height);\n    this.splatRenderTarget.depthTexture.format = THREE.DepthFormat;\n    this.splatRenderTarget.depthTexture.type = THREE.UnsignedIntType;\n  }\n\n  destroySplatRendertarget() {\n    if (this.splatRenderTarget) {\n      this.splatRenderTarget = null;\n    }\n  }\n\n  setupRenderTargetCopyObjects() {\n    const uniforms = {\n      sourceColorTexture: {\n        type: 't',\n        value: null,\n      },\n      sourceDepthTexture: {\n        type: 't',\n        value: null,\n      },\n    };\n    const renderTargetCopyMaterial = new THREE.ShaderMaterial({\n      vertexShader: `\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            `,\n      fragmentShader: `\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            `,\n      uniforms: uniforms,\n      depthWrite: false,\n      depthTest: false,\n      transparent: true,\n      blending: THREE.CustomBlending,\n      blendSrc: THREE.SrcAlphaFactor,\n      blendSrcAlpha: THREE.SrcAlphaFactor,\n      blendDst: THREE.OneMinusSrcAlphaFactor,\n      blendDstAlpha: THREE.OneMinusSrcAlphaFactor,\n    });\n    renderTargetCopyMaterial.extensions.fragDepth = true;\n    this.renderTargetCopyQuad = new THREE.Mesh(\n      new THREE.PlaneGeometry(2, 2),\n      renderTargetCopyMaterial,\n    );\n    this.renderTargetCopyCamera = new THREE.OrthographicCamera(\n      -1,\n      1,\n      1,\n      -1,\n      0,\n      1,\n    );\n  }\n\n  destroyRenderTargetCopyObjects() {\n    if (this.renderTargetCopyQuad) {\n      disposeAllMeshes(this.renderTargetCopyQuad);\n      this.renderTargetCopyQuad = null;\n    }\n  }\n\n  setupMeshCursor() {\n    if (!this.meshCursor) {\n      const coneGeometry = new THREE.ConeGeometry(0.5, 1.5, 32);\n      const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\n\n      const downArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n      downArrow.rotation.set(0, 0, Math.PI);\n      downArrow.position.set(0, 1, 0);\n      const upArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n      upArrow.position.set(0, -1, 0);\n      const leftArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n      leftArrow.rotation.set(0, 0, Math.PI / 2.0);\n      leftArrow.position.set(1, 0, 0);\n      const rightArrow = new THREE.Mesh(coneGeometry, coneMaterial);\n      rightArrow.rotation.set(0, 0, -Math.PI / 2.0);\n      rightArrow.position.set(-1, 0, 0);\n\n      this.meshCursor = new THREE.Object3D();\n      this.meshCursor.add(downArrow);\n      this.meshCursor.add(upArrow);\n      this.meshCursor.add(leftArrow);\n      this.meshCursor.add(rightArrow);\n      this.meshCursor.scale.set(0.1, 0.1, 0.1);\n      this.threeScene.add(this.meshCursor);\n      this.meshCursor.visible = false;\n    }\n  }\n\n  destroyMeshCursor() {\n    if (this.meshCursor) {\n      disposeAllMeshes(this.meshCursor);\n      this.threeScene.remove(this.meshCursor);\n      this.meshCursor = null;\n    }\n  }\n\n  setMeshCursorVisibility(visible) {\n    this.meshCursor.visible = visible;\n  }\n\n  getMeschCursorVisibility() {\n    return this.meshCursor.visible;\n  }\n\n  setMeshCursorPosition(position) {\n    this.meshCursor.position.copy(position);\n  }\n\n  positionAndOrientMeshCursor(position, camera) {\n    this.meshCursor.position.copy(position);\n    this.meshCursor.up.copy(camera.up);\n    this.meshCursor.lookAt(camera.position);\n  }\n\n  setupFocusMarker() {\n    if (!this.focusMarker) {\n      const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);\n      const focusMarkerMaterial = SceneHelper.buildFocusMarkerMaterial();\n      focusMarkerMaterial.depthTest = false;\n      focusMarkerMaterial.depthWrite = false;\n      focusMarkerMaterial.transparent = true;\n      this.focusMarker = new THREE.Mesh(sphereGeometry, focusMarkerMaterial);\n    }\n  }\n\n  destroyFocusMarker() {\n    if (this.focusMarker) {\n      disposeAllMeshes(this.focusMarker);\n      this.focusMarker = null;\n    }\n  }\n\n  updateFocusMarker = (function() {\n    const tempPosition = new THREE.Vector3();\n    const tempMatrix = new THREE.Matrix4();\n    const toCamera = new THREE.Vector3();\n\n    return function(position, camera, viewport) {\n      tempMatrix.copy(camera.matrixWorld).invert();\n      tempPosition.copy(position).applyMatrix4(tempMatrix);\n      tempPosition.normalize().multiplyScalar(10);\n      tempPosition.applyMatrix4(camera.matrixWorld);\n      toCamera.copy(camera.position).sub(position);\n      const toCameraDistance = toCamera.length();\n      this.focusMarker.position.copy(position);\n      this.focusMarker.scale.set(\n        toCameraDistance,\n        toCameraDistance,\n        toCameraDistance,\n      );\n      this.focusMarker.material.uniforms.realFocusPosition.value.copy(position);\n      this.focusMarker.material.uniforms.viewport.value.copy(viewport);\n      this.focusMarker.material.uniformsNeedUpdate = true;\n    };\n  })();\n\n  setFocusMarkerVisibility(visible) {\n    this.focusMarker.visible = visible;\n  }\n\n  setFocusMarkerOpacity(opacity) {\n    this.focusMarker.material.uniforms.opacity.value = opacity;\n    this.focusMarker.material.uniformsNeedUpdate = true;\n  }\n\n  getFocusMarkerOpacity() {\n    return this.focusMarker.material.uniforms.opacity.value;\n  }\n\n  setupControlPlane() {\n    if (!this.controlPlane) {\n      const planeGeometry = new THREE.PlaneGeometry(1, 1);\n      planeGeometry.rotateX(-Math.PI / 2);\n      const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\n      planeMaterial.transparent = true;\n      planeMaterial.opacity = 0.6;\n      planeMaterial.depthTest = false;\n      planeMaterial.depthWrite = false;\n      planeMaterial.side = THREE.DoubleSide;\n      const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);\n\n      const arrowDir = new THREE.Vector3(0, 1, 0);\n      arrowDir.normalize();\n      const arrowOrigin = new THREE.Vector3(0, 0, 0);\n      const arrowLength = 0.5;\n      const arrowRadius = 0.01;\n      const arrowColor = 0x00dd00;\n      const arrowHelper = new ArrowHelper(\n        arrowDir,\n        arrowOrigin,\n        arrowLength,\n        arrowRadius,\n        arrowColor,\n        0.1,\n        0.03,\n      );\n\n      this.controlPlane = new THREE.Object3D();\n      this.controlPlane.add(planeMesh);\n      this.controlPlane.add(arrowHelper);\n    }\n  }\n\n  destroyControlPlane() {\n    if (this.controlPlane) {\n      disposeAllMeshes(this.controlPlane);\n      this.controlPlane = null;\n    }\n  }\n\n  setControlPlaneVisibility(visible) {\n    this.controlPlane.visible = visible;\n  }\n\n  positionAndOrientControlPlane = (function() {\n    const tempQuaternion = new THREE.Quaternion();\n    const defaultUp = new THREE.Vector3(0, 1, 0);\n\n    return function(position, up) {\n      tempQuaternion.setFromUnitVectors(defaultUp, up);\n      this.controlPlane.position.copy(position);\n      this.controlPlane.quaternion.copy(tempQuaternion);\n    };\n  })();\n\n  addDebugMeshes() {\n    this.debugRoot = this.createDebugMeshes();\n    this.secondaryDebugRoot = this.createSecondaryDebugMeshes();\n    this.threeScene.add(this.debugRoot);\n    this.threeScene.add(this.secondaryDebugRoot);\n  }\n\n  destroyDebugMeshes() {\n    for (let debugRoot of [this.debugRoot, this.secondaryDebugRoot]) {\n      if (debugRoot) {\n        disposeAllMeshes(debugRoot);\n        this.threeScene.remove(debugRoot);\n      }\n    }\n    this.debugRoot = null;\n    this.secondaryDebugRoot = null;\n  }\n\n  createDebugMeshes(renderOrder) {\n    const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);\n    const debugMeshRoot = new THREE.Object3D();\n\n    const createMesh = (color, position) => {\n      let sphereMesh = new THREE.Mesh(\n        sphereGeometry,\n        SceneHelper.buildDebugMaterial(color),\n      );\n      sphereMesh.renderOrder = renderOrder;\n      debugMeshRoot.add(sphereMesh);\n      sphereMesh.position.fromArray(position);\n    };\n\n    createMesh(0xff0000, [-50, 0, 0]);\n    createMesh(0xff0000, [50, 0, 0]);\n    createMesh(0x00ff00, [0, 0, -50]);\n    createMesh(0x00ff00, [0, 0, 50]);\n    createMesh(0xffaa00, [5, 0, 5]);\n\n    return debugMeshRoot;\n  }\n\n  createSecondaryDebugMeshes(renderOrder) {\n    const boxGeometry = new THREE.BoxGeometry(3, 3, 3);\n    const debugMeshRoot = new THREE.Object3D();\n\n    let boxColor = 0xbbbbbb;\n    const createMesh = (position) => {\n      let boxMesh = new THREE.Mesh(\n        boxGeometry,\n        SceneHelper.buildDebugMaterial(boxColor),\n      );\n      boxMesh.renderOrder = renderOrder;\n      debugMeshRoot.add(boxMesh);\n      boxMesh.position.fromArray(position);\n    };\n\n    let separation = 10;\n    createMesh([-separation, 0, -separation]);\n    createMesh([-separation, 0, separation]);\n    createMesh([separation, 0, -separation]);\n    createMesh([separation, 0, separation]);\n\n    return debugMeshRoot;\n  }\n\n  static buildDebugMaterial(color) {\n    const vertexShaderSource = `\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        `;\n\n    const fragmentShaderSource = `\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        `;\n\n    const uniforms = {\n      color: {\n        type: 'v3',\n        value: new THREE.Color(color),\n      },\n    };\n\n    const material = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: vertexShaderSource,\n      fragmentShader: fragmentShaderSource,\n      transparent: false,\n      depthTest: true,\n      depthWrite: true,\n      side: THREE.FrontSide,\n    });\n    material.extensions.fragDepth = true;\n\n    return material;\n  }\n\n  static buildFocusMarkerMaterial(color) {\n    const vertexShaderSource = `\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        `;\n\n    const fragmentShaderSource = `\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        `;\n\n    const uniforms = {\n      color: {\n        type: 'v3',\n        value: new THREE.Color(color),\n      },\n      realFocusPosition: {\n        type: 'v3',\n        value: new THREE.Vector3(),\n      },\n      viewport: {\n        type: 'v2',\n        value: new THREE.Vector2(),\n      },\n      opacity: {\n        value: 0.0,\n      },\n    };\n\n    const material = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: vertexShaderSource,\n      fragmentShader: fragmentShaderSource,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false,\n      side: THREE.FrontSide,\n    });\n\n    return material;\n  }\n\n  dispose() {\n    this.destroyMeshCursor();\n    this.destroyFocusMarker();\n    this.destroyDebugMeshes();\n    this.destroyControlPlane();\n    this.destroyRenderTargetCopyObjects();\n    this.destroySplatRendertarget();\n  }\n}\n","export const SceneRevealMode = {\n  Default: 0,\n  Gradual: 1,\n  Instant: 2,\n};\n","export const SplatRenderMode = {\n  ThreeD: 0,\n  TwoD: 1,\n};\n","import { clamp } from '../../../Util';\nimport { UncompressedSplatArray } from '../../UncompressedSplatArray';\nimport * as THREE from 'three';\n\nexport class GLTFParser {\n  constructor() {}\n\n  decodeSplatData(splatCount, splatBuffers, shBuffers) {\n    // cool to determine the spherical harmonics degree based on the length of shBuffers?\n    const shDegree =\n      shBuffers.length === 3 ? 1 : shBuffers.length === 8 ? 2 : 0;\n\n    const splatArray = new UncompressedSplatArray(shDegree);\n\n    for (let row = 0; row < splatCount; row++) {\n      const newSplat = GLTFParser.parseToUncompressedSplat(\n        splatBuffers,\n        row,\n        shBuffers,\n        shDegree,\n      );\n      splatArray.addSplat(newSplat);\n    }\n    return splatArray;\n  }\n\n  static parseToUncompressedSplat = (function() {\n    const tempRotation = new THREE.Quaternion();\n\n    const OFFSET = UncompressedSplatArray.OFFSET;\n\n    const SH_C0 = 0.28209479177387814;\n\n    return function(splatBuffers, row, shBuffers, shDegree) {\n      const newSplat = UncompressedSplatArray.createSplat(0);\n\n      // center\n      const positions = splatBuffers.POSITION;\n\n      const x = positions[row * 3];\n      const y = positions[row * 3 + 1];\n      const z = positions[row * 3 + 2];\n\n      newSplat[OFFSET.X] = x;\n      newSplat[OFFSET.Y] = y;\n      newSplat[OFFSET.Z] = z;\n\n      // scale\n      const scales = splatBuffers.scale;\n\n      const sx = Math.exp(scales[row * 3]);\n      const sy = Math.exp(scales[row * 3 + 1]);\n      const sz = Math.exp(scales[row * 3 + 2]);\n\n      newSplat[OFFSET.SCALE0] = sx;\n      newSplat[OFFSET.SCALE1] = sy;\n      newSplat[OFFSET.SCALE2] = sz;\n\n      // rotation\n      const rotations = splatBuffers.rotation;\n      const rx = rotations[row * 4];\n      const ry = rotations[row * 4 + 1];\n      const rz = rotations[row * 4 + 2];\n      const rw = rotations[row * 4 + 3];\n\n      tempRotation.set(rx, ry, rz, rw);\n      tempRotation.normalize();\n\n      newSplat[OFFSET.ROTATION0] = tempRotation.x;\n      newSplat[OFFSET.ROTATION1] = tempRotation.y;\n      newSplat[OFFSET.ROTATION2] = tempRotation.z;\n      newSplat[OFFSET.ROTATION3] = tempRotation.w;\n\n      // opacity\n      const opacities = splatBuffers.opacity;\n      const sh0 = splatBuffers.sh_band_0;\n\n      const opacity = (1 / (1 + Math.exp(-opacities[row]))) * 255;\n      newSplat[OFFSET.OPACITY] = clamp(Math.floor(opacity), 0, 255);\n\n      // base color aka. sh degree 0\n      const dcx = sh0[row * 3];\n      const dcy = sh0[row * 3 + 1];\n      const dcz = sh0[row * 3 + 2];\n\n      newSplat[OFFSET.FDC0] = (0.5 + SH_C0 * dcx) * 255;\n      newSplat[OFFSET.FDC1] = (0.5 + SH_C0 * dcy) * 255;\n      newSplat[OFFSET.FDC2] = (0.5 + SH_C0 * dcz) * 255;\n\n      newSplat[OFFSET.FDC0] = clamp(Math.floor(newSplat[OFFSET.FDC0]), 0, 255);\n      newSplat[OFFSET.FDC1] = clamp(Math.floor(newSplat[OFFSET.FDC1]), 0, 255);\n      newSplat[OFFSET.FDC2] = clamp(Math.floor(newSplat[OFFSET.FDC2]), 0, 255);\n\n      // first order sh bands\n      if (shDegree >= 1) {\n        for (let i = 0; i < 9; i++) {\n          newSplat[OFFSET[`FRC${i}`]] = shBuffers[row * 3 + i];\n        }\n        // second order sh bands\n        if (shDegree >= 2) {\n          for (let i = 9; i < 24; i++) {\n            newSplat[OFFSET[`FRC${i}`]] = shBuffers[row * 3 + i];\n          }\n        }\n      }\n\n      return newSplat;\n    };\n  })();\n\n  parseToUncompressedSplatArray(splatCount, splatBuffers, shBuffers) {\n    return this.decodeSplatData(splatCount, splatBuffers, shBuffers);\n  }\n}\n","import * as THREE from 'three';\nimport { SplatBuffer } from '../../SplatBuffer';\nimport { GLTFParser } from './GLTFParser.js';\nimport { delayedExecute } from '../../../Util.js';\n\nfunction finalize(splatData, minimumAlpha = 1) {\n  return SplatBuffer.generateFromUncompressedSplatArrays(\n    [splatData],\n    minimumAlpha,\n    0,\n    new THREE.Vector3(),\n  );\n}\n\nfunction getBaseUrl(url) {\n  return url.substring(0, url.lastIndexOf('/') + 1);\n}\n\nfunction getFilePaths(gltf, gltfUrl) {\n  const baseUrl = getBaseUrl(gltfUrl);\n\n  try {\n    const attributes = gltf.meshes[0].primitives[0].attributes;\n    const extensions =\n      gltf.meshes[0].primitives[0].extensions\n        .OPF_mesh_primitive_custom_attributes.attributes;\n\n    const attributeMapping = {\n      POSITION: attributes.POSITION,\n      opacity: extensions.opacity,\n      scale: extensions.scale,\n      rotation: extensions.rotation,\n      // 0th order\n      sh_band_0: extensions.sh_band_0,\n      // 1st order\n      sh_band_1_0: extensions.sh_band_1_triplet_0,\n      sh_band_1_1: extensions.sh_band_1_triplet_1,\n      sh_band_1_2: extensions.sh_band_1_triplet_2,\n      // 2nd order\n      sh_band_2_0: extensions.sh_band_2_triplet_0,\n      sh_band_2_1: extensions.sh_band_2_triplet_1,\n      sh_band_2_2: extensions.sh_band_2_triplet_2,\n      sh_band_2_3: extensions.sh_band_2_triplet_3,\n      sh_band_2_4: extensions.sh_band_2_triplet_4,\n    };\n\n    return Object.fromEntries(\n      Object.entries(attributeMapping).map(([key, index]) => {\n        const bufferIndex =\n          gltf.bufferViews[gltf.accessors[index].bufferView].buffer;\n        return [key, baseUrl + gltf.buffers[bufferIndex].uri];\n      }),\n    );\n  } catch (error) {\n    console.error('Error processing GLTF structure:', error);\n    return {};\n  }\n}\n\nexport class GLTFLoader {\n  /**\n   *\n   * @param {import('../../../Viewer.js').Viewer} viewer\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n  }\n  async loadFromURL(url = 'http://localhost:8081/gaussian/gltf/pcl.gltf') {\n    try {\n      const gltf = await this.fetchGLTF(url);\n      const filePaths = getFilePaths(gltf, url);\n      const splatBuffers = await this.fetchBuffers(filePaths, [\n        'POSITION',\n        'opacity',\n        'scale',\n        'rotation',\n        'sh_band_0',\n      ]);\n      const shBuffers = await this.fetchBuffers(filePaths, [\n        'sh_band_1_0',\n        'sh_band_1_1',\n        'sh_band_1_2',\n        'sh_band_2_0',\n        'sh_band_2_1',\n        'sh_band_2_2',\n        'sh_band_2_3',\n        'sh_band_2_4',\n        // TODO: higher order bands\n      ]);\n      const splatCount = this.getSplatCountFromGLTF(gltf);\n\n      return this.loadFromBufferData(splatCount, splatBuffers, shBuffers);\n    } catch (error) {\n      console.error('Error loading GLTF from URL:', error);\n      return null;\n    }\n  }\n\n  fetch(url) {\n    return this.viewer.fetch(url);\n  }\n\n  async fetchGLTF(url) {\n    try {\n      const response = await this.fetch(url);\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching GLTF:', error);\n      return null;\n    }\n  }\n\n  async fetchBuffers(filePaths, bufferNames) {\n    // const componentTypeMap = {\n    //     5120: Int8Array,\n    //     5121: Uint8Array,\n    //     5122: Int16Array,\n    //     5123: Uint16Array,\n    //     5125: Uint32Array,\n    //     5126: Float32Array\n    // };\n\n    try {\n      const bufferPromises = bufferNames.map(async (name) => {\n        const response = await this.fetch(filePaths[name]);\n        const buffer = await response.arrayBuffer();\n\n        // TODO: check component type rather than assuming float32\n        return { [name]: new Float32Array(buffer) };\n      });\n\n      const bufferData = await Promise.all(bufferPromises);\n      return Object.assign({}, ...bufferData);\n    } catch (error) {\n      console.error('Error fetching buffers:', error);\n      return {};\n    }\n  }\n\n  getSplatCountFromGLTF(gltf) {\n    try {\n      return gltf.accessors[gltf.meshes[0].primitives[0].attributes.POSITION]\n        .count;\n    } catch (error) {\n      console.error('Error determining splat count:', error);\n      return 0;\n    }\n  }\n\n  async loadFromBufferData(splatCount, splatBuffers, shBuffers = []) {\n    return delayedExecute(() =>\n      new GLTFParser().parseToUncompressedSplatArray(\n        splatCount,\n        splatBuffers,\n        shBuffers,\n      ),\n    ).then(finalize);\n  }\n}\n","import * as THREE from 'three';\n\nconst VectorRight = new THREE.Vector3(1, 0, 0);\nconst VectorUp = new THREE.Vector3(0, 1, 0);\nconst VectorBackward = new THREE.Vector3(0, 0, 1);\n\nexport class Ray {\n  constructor(origin = new THREE.Vector3(), direction = new THREE.Vector3()) {\n    this.origin = new THREE.Vector3();\n    this.direction = new THREE.Vector3();\n    this.setParameters(origin, direction);\n  }\n\n  setParameters(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction).normalize();\n  }\n\n  boxContainsPoint(box, point, epsilon) {\n    return point.x < box.min.x - epsilon ||\n      point.x > box.max.x + epsilon ||\n      point.y < box.min.y - epsilon ||\n      point.y > box.max.y + epsilon ||\n      point.z < box.min.z - epsilon ||\n      point.z > box.max.z + epsilon ?\n      false :\n      true;\n  }\n\n  intersectBox = (function() {\n    const planeIntersectionPoint = new THREE.Vector3();\n    const planeIntersectionPointArray = [];\n    const originArray = [];\n    const directionArray = [];\n\n    return function(box, outHit) {\n      originArray[0] = this.origin.x;\n      originArray[1] = this.origin.y;\n      originArray[2] = this.origin.z;\n      directionArray[0] = this.direction.x;\n      directionArray[1] = this.direction.y;\n      directionArray[2] = this.direction.z;\n\n      if (this.boxContainsPoint(box, this.origin, 0.0001)) {\n        if (outHit) {\n          outHit.origin.copy(this.origin);\n          outHit.normal.set(0, 0, 0);\n          outHit.distance = -1;\n        }\n        return true;\n      }\n\n      for (let i = 0; i < 3; i++) {\n        if (directionArray[i] == 0.0) continue;\n\n        const hitNormal =\n          i == 0 ? VectorRight : i == 1 ? VectorUp : VectorBackward;\n        const extremeVec = directionArray[i] < 0 ? box.max : box.min;\n        let multiplier = -Math.sign(directionArray[i]);\n        planeIntersectionPointArray[0] =\n          i == 0 ? extremeVec.x : i == 1 ? extremeVec.y : extremeVec.z;\n        let toSide = planeIntersectionPointArray[0] - originArray[i];\n\n        if (toSide * multiplier < 0) {\n          const idx1 = (i + 1) % 3;\n          const idx2 = (i + 2) % 3;\n          planeIntersectionPointArray[2] =\n            (directionArray[idx1] / directionArray[i]) * toSide +\n            originArray[idx1];\n          planeIntersectionPointArray[1] =\n            (directionArray[idx2] / directionArray[i]) * toSide +\n            originArray[idx2];\n          planeIntersectionPoint.set(\n            planeIntersectionPointArray[i],\n            planeIntersectionPointArray[idx2],\n            planeIntersectionPointArray[idx1],\n          );\n          if (this.boxContainsPoint(box, planeIntersectionPoint, 0.0001)) {\n            if (outHit) {\n              outHit.origin.copy(planeIntersectionPoint);\n              outHit.normal.copy(hitNormal).multiplyScalar(multiplier);\n              outHit.distance = planeIntersectionPoint\n                .sub(this.origin)\n                .length();\n            }\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n  })();\n\n  intersectSphere = (function() {\n    const toSphereCenterVec = new THREE.Vector3();\n\n    return function(center, radius, outHit) {\n      toSphereCenterVec.copy(center).sub(this.origin);\n      const toClosestApproach = toSphereCenterVec.dot(this.direction);\n      const toClosestApproachSq = toClosestApproach * toClosestApproach;\n      const toSphereCenterSq = toSphereCenterVec.dot(toSphereCenterVec);\n      const diffSq = toSphereCenterSq - toClosestApproachSq;\n      const radiusSq = radius * radius;\n\n      if (diffSq > radiusSq) return false;\n\n      const thc = Math.sqrt(radiusSq - diffSq);\n      const t0 = toClosestApproach - thc;\n      const t1 = toClosestApproach + thc;\n\n      if (t1 < 0) return false;\n      let t = t0 < 0 ? t1 : t0;\n\n      if (outHit) {\n        outHit.origin.copy(this.origin).addScaledVector(this.direction, t);\n        outHit.normal.copy(outHit.origin).sub(center).normalize();\n        outHit.distance = t;\n      }\n      return true;\n    };\n  })();\n}\n","import * as THREE from 'three';\n\nexport class Hit {\n  constructor() {\n    this.origin = new THREE.Vector3();\n    this.normal = new THREE.Vector3();\n    this.distance = 0;\n    this.splatIndex = 0;\n  }\n\n  set(origin, normal, distance, splatIndex) {\n    this.origin.copy(origin);\n    this.normal.copy(normal);\n    this.distance = distance;\n    this.splatIndex = splatIndex;\n  }\n\n  clone() {\n    const hitClone = new Hit();\n    hitClone.origin.copy(this.origin);\n    hitClone.normal.copy(this.normal);\n    hitClone.distance = this.distance;\n    hitClone.splatIndex = this.splatIndex;\n    return hitClone;\n  }\n}\n","import * as THREE from 'three';\nimport { Ray } from './Ray.js';\nimport { Hit } from './Hit.js';\nimport { SplatRenderMode } from '../SplatRenderMode.js';\n\nexport class Raycaster {\n  constructor(origin, direction, raycastAgainstTrueSplatEllipsoid = false) {\n    this.ray = new Ray(origin, direction);\n    this.raycastAgainstTrueSplatEllipsoid = raycastAgainstTrueSplatEllipsoid;\n  }\n\n  setFromCameraAndScreenPosition = (function() {\n    const ndcCoords = new THREE.Vector2();\n\n    return function(camera, screenPosition, screenDimensions) {\n      ndcCoords.x = (screenPosition.x / screenDimensions.x) * 2.0 - 1.0;\n      ndcCoords.y =\n        ((screenDimensions.y - screenPosition.y) / screenDimensions.y) * 2.0 -\n        1.0;\n      if (camera.isPerspectiveCamera) {\n        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n        this.ray.direction\n          .set(ndcCoords.x, ndcCoords.y, 0.5)\n          .unproject(camera)\n          .sub(this.ray.origin)\n          .normalize();\n        this.camera = camera;\n      } else if (camera.isOrthographicCamera) {\n        this.ray.origin\n          .set(\n            ndcCoords.x,\n            ndcCoords.y,\n            (camera.near + camera.far) / (camera.near - camera.far),\n          )\n          .unproject(camera);\n        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n        this.camera = camera;\n      } else {\n        throw new Error(\n          'Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type',\n        );\n      }\n    };\n  })();\n\n  intersectSplatMesh = (function() {\n    const toLocal = new THREE.Matrix4();\n    const fromLocal = new THREE.Matrix4();\n    const sceneTransform = new THREE.Matrix4();\n    const localRay = new Ray();\n    const tempPoint = new THREE.Vector3();\n\n    return function(splatMesh, outHits = []) {\n      const splatTree = splatMesh.getSplatTree();\n\n      if (!splatTree) return;\n\n      for (let s = 0; s < splatTree.subTrees.length; s++) {\n        const subTree = splatTree.subTrees[s];\n\n        fromLocal.copy(splatMesh.matrixWorld);\n        if (splatMesh.dynamicMode) {\n          splatMesh.getSceneTransform(s, sceneTransform);\n          fromLocal.multiply(sceneTransform);\n        }\n        toLocal.copy(fromLocal).invert();\n\n        localRay.origin.copy(this.ray.origin).applyMatrix4(toLocal);\n        localRay.direction.copy(this.ray.origin).add(this.ray.direction);\n        localRay.direction\n          .applyMatrix4(toLocal)\n          .sub(localRay.origin)\n          .normalize();\n\n        const outHitsForSubTree = [];\n        if (subTree.rootNode) {\n          this.castRayAtSplatTreeNode(\n            localRay,\n            splatTree,\n            subTree.rootNode,\n            outHitsForSubTree,\n          );\n        }\n\n        outHitsForSubTree.forEach((hit) => {\n          hit.origin.applyMatrix4(fromLocal);\n          hit.normal.applyMatrix4(fromLocal).normalize();\n          hit.distance = tempPoint\n            .copy(hit.origin)\n            .sub(this.ray.origin)\n            .length();\n        });\n\n        outHits.push(...outHitsForSubTree);\n      }\n\n      outHits.sort((a, b) => {\n        if (a.distance > b.distance) return 1;\n        else return -1;\n      });\n\n      return outHits;\n    };\n  })();\n\n  castRayAtSplatTreeNode = (function() {\n    const tempColor = new THREE.Vector4();\n    const tempCenter = new THREE.Vector3();\n    const tempScale = new THREE.Vector3();\n    const tempRotation = new THREE.Quaternion();\n    const tempHit = new Hit();\n    const scaleEpsilon = 0.0000001;\n\n    const origin = new THREE.Vector3(0, 0, 0);\n    const uniformScaleMatrix = new THREE.Matrix4();\n    const scaleMatrix = new THREE.Matrix4();\n    const rotationMatrix = new THREE.Matrix4();\n    const toSphereSpace = new THREE.Matrix4();\n    const fromSphereSpace = new THREE.Matrix4();\n    const tempRay = new Ray();\n\n    return function(ray, splatTree, node, outHits = []) {\n      if (!ray.intersectBox(node.boundingBox)) {\n        return;\n      }\n      if (node.data && node.data.indexes && node.data.indexes.length > 0) {\n        for (let i = 0; i < node.data.indexes.length; i++) {\n          const splatGlobalIndex = node.data.indexes[i];\n          const splatSceneIndex =\n            splatTree.splatMesh.getSceneIndexForSplat(splatGlobalIndex);\n          const splatScene = splatTree.splatMesh.getScene(splatSceneIndex);\n          if (!splatScene.visible) continue;\n\n          splatTree.splatMesh.getSplatColor(splatGlobalIndex, tempColor);\n          splatTree.splatMesh.getSplatCenter(splatGlobalIndex, tempCenter);\n          splatTree.splatMesh.getSplatScaleAndRotation(\n            splatGlobalIndex,\n            tempScale,\n            tempRotation,\n          );\n\n          if (\n            tempScale.x <= scaleEpsilon ||\n            tempScale.y <= scaleEpsilon ||\n            (splatTree.splatMesh.splatRenderMode === SplatRenderMode.ThreeD &&\n              tempScale.z <= scaleEpsilon)\n          ) {\n            continue;\n          }\n\n          if (!this.raycastAgainstTrueSplatEllipsoid) {\n            let radius = tempScale.x + tempScale.y;\n            let componentCount = 2;\n            if (\n              splatTree.splatMesh.splatRenderMode === SplatRenderMode.ThreeD\n            ) {\n              radius += tempScale.z;\n              componentCount = 3;\n            }\n            radius = radius / componentCount;\n            if (ray.intersectSphere(tempCenter, radius, tempHit)) {\n              const hitClone = tempHit.clone();\n              hitClone.splatIndex = splatGlobalIndex;\n              outHits.push(hitClone);\n            }\n          } else {\n            scaleMatrix.makeScale(tempScale.x, tempScale.y, tempScale.z);\n            rotationMatrix.makeRotationFromQuaternion(tempRotation);\n            const uniformScale = Math.log10(tempColor.w) * 2.0;\n            uniformScaleMatrix.makeScale(\n              uniformScale,\n              uniformScale,\n              uniformScale,\n            );\n            fromSphereSpace\n              .copy(uniformScaleMatrix)\n              .multiply(rotationMatrix)\n              .multiply(scaleMatrix);\n            toSphereSpace.copy(fromSphereSpace).invert();\n            tempRay.origin\n              .copy(ray.origin)\n              .sub(tempCenter)\n              .applyMatrix4(toSphereSpace);\n            tempRay.direction\n              .copy(ray.origin)\n              .add(ray.direction)\n              .sub(tempCenter);\n            tempRay.direction\n              .applyMatrix4(toSphereSpace)\n              .sub(tempRay.origin)\n              .normalize();\n            if (tempRay.intersectSphere(origin, 1.0, tempHit)) {\n              const hitClone = tempHit.clone();\n              hitClone.splatIndex = splatGlobalIndex;\n              hitClone.origin.applyMatrix4(fromSphereSpace).add(tempCenter);\n              outHits.push(hitClone);\n            }\n          }\n        }\n      }\n      if (node.children && node.children.length > 0) {\n        for (let child of node.children) {\n          this.castRayAtSplatTreeNode(ray, splatTree, child, outHits);\n        }\n      }\n      return outHits;\n    };\n  })();\n}\n","import * as THREE from 'three';\nimport { Constants } from '../Constants.js';\n\nexport class SplatMaterial {\n  static buildVertexShaderBase(\n    dynamicMode = false,\n    enableOptionalEffects = false,\n    maxSphericalHarmonicsDegree = 0,\n    customVars = '',\n  ) {\n    let vertexShaderSource = `\n        precision highp float;\n        #include <common>\n\n        attribute uint splatIndex;\n        uniform highp usampler2D centersColorsTexture;\n        uniform highp sampler2D sphericalHarmonicsTexture;\n        uniform highp sampler2D sphericalHarmonicsTextureR;\n        uniform highp sampler2D sphericalHarmonicsTextureG;\n        uniform highp sampler2D sphericalHarmonicsTextureB;\n\n        uniform highp usampler2D sceneIndexesTexture;\n        uniform vec2 sceneIndexesTextureSize;\n        uniform int sceneCount;\n    `;\n\n    if (enableOptionalEffects) {\n      vertexShaderSource += `\n            uniform float sceneOpacity[${Constants.MaxScenes}];\n            uniform int sceneVisibility[${Constants.MaxScenes}];\n        `;\n    }\n\n    if (dynamicMode) {\n      vertexShaderSource += `\n            uniform highp mat4 transforms[${Constants.MaxScenes}];\n        `;\n    }\n\n    vertexShaderSource += `\n        ${customVars}\n        uniform vec2 focal;\n        uniform float orthoZoom;\n        uniform int orthographicMode;\n        uniform int pointCloudModeEnabled;\n        uniform float inverseFocalAdjustment;\n        uniform vec2 viewport;\n        uniform vec2 basisViewport;\n        uniform vec2 centersColorsTextureSize;\n        uniform int sphericalHarmonicsDegree;\n        uniform vec2 sphericalHarmonicsTextureSize;\n        uniform int sphericalHarmonics8BitMode;\n        uniform int sphericalHarmonicsMultiTextureMode;\n        uniform float visibleRegionRadius;\n        uniform float visibleRegionFadeStartRadius;\n        uniform float firstRenderTime;\n        uniform float currentTime;\n        uniform int fadeInComplete;\n        uniform vec3 sceneCenter;\n        uniform float splatScale;\n        uniform float sphericalHarmonics8BitCompressionRangeMin[${Constants.MaxScenes}];\n        uniform float sphericalHarmonics8BitCompressionRangeMax[${Constants.MaxScenes}];\n\n        varying vec4 vColor;\n        varying vec2 vUv;\n        varying vec2 vPosition;\n        varying float vZ;\n        varying float vSplatIndex;\n        varying vec4 vVertex;\n\n        mat3 quaternionToRotationMatrix(float x, float y, float z, float w) {\n            float s = 1.0 / sqrt(w * w + x * x + y * y + z * z);\n        \n            return mat3(\n                1. - 2. * (y * y + z * z),\n                2. * (x * y + w * z),\n                2. * (x * z - w * y),\n                2. * (x * y - w * z),\n                1. - 2. * (x * x + z * z),\n                2. * (y * z + w * x),\n                2. * (x * z + w * y),\n                2. * (y * z - w * x),\n                1. - 2. * (x * x + y * y)\n            );\n        }\n\n        const float sqrt8 = sqrt(8.0);\n        const float minAlpha = 1.0 / 255.0;\n\n        const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n        const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n        const uvec4 shift4 = uvec4(0, 8, 16, 24);\n        vec4 uintToRGBAVec (uint u) {\n           uvec4 urgba = mask4 & u;\n           urgba = urgba >> shift4;\n           vec4 rgba = vec4(urgba) * encodeNorm4;\n           return rgba;\n        }\n\n        vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {\n            vec2 samplerUV = vec2(0.0, 0.0);\n            float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;\n            samplerUV.y = float(floor(d)) / dimensions.y;\n            samplerUV.x = fract(d);\n            return samplerUV;\n        }\n\n        const float SH_C1 = 0.4886025119029199f;\n        const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);\n\n        void main () {\n\n            vSplatIndex = float(splatIndex);\n\n            uint oddOffset = splatIndex & uint(0x00000001);\n            uint doubleOddOffset = oddOffset * uint(2);\n            bool isEven = oddOffset == uint(0);\n            uint nearestEvenIndex = splatIndex - oddOffset;\n            float fOddOffset = float(oddOffset);\n\n            uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n            vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n\n            uint sceneIndex = uint(0);\n            if (sceneCount > 1) {\n                sceneIndex = texture(sceneIndexesTexture, getDataUV(1, 0, sceneIndexesTextureSize)).r;\n            }\n            `;\n\n    if (enableOptionalEffects) {\n      vertexShaderSource += `\n                float splatOpacityFromScene = sceneOpacity[sceneIndex];\n                int sceneVisible = sceneVisibility[sceneIndex];\n                if (splatOpacityFromScene <= 0.01 || sceneVisible == 0) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n            `;\n    }\n\n    if (dynamicMode) {\n      vertexShaderSource += `\n                mat4 transform = transforms[sceneIndex];\n                mat4 transformModelViewMatrix = modelViewMatrix * transform;\n            `;\n    } else {\n      vertexShaderSource += `mat4 transformModelViewMatrix = modelViewMatrix;`;\n    }\n\n    vertexShaderSource += `\n            float sh8BitCompressionRangeMinForScene = sphericalHarmonics8BitCompressionRangeMin[sceneIndex];\n            float sh8BitCompressionRangeMaxForScene = sphericalHarmonics8BitCompressionRangeMax[sceneIndex];\n            float sh8BitCompressionRangeForScene = sh8BitCompressionRangeMaxForScene - sh8BitCompressionRangeMinForScene;\n            float sh8BitCompressionHalfRangeForScene = sh8BitCompressionRangeForScene / 2.0;\n            vec3 vec8BitSHShift = vec3(sh8BitCompressionRangeMinForScene);\n\n            vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);\n\n            vec4 clipCenter = projectionMatrix * viewCenter;\n\n            float clip = 1.2 * clipCenter.w;\n            if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                return;\n            }\n\n            vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n            vPosition = position.xy;\n            vColor = uintToRGBAVec(sampledCenterColor.r);\n        `;\n\n    // Proceed to sampling and rendering 1st degree spherical harmonics\n    if (maxSphericalHarmonicsDegree >= 1) {\n      vertexShaderSource += `   \n            if (sphericalHarmonicsDegree >= 1) {\n            `;\n\n      if (dynamicMode) {\n        vertexShaderSource += `\n                    vec3 worldViewDir = normalize(splatCenter - vec3(inverse(transform) * vec4(cameraPosition, 1.0)));\n                `;\n      } else {\n        vertexShaderSource += `\n                    vec3 worldViewDir = normalize(splatCenter - cameraPosition);\n                `;\n      }\n\n      vertexShaderSource += `\n                vec3 sh1;\n                vec3 sh2;\n                vec3 sh3;\n            `;\n\n      if (maxSphericalHarmonicsDegree >= 2) {\n        vertexShaderSource += `\n                    vec3 sh4;\n                    vec3 sh5;\n                    vec3 sh6;\n                    vec3 sh7;\n                    vec3 sh8;\n                `;\n      }\n\n      // Determining how to sample spherical harmonics textures to get the coefficients for calculations for a given degree\n      // depends on how many total degrees (maxSphericalHarmonicsDegree) are present in the textures. This is because that\n      // number affects how they are packed in the textures, and therefore the offset & stride required to access them.\n\n      // Sample spherical harmonics textures with 1 degree worth of data for 1st degree calculations, and store in sh1, sh2, and sh3\n      if (maxSphericalHarmonicsDegree === 1) {\n        vertexShaderSource += `\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);\n                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);\n                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);\n                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);\n                        sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;\n                    } else {\n                        vec2 sampledSH01R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH01B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize)).rg;\n                        vec2 sampledSH23B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize)).rg;\n                        sh1 = vec3(sampledSH01R.rg, sampledSH23R.r);\n                        sh2 = vec3(sampledSH01G.rg, sampledSH23G.r);\n                        sh3 = vec3(sampledSH01B.rg, sampledSH23B.r);\n                    }\n                `;\n        // Sample spherical harmonics textures with 2 degrees worth of data for 1st degree calculations, and store in sh1, sh2, and sh3\n      } else if (maxSphericalHarmonicsDegree === 2) {\n        vertexShaderSource += `\n                    vec4 sampledSH0123;\n                    vec4 sampledSH4567;\n                    vec4 sampledSH891011;\n\n                    vec4 sampledSH0123R;\n                    vec4 sampledSH0123G;\n                    vec4 sampledSH0123B;\n\n                    if (sphericalHarmonicsMultiTextureMode == 0) {\n                        sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));\n                        sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));\n                        sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));\n                        sh1 = sampledSH0123.rgb;\n                        sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);\n                        sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);\n                    } else {\n                        sampledSH0123R = texture(sphericalHarmonicsTextureR, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123G = texture(sphericalHarmonicsTextureG, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sampledSH0123B = texture(sphericalHarmonicsTextureB, getDataUV(2, 0, sphericalHarmonicsTextureSize));\n                        sh1 = vec3(sampledSH0123R.rgb);\n                        sh2 = vec3(sampledSH0123G.rgb);\n                        sh3 = vec3(sampledSH0123B.rgb);\n                    }\n                `;\n      }\n\n      // Perform 1st degree spherical harmonics calculations\n      vertexShaderSource += `\n                    if (sphericalHarmonics8BitMode == 1) {\n                        sh1 = sh1 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh2 = sh2 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        sh3 = sh3 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                    }\n                    float x = worldViewDir.x;\n                    float y = worldViewDir.y;\n                    float z = worldViewDir.z;\n                    vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);\n            `;\n\n      // Proceed to sampling and rendering 2nd degree spherical harmonics\n      if (maxSphericalHarmonicsDegree >= 2) {\n        vertexShaderSource += `\n                    if (sphericalHarmonicsDegree >= 2) {\n                        float xx = x * x;\n                        float yy = y * y;\n                        float zz = z * z;\n                        float xy = x * y;\n                        float yz = y * z;\n                        float xz = x * z;\n                `;\n\n        // Sample spherical harmonics textures with 2 degrees worth of data for 2nd degree calculations,\n        // and store in sh4, sh5, sh6, sh7, and sh8\n        if (maxSphericalHarmonicsDegree === 2) {\n          vertexShaderSource += `\n                        if (sphericalHarmonicsMultiTextureMode == 0) {\n                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));\n                            sh4 = sampledSH891011.gba;\n                            sh5 = sampledSH12131415.rgb;\n                            sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);\n                            sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);\n                            sh8 = sampledSH20212223.gba;\n                        } else {\n                            vec4 sampledSH4567R = texture(sphericalHarmonicsTextureR, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567G = texture(sphericalHarmonicsTextureG, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            vec4 sampledSH4567B = texture(sphericalHarmonicsTextureB, getDataUV(2, 1, sphericalHarmonicsTextureSize));\n                            sh4 = vec3(sampledSH0123R.a, sampledSH4567R.rg);\n                            sh5 = vec3(sampledSH4567R.ba, sampledSH0123G.a);\n                            sh6 = vec3(sampledSH4567G.rgb);\n                            sh7 = vec3(sampledSH4567G.a, sampledSH0123B.a, sampledSH4567B.r);\n                            sh8 = vec3(sampledSH4567B.gba);\n                        }\n                    `;\n        }\n\n        // Perform 2nd degree spherical harmonics calculations\n        vertexShaderSource += `\n                        if (sphericalHarmonics8BitMode == 1) {\n                            sh4 = sh4 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh5 = sh5 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh6 = sh6 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh7 = sh7 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                            sh8 = sh8 * sh8BitCompressionRangeForScene + vec8BitSHShift;\n                        }\n\n                        vColor.rgb +=\n                            (SH_C2[0] * xy) * sh4 +\n                            (SH_C2[1] * yz) * sh5 +\n                            (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +\n                            (SH_C2[3] * xz) * sh7 +\n                            (SH_C2[4] * (xx - yy)) * sh8;\n                    }\n                `;\n      }\n\n      vertexShaderSource += `\n\n                vColor.rgb = clamp(vColor.rgb, vec3(0.), vec3(1.));\n            }\n\n            `;\n    }\n\n    return vertexShaderSource;\n  }\n\n  static getVertexShaderFadeIn() {\n    return `\n            if (fadeInComplete == 0) {\n                float opacityAdjust = 1.0;\n                float centerDist = length(splatCenter - sceneCenter);\n                float renderTime = max(currentTime - firstRenderTime, 0.0);\n\n                float fadeDistance = 0.75;\n                float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);\n                distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +\n                                        (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *\n                                        distanceLoadFadeInFactor;\n                opacityAdjust *= distanceLoadFadeInFactor;\n                vColor.a *= opacityAdjust;\n            }\n        `;\n  }\n\n  static getUniforms(\n    dynamicMode = false,\n    enableOptionalEffects = false,\n    maxSphericalHarmonicsDegree = 0,\n    splatScale = 1.0,\n    pointCloudModeEnabled = false,\n  ) {\n    const uniforms = {\n      sceneCenter: {\n        type: 'v3',\n        value: new THREE.Vector3(),\n      },\n      fadeInComplete: {\n        type: 'i',\n        value: 0,\n      },\n      orthographicMode: {\n        type: 'i',\n        value: 0,\n      },\n      visibleRegionFadeStartRadius: {\n        type: 'f',\n        value: 0.0,\n      },\n      visibleRegionRadius: {\n        type: 'f',\n        value: 0.0,\n      },\n      currentTime: {\n        type: 'f',\n        value: 0.0,\n      },\n      firstRenderTime: {\n        type: 'f',\n        value: 0.0,\n      },\n      centersColorsTexture: {\n        type: 't',\n        value: null,\n      },\n      sphericalHarmonicsTexture: {\n        type: 't',\n        value: null,\n      },\n      sphericalHarmonicsTextureR: {\n        type: 't',\n        value: null,\n      },\n      sphericalHarmonicsTextureG: {\n        type: 't',\n        value: null,\n      },\n      sphericalHarmonicsTextureB: {\n        type: 't',\n        value: null,\n      },\n      sphericalHarmonics8BitCompressionRangeMin: {\n        type: 'f',\n        value: [],\n      },\n      sphericalHarmonics8BitCompressionRangeMax: {\n        type: 'f',\n        value: [],\n      },\n      focal: {\n        type: 'v2',\n        value: new THREE.Vector2(),\n      },\n      orthoZoom: {\n        type: 'f',\n        value: 1.0,\n      },\n      inverseFocalAdjustment: {\n        type: 'f',\n        value: 1.0,\n      },\n      viewport: {\n        type: 'v2',\n        value: new THREE.Vector2(),\n      },\n      basisViewport: {\n        type: 'v2',\n        value: new THREE.Vector2(),\n      },\n      debugColor: {\n        type: 'v3',\n        value: new THREE.Color(),\n      },\n      centersColorsTextureSize: {\n        type: 'v2',\n        value: new THREE.Vector2(1024, 1024),\n      },\n      sphericalHarmonicsDegree: {\n        type: 'i',\n        value: maxSphericalHarmonicsDegree,\n      },\n      sphericalHarmonicsTextureSize: {\n        type: 'v2',\n        value: new THREE.Vector2(1024, 1024),\n      },\n      sphericalHarmonics8BitMode: {\n        type: 'i',\n        value: 0,\n      },\n      sphericalHarmonicsMultiTextureMode: {\n        type: 'i',\n        value: 0,\n      },\n      splatScale: {\n        type: 'f',\n        value: splatScale,\n      },\n      pointCloudModeEnabled: {\n        type: 'i',\n        value: pointCloudModeEnabled ? 1 : 0,\n      },\n      sceneIndexesTexture: {\n        type: 't',\n        value: null,\n      },\n      sceneIndexesTextureSize: {\n        type: 'v2',\n        value: new THREE.Vector2(1024, 1024),\n      },\n      sceneCount: {\n        type: 'i',\n        value: 1,\n      },\n    };\n    for (let i = 0; i < Constants.MaxScenes; i++) {\n      uniforms.sphericalHarmonics8BitCompressionRangeMin.value.push(\n        -Constants.SphericalHarmonics8BitCompressionRange / 2.0,\n      );\n      uniforms.sphericalHarmonics8BitCompressionRangeMax.value.push(\n        Constants.SphericalHarmonics8BitCompressionRange / 2.0,\n      );\n    }\n\n    if (enableOptionalEffects) {\n      const sceneOpacity = [];\n      for (let i = 0; i < Constants.MaxScenes; i++) {\n        sceneOpacity.push(1.0);\n      }\n      uniforms['sceneOpacity'] = {\n        type: 'f',\n        value: sceneOpacity,\n      };\n\n      const sceneVisibility = [];\n      for (let i = 0; i < Constants.MaxScenes; i++) {\n        sceneVisibility.push(1);\n      }\n      uniforms['sceneVisibility'] = {\n        type: 'i',\n        value: sceneVisibility,\n      };\n    }\n\n    if (dynamicMode) {\n      const transformMatrices = [];\n      for (let i = 0; i < Constants.MaxScenes; i++) {\n        transformMatrices.push(new THREE.Matrix4());\n      }\n      uniforms['transforms'] = {\n        type: 'mat4',\n        value: transformMatrices,\n      };\n    }\n\n    return uniforms;\n  }\n}\n","import * as THREE from 'three';\nimport { SplatMaterial } from './SplatMaterial.js';\n\nexport class SplatMaterial3D {\n  /**\n   * Build the Three.js material that is used to render the splats.\n   * @param {number} dynamicMode If true, it means the scene geometry represented by this splat mesh is not stationary or\n   *                             that the splat count might change\n   * @param {boolean} enableOptionalEffects When true, allows for usage of extra properties and attributes in the shader for effects\n   *                                        such as opacity adjustment. Default is false for performance reasons.\n   * @param {boolean} antialiased If true, calculate compensation factor to deal with gaussians being rendered at a significantly\n   *                              different resolution than that of their training\n   * @param {number} maxScreenSpaceSplatSize The maximum clip space splat size\n   * @param {number} splatScale Value by which all splats are scaled in screen-space (default is 1.0)\n   * @param {number} pointCloudModeEnabled Render all splats as screen-space circles\n   * @param {number} maxSphericalHarmonicsDegree Degree of spherical harmonics to utilize in rendering splats\n   * @return {THREE.ShaderMaterial}\n   */\n  static build(\n    dynamicMode = false,\n    enableOptionalEffects = false,\n    antialiased = false,\n    maxScreenSpaceSplatSize = 2048,\n    splatScale = 1.0,\n    pointCloudModeEnabled = false,\n    maxSphericalHarmonicsDegree = 0,\n  ) {\n    const customVertexVars = `\n            uniform vec2 covariancesTextureSize;\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D covariancesTextureHalfFloat;\n            uniform int covariancesAreHalfFloat;\n\n            void fromCovarianceHalfFloatV4(uvec4 val, out vec4 first, out vec4 second) {\n                vec2 r = unpackHalf2x16(val.r);\n                vec2 g = unpackHalf2x16(val.g);\n                vec2 b = unpackHalf2x16(val.b);\n\n                first = vec4(r.x, r.y, g.x, g.y);\n                second = vec4(b.x, b.y, 0.0, 0.0);\n            }\n        `;\n\n    let vertexShaderSource = SplatMaterial.buildVertexShaderBase(\n      dynamicMode,\n      enableOptionalEffects,\n      maxSphericalHarmonicsDegree,\n      customVertexVars,\n    );\n    vertexShaderSource += SplatMaterial3D.buildVertexShaderProjection(\n      antialiased,\n      enableOptionalEffects,\n      maxScreenSpaceSplatSize,\n    );\n    const fragmentShaderSource = SplatMaterial3D.buildFragmentShader();\n\n    const uniforms = SplatMaterial.getUniforms(\n      dynamicMode,\n      enableOptionalEffects,\n      maxSphericalHarmonicsDegree,\n      splatScale,\n      pointCloudModeEnabled,\n    );\n\n    uniforms['covariancesTextureSize'] = {\n      type: 'v2',\n      value: new THREE.Vector2(1024, 1024),\n    };\n    uniforms['covariancesTexture'] = {\n      type: 't',\n      value: null,\n    };\n    uniforms['covariancesTextureHalfFloat'] = {\n      type: 't',\n      value: null,\n    };\n    uniforms['covariancesAreHalfFloat'] = {\n      type: 'i',\n      value: 0,\n    };\n\n    uniforms[\"uSetID\"] = {\n      type: \"f\",\n      value: 0\n    }\n\n    const material = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: vertexShaderSource,\n      fragmentShader: fragmentShaderSource,\n      transparent: true,\n      alphaTest: 1.0,\n      blending: THREE.NormalBlending,\n      depthTest: true,\n      depthWrite: false,\n      side: THREE.DoubleSide,\n    });\n\n    return material;\n  }\n\n  static buildVertexShaderProjection(\n    antialiased,\n    enableOptionalEffects,\n    maxScreenSpaceSplatSize,\n  ) {\n    let vertexShaderSource = `\n\n            vec4 sampledCovarianceA;\n            vec4 sampledCovarianceB;\n            vec3 cov3D_M11_M12_M13;\n            vec3 cov3D_M22_M23_M33;\n            if (covariancesAreHalfFloat == 0) {\n                sampledCovarianceA = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset,\n                                                                            covariancesTextureSize));\n                sampledCovarianceB = texture(covariancesTexture, getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1),\n                                                                            covariancesTextureSize));\n\n                cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +\n                                    vec3(sampledCovarianceB.gba) * fOddOffset;\n            } else {\n                uvec4 sampledCovarianceU = texture(covariancesTextureHalfFloat, getDataUV(1, 0, covariancesTextureSize));\n                fromCovarianceHalfFloatV4(sampledCovarianceU, sampledCovarianceA, sampledCovarianceB);\n                cov3D_M11_M12_M13 = sampledCovarianceA.rgb;\n                cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg);\n            }\n        \n            // Construct the 3D covariance matrix\n            mat3 Vrk = mat3(\n                cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n            );\n\n            mat3 J;\n            if (orthographicMode == 1) {\n                // Since the projection is linear, we don't need an approximation\n                J = transpose(mat3(orthoZoom, 0.0, 0.0,\n                                0.0, orthoZoom, 0.0,\n                                0.0, 0.0, 0.0));\n            } else {\n                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the\n                // 3D covariance matrix instead of using the actual projection matrix because that transformation would\n                // require a non-linear component (perspective division) which would yield a non-gaussian result.\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n            }\n\n            // Concatenate the projection approximation with the model-view transformation\n            mat3 W = transpose(mat3(transformModelViewMatrix));\n            mat3 T = W * J;\n\n            // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix\n            mat3 cov2Dm = transpose(T) * Vrk * T;\n            `;\n\n    if (antialiased) {\n      vertexShaderSource += `\n                float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n                float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];\n                vColor.a *= sqrt(max(detOrig / detBlur, 0.0));\n                if (vColor.a < minAlpha) return;\n            `;\n    } else {\n      vertexShaderSource += `\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n            `;\n    }\n\n    vertexShaderSource += `\n\n            // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n            // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n            // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n            // need cov2Dm[1][0] because it is a symetric matrix.\n            vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n            // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n            // so that we can determine the 2D basis for the splat. This is done using the method described\n            // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n            // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat\n            // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * sqrt(eigen-value)), which is\n            // equal to scaling them by sqrt(8) standard deviations.\n            //\n            // This is a different approach than in the original work at INRIA. In that work they compute the\n            // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle\n            // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0\n            // times the square root of the maximum eigen-value, or 3 standard deviations. They then use the inverse\n            // 2D covariance matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by\n            // calculating the full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity\n            float a = cov2Dv.x;\n            float d = cov2Dv.z;\n            float b = cov2Dv.y;\n            float D = a * d - b * b;\n            float trace = a + d;\n            float traceOver2 = 0.5 * trace;\n            float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\n            float eigenValue1 = traceOver2 + term2;\n            float eigenValue2 = traceOver2 - term2;\n\n            if (pointCloudModeEnabled == 1) {\n                eigenValue1 = eigenValue2 = 0.2;\n            }\n\n            if (eigenValue2 <= 0.0) return;\n\n            vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n            // since the eigen vectors are orthogonal, we derive the second one from the first\n            vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n\n            // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\n            vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(\n              maxScreenSpaceSplatSize,\n            )}.0);\n            vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(\n              maxScreenSpaceSplatSize,\n            )}.0);\n            `;\n\n    if (enableOptionalEffects) {\n      vertexShaderSource += `\n                vColor.a *= splatOpacityFromScene;\n            `;\n    }\n\n    vertexShaderSource += `\n            vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *\n                             basisViewport * 2.0 * inverseFocalAdjustment;\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            vZ = ndcCenter.z;\n            gl_Position = quadPos;\n            vVertex = gl_Position;\n\n            // Scale the position data we send to the fragment shader\n            vPosition *= sqrt8;\n        `;\n\n    vertexShaderSource += SplatMaterial.getVertexShaderFadeIn();\n    vertexShaderSource += `}`;\n\n    return vertexShaderSource;\n  }\n\n  static buildFragmentShader() {\n    let fragmentShaderSource = `\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n            uniform float uSetID;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n            varying float vZ;\n            varying float vSplatIndex;\n            varying vec4 vVertex;\n        `;\n\n    fragmentShaderSource += `\n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n                if (A > 8.0) discard;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp(-0.5 * A) * vColor.a;\n\n                vec3 color = vColor.rgb;\n\n                if(uSetID > 0.5) {\n                  \n                  if(opacity < 0.2) discard;\n\n                  vec2 screenData = vVertex.xy / vVertex.w;\n                  screenData = 0.5 * screenData + 0.5;\n\n                  float index = float(vSplatIndex);\n\n                  /*\n                    if(screenData.y < 0.5) {\n                      if(screenData.x < 0.5) {\n                        index = 7.;\n                      } else {\n                        index = 10903.;\n                      }\n                    } else {\n                      if(screenData.x < 0.5) {\n                        index = 1485903.;\n                      } else {\n                        index = 15892345.;\n                      }\n                    }\n                \n                    index /= pow(256., 3.);\n\n                    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * index;\n                    enc = fract(enc);\n                    enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n                  */\n\n                  gl_FragColor = vec4(index, 0., 0., 1.);\n                  return;\n\n                }\n\n                gl_FragColor = vec4(color, opacity);\n            }\n        `;\n\n    return fragmentShaderSource;\n  }\n}\n","import * as THREE from 'three';\nimport { SplatMaterial } from './SplatMaterial.js';\n\nexport class SplatMaterial2D {\n  /**\n   * Build the Three.js material that is used to render the splats.\n   * @param {number} dynamicMode If true, it means the scene geometry represented by this splat mesh is not stationary or\n   *                             that the splat count might change\n   * @param {boolean} enableOptionalEffects When true, allows for usage of extra properties and attributes in the shader for effects\n   *                                        such as opacity adjustment. Default is false for performance reasons.\n   * @param {number} splatScale Value by which all splats are scaled in screen-space (default is 1.0)\n   * @param {number} pointCloudModeEnabled Render all splats as screen-space circles\n   * @param {number} maxSphericalHarmonicsDegree Degree of spherical harmonics to utilize in rendering splats\n   * @return {THREE.ShaderMaterial}\n   */\n  static build(\n    dynamicMode = false,\n    enableOptionalEffects = false,\n    splatScale = 1.0,\n    pointCloudModeEnabled = false,\n    maxSphericalHarmonicsDegree = 0,\n  ) {\n    const customVertexVars = `\n            uniform vec2 scaleRotationsTextureSize;\n            uniform highp sampler2D scaleRotationsTexture;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n        `;\n\n    let vertexShaderSource = SplatMaterial.buildVertexShaderBase(\n      dynamicMode,\n      enableOptionalEffects,\n      maxSphericalHarmonicsDegree,\n      customVertexVars,\n    );\n    vertexShaderSource += SplatMaterial2D.buildVertexShaderProjection();\n    const fragmentShaderSource = SplatMaterial2D.buildFragmentShader();\n\n    const uniforms = SplatMaterial.getUniforms(\n      dynamicMode,\n      enableOptionalEffects,\n      maxSphericalHarmonicsDegree,\n      splatScale,\n      pointCloudModeEnabled,\n    );\n\n    uniforms['scaleRotationsTexture'] = {\n      type: 't',\n      value: null,\n    };\n    uniforms['scaleRotationsTextureSize'] = {\n      type: 'v2',\n      value: new THREE.Vector2(1024, 1024),\n    };\n\n    const material = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: vertexShaderSource,\n      fragmentShader: fragmentShaderSource,\n      transparent: true,\n      alphaTest: 1.0,\n      blending: THREE.NormalBlending,\n      depthTest: true,\n      depthWrite: false,\n      side: THREE.DoubleSide,\n    });\n\n    return material;\n  }\n\n  static buildVertexShaderProjection() {\n    // Original CUDA code for calculating splat-to-screen transformation, for reference\n    /*\n            glm::mat3 R = quat_to_rotmat(rot);\n            glm::mat3 S = scale_to_mat(scale, mod);\n            glm::mat3 L = R * S;\n\n            // center of Gaussians in the camera coordinate\n            glm::mat3x4 splat2world = glm::mat3x4(\n                glm::vec4(L[0], 0.0),\n                glm::vec4(L[1], 0.0),\n                glm::vec4(p_orig.x, p_orig.y, p_orig.z, 1)\n            );\n\n            glm::mat4 world2ndc = glm::mat4(\n                projmatrix[0], projmatrix[4], projmatrix[8], projmatrix[12],\n                projmatrix[1], projmatrix[5], projmatrix[9], projmatrix[13],\n                projmatrix[2], projmatrix[6], projmatrix[10], projmatrix[14],\n                projmatrix[3], projmatrix[7], projmatrix[11], projmatrix[15]\n            );\n\n            glm::mat3x4 ndc2pix = glm::mat3x4(\n                glm::vec4(float(W) / 2.0, 0.0, 0.0, float(W-1) / 2.0),\n                glm::vec4(0.0, float(H) / 2.0, 0.0, float(H-1) / 2.0),\n                glm::vec4(0.0, 0.0, 0.0, 1.0)\n            );\n\n            T = glm::transpose(splat2world) * world2ndc * ndc2pix;\n            normal = transformVec4x3({L[2].x, L[2].y, L[2].z}, viewmatrix);\n        */\n\n    // Compute a 2D-to-2D mapping matrix from a tangent plane into a image plane\n    // given a 2D gaussian parameters. T = WH (from the paper: https://arxiv.org/pdf/2403.17888)\n    let vertexShaderSource = `\n\n            vec4 scaleRotationA = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset, scaleRotationsTextureSize));\n            vec4 scaleRotationB = texture(scaleRotationsTexture, getDataUVF(nearestEvenIndex, 1.5,\n                                                                            oddOffset + uint(1), scaleRotationsTextureSize));\n\n            vec3 scaleRotation123 = vec3(scaleRotationA.rgb) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationA.ba, scaleRotationB.r) * fOddOffset;\n            vec3 scaleRotation456 = vec3(scaleRotationA.a, scaleRotationB.rg) * (1.0 - fOddOffset) +\n                                    vec3(scaleRotationB.gba) * fOddOffset;\n\n            float missingW = sqrt(1.0 - scaleRotation456.x * scaleRotation456.x - scaleRotation456.y *\n                                    scaleRotation456.y - scaleRotation456.z * scaleRotation456.z);\n            mat3 R = quaternionToRotationMatrix(scaleRotation456.r, scaleRotation456.g, scaleRotation456.b, missingW);\n            mat3 S = mat3(scaleRotation123.r, 0.0, 0.0,\n                            0.0, scaleRotation123.g, 0.0,\n                            0.0, 0.0, scaleRotation123.b);\n            \n            mat3 L = R * S;\n\n            mat3x4 splat2World = mat3x4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n            mat4 world2ndc = transpose(projectionMatrix * transformModelViewMatrix);\n\n            mat3x4 ndc2pix = mat3x4(vec4(viewport.x / 2.0, 0.0, 0.0, (viewport.x - 1.0) / 2.0),\n                                    vec4(0.0, viewport.y / 2.0, 0.0, (viewport.y - 1.0) / 2.0),\n                                    vec4(0.0, 0.0, 0.0, 1.0));\n\n            mat3 T = transpose(splat2World) * world2ndc * ndc2pix;\n            vec3 normal = vec3(viewMatrix * vec4(L[0][2], L[1][2], L[2][2], 0.0));\n        `;\n\n    // Original CUDA code for projection to 2D, for reference\n    /*\n            float3 T0 = {T[0][0], T[0][1], T[0][2]};\n            float3 T1 = {T[1][0], T[1][1], T[1][2]};\n            float3 T3 = {T[2][0], T[2][1], T[2][2]};\n\n            // Compute AABB\n            float3 temp_point = {1.0f, 1.0f, -1.0f};\n            float distance = sumf3(T3 * T3 * temp_point);\n            float3 f = (1 / distance) * temp_point;\n            if (distance == 0.0) return false;\n\n            point_image = {\n                sumf3(f * T0 * T3),\n                sumf3(f * T1 * T3)\n            };\n\n            float2 temp = {\n                sumf3(f * T0 * T0),\n                sumf3(f * T1 * T1)\n            };\n            float2 half_extend = point_image * point_image - temp;\n            extent = sqrtf2(maxf2(1e-4, half_extend));\n            return true;\n        */\n\n    // Computing the bounding box of the 2D Gaussian and its center\n    // The center of the bounding box is used to create a low pass filter.\n    // This code is based off the reference implementation and creates an AABB aligned\n    // with the screen for the quad to be rendered.\n    const referenceQuadGeneration = `\n            vec3 T0 = vec3(T[0][0], T[0][1], T[0][2]);\n            vec3 T1 = vec3(T[1][0], T[1][1], T[1][2]);\n            vec3 T3 = vec3(T[2][0], T[2][1], T[2][2]);\n\n            vec3 tempPoint = vec3(1.0, 1.0, -1.0);\n            float distance = (T3.x * T3.x * tempPoint.x) + (T3.y * T3.y * tempPoint.y) + (T3.z * T3.z * tempPoint.z);\n            vec3 f = (1.0 / distance) * tempPoint;\n            if (abs(distance) < 0.00001) return;\n\n            float pointImageX = (T0.x * T3.x * f.x) + (T0.y * T3.y * f.y) + (T0.z * T3.z * f.z);\n            float pointImageY = (T1.x * T3.x * f.x) + (T1.y * T3.y * f.y) + (T1.z * T3.z * f.z);\n            vec2 pointImage = vec2(pointImageX, pointImageY);\n\n            float tempX = (T0.x * T0.x * f.x) + (T0.y * T0.y * f.y) + (T0.z * T0.z * f.z);\n            float tempY = (T1.x * T1.x * f.x) + (T1.y * T1.y * f.y) + (T1.z * T1.z * f.z);\n            vec2 temp = vec2(tempX, tempY);\n\n            vec2 halfExtend = pointImage * pointImage - temp;\n            vec2 extent = sqrt(max(vec2(0.0001), halfExtend));\n            float radius = max(extent.x, extent.y);\n\n            vec2 ndcOffset = ((position.xy * radius * 3.0) * basisViewport * 2.0);\n\n            vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            gl_Position = quadPos;\n\n            vT = T;\n            vQuadCenter = pointImage;\n            vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n        `;\n\n    const useRefImplementation = false;\n    if (useRefImplementation) {\n      vertexShaderSource += referenceQuadGeneration;\n    } else {\n      // Create a quad that is aligned with the eigen vectors of the projected gaussian for rendering.\n      // This is a different approach than the reference implementation, similar to how the rendering of\n      // 3D gaussians in this viewer differs from the reference implementation. If the quad is too small\n      // (smaller than a pixel), then revert to the reference implementation.\n      vertexShaderSource += `\n\n                mat4 splat2World4 = mat4(vec4(L[0], 0.0),\n                                        vec4(L[1], 0.0),\n                                        vec4(L[2], 0.0),\n                                        vec4(splatCenter.x, splatCenter.y, splatCenter.z, 1.0));\n\n                mat4 Tt = transpose(transpose(splat2World4) * world2ndc);\n\n                vec4 tempPoint1 = Tt * vec4(1.0, 0.0, 0.0, 1.0);\n                tempPoint1 /= tempPoint1.w;\n\n                vec4 tempPoint2 = Tt * vec4(0.0, 1.0, 0.0, 1.0);\n                tempPoint2 /= tempPoint2.w;\n\n                vec4 center = Tt * vec4(0.0, 0.0, 0.0, 1.0);\n                center /= center.w;\n\n                vec2 basisVector1 = tempPoint1.xy - center.xy;\n                vec2 basisVector2 = tempPoint2.xy - center.xy;\n\n                vec2 basisVector1Screen = basisVector1 * 0.5 * viewport;\n                vec2 basisVector2Screen = basisVector2 * 0.5 * viewport;\n\n                const float minPix = 1.;\n                if (length(basisVector1Screen) < minPix || length(basisVector2Screen) < minPix) {\n                    ${referenceQuadGeneration}\n                } else {\n                    vec2 ndcOffset = vec2(position.x * basisVector1 + position.y * basisVector2) * 3.0 * inverseFocalAdjustment;\n                    vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n                    gl_Position = quadPos;\n\n                    vT = T;\n                    vQuadCenter = center.xy;\n                    vFragCoord = (quadPos.xy * 0.5 + 0.5) * viewport;\n                }\n            `;\n    }\n\n    vertexShaderSource += SplatMaterial.getVertexShaderFadeIn();\n    vertexShaderSource += `}`;\n\n    return vertexShaderSource;\n  }\n\n  static buildFragmentShader() {\n    // Original CUDA code for splat intersection, for reference\n    /*\n            const float2 xy = collected_xy[j];\n            const float3 Tu = collected_Tu[j];\n            const float3 Tv = collected_Tv[j];\n            const float3 Tw = collected_Tw[j];\n            float3 k = pix.x * Tw - Tu;\n            float3 l = pix.y * Tw - Tv;\n            float3 p = cross(k, l);\n            if (p.z == 0.0) continue;\n            float2 s = {p.x / p.z, p.y / p.z};\n            float rho3d = (s.x * s.x + s.y * s.y);\n            float2 d = {xy.x - pixf.x, xy.y - pixf.y};\n            float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y);\n\n            // compute intersection and depth\n            float rho = min(rho3d, rho2d);\n            float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z;\n            if (depth < near_n) continue;\n            float4 nor_o = collected_normal_opacity[j];\n            float normal[3] = {nor_o.x, nor_o.y, nor_o.z};\n            float opa = nor_o.w;\n\n            float power = -0.5f * rho;\n            if (power > 0.0f)\n                continue;\n\n            // Eq. (2) from 3D Gaussian splatting paper.\n            // Obtain alpha by multiplying with Gaussian opacity\n            // and its exponential falloff from mean.\n            // Avoid numerical instabilities (see paper appendix).\n            float alpha = min(0.99f, opa * exp(power));\n            if (alpha < 1.0f / 255.0f)\n                continue;\n            float test_T = T * (1 - alpha);\n            if (test_T < 0.0001f)\n            {\n                done = true;\n                continue;\n            }\n\n            float w = alpha * T;\n        */\n    let fragmentShaderSource = `\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n            varying vec2 vPosition;\n            varying mat3 vT;\n            varying vec2 vQuadCenter;\n            varying vec2 vFragCoord;\n\n            void main () {\n\n                const float FilterInvSquare = 2.0;\n                const float near_n = 0.2;\n                const float T = 1.0;\n\n                vec2 xy = vQuadCenter;\n                vec3 Tu = vT[0];\n                vec3 Tv = vT[1];\n                vec3 Tw = vT[2];\n                vec3 k = vFragCoord.x * Tw - Tu;\n                vec3 l = vFragCoord.y * Tw - Tv;\n                vec3 p = cross(k, l);\n                if (p.z == 0.0) discard;\n                vec2 s = vec2(p.x / p.z, p.y / p.z);\n                float rho3d = (s.x * s.x + s.y * s.y); \n                vec2 d = vec2(xy.x - vFragCoord.x, xy.y - vFragCoord.y);\n                float rho2d = FilterInvSquare * (d.x * d.x + d.y * d.y); \n\n                // compute intersection and depth\n                float rho = min(rho3d, rho2d);\n                float depth = (rho3d <= rho2d) ? (s.x * Tw.x + s.y * Tw.y) + Tw.z : Tw.z; \n                if (depth < near_n) discard;\n                //  vec4 nor_o = collected_normal_opacity[j];\n                //  float normal[3] = {nor_o.x, nor_o.y, nor_o.z};\n                float opa = vColor.a;\n\n                float power = -0.5f * rho;\n                if (power > 0.0f) discard;\n\n                // Eq. (2) from 3D Gaussian splatting paper.\n                // Obtain alpha by multiplying with Gaussian opacity\n                // and its exponential falloff from mean.\n                // Avoid numerical instabilities (see paper appendix). \n                float alpha = min(0.99f, opa * exp(power));\n                if (alpha < 1.0f / 255.0f) discard;\n                float test_T = T * (1.0 - alpha);\n                if (test_T < 0.0001)discard;\n\n                float w = alpha * T;\n                gl_FragColor = vec4(vColor.rgb, w);\n            }\n        `;\n\n    return fragmentShaderSource;\n  }\n}\n","import * as THREE from 'three';\n\nexport class SplatGeometry {\n  /**\n   * Build the Three.js geometry that will be used to render the splats. The geometry is instanced and is made up of\n   * vertices for a single quad as well as an attribute buffer for the splat indexes.\n   * @param {number} maxSplatCount The maximum number of splats that the geometry will need to accomodate\n   * @return {THREE.InstancedBufferGeometry}\n   */\n  static build(maxSplatCount) {\n    const baseGeometry = new THREE.BufferGeometry();\n    baseGeometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n    // Vertices for the instanced quad\n    const positionsArray = new Float32Array(4 * 3);\n    const positions = new THREE.BufferAttribute(positionsArray, 3);\n    baseGeometry.setAttribute('position', positions);\n    positions.setXYZ(0, -1.0, -1.0, 0.0);\n    positions.setXYZ(1, -1.0, 1.0, 0.0);\n    positions.setXYZ(2, 1.0, 1.0, 0.0);\n    positions.setXYZ(3, 1.0, -1.0, 0.0);\n    positions.needsUpdate = true;\n\n    const geometry = new THREE.InstancedBufferGeometry().copy(baseGeometry);\n\n    // Splat index buffer\n    const splatIndexArray = new Uint32Array(maxSplatCount);\n    const splatIndexes = new THREE.InstancedBufferAttribute(\n      splatIndexArray,\n      1,\n      false,\n    );\n    splatIndexes.setUsage(THREE.DynamicDrawUsage);\n    geometry.setAttribute('splatIndex', splatIndexes);\n\n    geometry.instanceCount = 0;\n\n    return geometry;\n  }\n}\n","import * as THREE from 'three';\n\n/**\n * SplatScene: Descriptor for a single splat scene managed by an instance of SplatMesh.\n */\nexport class SplatScene extends THREE.Object3D {\n  constructor(\n    splatBuffer,\n    position = new THREE.Vector3(),\n    quaternion = new THREE.Quaternion(),\n    scale = new THREE.Vector3(1, 1, 1),\n    minimumAlpha = 1,\n    opacity = 1.0,\n    visible = true,\n  ) {\n    super();\n    this.splatBuffer = splatBuffer;\n    this.position.copy(position);\n    this.quaternion.copy(quaternion);\n    this.scale.copy(scale);\n    this.transform = new THREE.Matrix4();\n    this.minimumAlpha = minimumAlpha;\n    this.opacity = opacity;\n    this.visible = visible;\n  }\n\n  copyTransformData(otherScene) {\n    this.position.copy(otherScene.position);\n    this.quaternion.copy(otherScene.quaternion);\n    this.scale.copy(otherScene.scale);\n    this.transform.copy(otherScene.transform);\n  }\n\n  updateTransform(dynamicMode) {\n    if (dynamicMode) {\n      if (this.matrixWorldAutoUpdate) this.updateWorldMatrix(true, false);\n      this.transform.copy(this.matrixWorld);\n    } else {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.transform.copy(this.matrix);\n    }\n  }\n}\n","import * as THREE from 'three';\nimport { delayedExecute } from '../Util.js';\n\nclass SplatTreeNode {\n  static idGen = 0;\n\n  constructor(min, max, depth, id) {\n    this.min = new THREE.Vector3().copy(min);\n    this.max = new THREE.Vector3().copy(max);\n    this.boundingBox = new THREE.Box3(this.min, this.max);\n    this.center = new THREE.Vector3()\n      .copy(this.max)\n      .sub(this.min)\n      .multiplyScalar(0.5)\n      .add(this.min);\n    this.depth = depth;\n    this.children = [];\n    this.data = null;\n    this.id = id || SplatTreeNode.idGen++;\n  }\n}\n\nclass SplatSubTree {\n  constructor(maxDepth, maxCentersPerNode) {\n    this.maxDepth = maxDepth;\n    this.maxCentersPerNode = maxCentersPerNode;\n    this.sceneDimensions = new THREE.Vector3();\n    this.sceneMin = new THREE.Vector3();\n    this.sceneMax = new THREE.Vector3();\n    this.rootNode = null;\n    this.nodesWithIndexes = [];\n    this.splatMesh = null;\n  }\n\n  static convertWorkerSubTreeNode(workerSubTreeNode) {\n    const minVector = new THREE.Vector3().fromArray(workerSubTreeNode.min);\n    const maxVector = new THREE.Vector3().fromArray(workerSubTreeNode.max);\n    const convertedNode = new SplatTreeNode(\n      minVector,\n      maxVector,\n      workerSubTreeNode.depth,\n      workerSubTreeNode.id,\n    );\n    if (workerSubTreeNode.data.indexes) {\n      convertedNode.data = {\n        indexes: [],\n      };\n      for (let index of workerSubTreeNode.data.indexes) {\n        convertedNode.data.indexes.push(index);\n      }\n    }\n    if (workerSubTreeNode.children) {\n      for (let child of workerSubTreeNode.children) {\n        convertedNode.children.push(\n          SplatSubTree.convertWorkerSubTreeNode(child),\n        );\n      }\n    }\n    return convertedNode;\n  }\n\n  static convertWorkerSubTree(workerSubTree, splatMesh) {\n    const convertedSubTree = new SplatSubTree(\n      workerSubTree.maxDepth,\n      workerSubTree.maxCentersPerNode,\n    );\n    convertedSubTree.sceneMin = new THREE.Vector3().fromArray(\n      workerSubTree.sceneMin,\n    );\n    convertedSubTree.sceneMax = new THREE.Vector3().fromArray(\n      workerSubTree.sceneMax,\n    );\n\n    convertedSubTree.splatMesh = splatMesh;\n    convertedSubTree.rootNode = SplatSubTree.convertWorkerSubTreeNode(\n      workerSubTree.rootNode,\n    );\n\n    const visitLeavesFromNode = (node, visitFunc) => {\n      if (node.children.length === 0) visitFunc(node);\n      for (let child of node.children) {\n        visitLeavesFromNode(child, visitFunc);\n      }\n    };\n\n    convertedSubTree.nodesWithIndexes = [];\n    visitLeavesFromNode(convertedSubTree.rootNode, (node) => {\n      if (node.data && node.data.indexes && node.data.indexes.length > 0) {\n        convertedSubTree.nodesWithIndexes.push(node);\n      }\n    });\n\n    return convertedSubTree;\n  }\n}\n\nfunction createSplatTreeWorker(self) {\n  let WorkerSplatTreeNodeIDGen = 0;\n\n  class WorkerBox3 {\n    constructor(min, max) {\n      this.min = [min[0], min[1], min[2]];\n      this.max = [max[0], max[1], max[2]];\n    }\n\n    containsPoint(point) {\n      return (\n        point[0] >= this.min[0] &&\n        point[0] <= this.max[0] &&\n        point[1] >= this.min[1] &&\n        point[1] <= this.max[1] &&\n        point[2] >= this.min[2] &&\n        point[2] <= this.max[2]\n      );\n    }\n  }\n\n  class WorkerSplatSubTree {\n    constructor(maxDepth, maxCentersPerNode) {\n      this.maxDepth = maxDepth;\n      this.maxCentersPerNode = maxCentersPerNode;\n      this.sceneDimensions = [];\n      this.sceneMin = [];\n      this.sceneMax = [];\n      this.rootNode = null;\n      this.addedIndexes = {};\n      this.nodesWithIndexes = [];\n      this.splatMesh = null;\n      this.disposed = false;\n    }\n  }\n\n  class WorkerSplatTreeNode {\n    constructor(min, max, depth, id) {\n      this.min = [min[0], min[1], min[2]];\n      this.max = [max[0], max[1], max[2]];\n      this.center = [\n        (max[0] - min[0]) * 0.5 + min[0],\n        (max[1] - min[1]) * 0.5 + min[1],\n        (max[2] - min[2]) * 0.5 + min[2],\n      ];\n      this.depth = depth;\n      this.children = [];\n      this.data = null;\n      this.id = id || WorkerSplatTreeNodeIDGen++;\n    }\n  }\n\n  processSplatTreeNode = function(tree, node, indexToCenter, sceneCenters) {\n    const splatCount = node.data.indexes.length;\n\n    if (splatCount < tree.maxCentersPerNode || node.depth > tree.maxDepth) {\n      const newIndexes = [];\n      for (let i = 0; i < node.data.indexes.length; i++) {\n        if (!tree.addedIndexes[node.data.indexes[i]]) {\n          newIndexes.push(node.data.indexes[i]);\n          tree.addedIndexes[node.data.indexes[i]] = true;\n        }\n      }\n      node.data.indexes = newIndexes;\n      node.data.indexes.sort((a, b) => {\n        if (a > b) return 1;\n        else return -1;\n      });\n      tree.nodesWithIndexes.push(node);\n      return;\n    }\n\n    const nodeDimensions = [\n      node.max[0] - node.min[0],\n      node.max[1] - node.min[1],\n      node.max[2] - node.min[2],\n    ];\n    const halfDimensions = [\n      nodeDimensions[0] * 0.5,\n      nodeDimensions[1] * 0.5,\n      nodeDimensions[2] * 0.5,\n    ];\n    const nodeCenter = [\n      node.min[0] + halfDimensions[0],\n      node.min[1] + halfDimensions[1],\n      node.min[2] + halfDimensions[2],\n    ];\n\n    const childrenBounds = [\n      // top section, clockwise from upper-left (looking from above, +Y)\n      new WorkerBox3(\n        [\n          nodeCenter[0] - halfDimensions[0],\n          nodeCenter[1],\n          nodeCenter[2] - halfDimensions[2],\n        ],\n        [nodeCenter[0], nodeCenter[1] + halfDimensions[1], nodeCenter[2]],\n      ),\n      new WorkerBox3(\n        [nodeCenter[0], nodeCenter[1], nodeCenter[2] - halfDimensions[2]],\n        [\n          nodeCenter[0] + halfDimensions[0],\n          nodeCenter[1] + halfDimensions[1],\n          nodeCenter[2],\n        ],\n      ),\n      new WorkerBox3(\n        [nodeCenter[0], nodeCenter[1], nodeCenter[2]],\n        [\n          nodeCenter[0] + halfDimensions[0],\n          nodeCenter[1] + halfDimensions[1],\n          nodeCenter[2] + halfDimensions[2],\n        ],\n      ),\n      new WorkerBox3(\n        [nodeCenter[0] - halfDimensions[0], nodeCenter[1], nodeCenter[2]],\n        [\n          nodeCenter[0],\n          nodeCenter[1] + halfDimensions[1],\n          nodeCenter[2] + halfDimensions[2],\n        ],\n      ),\n\n      // bottom section, clockwise from lower-left (looking from above, +Y)\n      new WorkerBox3(\n        [\n          nodeCenter[0] - halfDimensions[0],\n          nodeCenter[1] - halfDimensions[1],\n          nodeCenter[2] - halfDimensions[2],\n        ],\n        [nodeCenter[0], nodeCenter[1], nodeCenter[2]],\n      ),\n      new WorkerBox3(\n        [\n          nodeCenter[0],\n          nodeCenter[1] - halfDimensions[1],\n          nodeCenter[2] - halfDimensions[2],\n        ],\n        [nodeCenter[0] + halfDimensions[0], nodeCenter[1], nodeCenter[2]],\n      ),\n      new WorkerBox3(\n        [nodeCenter[0], nodeCenter[1] - halfDimensions[1], nodeCenter[2]],\n        [\n          nodeCenter[0] + halfDimensions[0],\n          nodeCenter[1],\n          nodeCenter[2] + halfDimensions[2],\n        ],\n      ),\n      new WorkerBox3(\n        [\n          nodeCenter[0] - halfDimensions[0],\n          nodeCenter[1] - halfDimensions[1],\n          nodeCenter[2],\n        ],\n        [nodeCenter[0], nodeCenter[1], nodeCenter[2] + halfDimensions[2]],\n      ),\n    ];\n\n    const splatCounts = [];\n    const baseIndexes = [];\n    for (let i = 0; i < childrenBounds.length; i++) {\n      splatCounts[i] = 0;\n      baseIndexes[i] = [];\n    }\n\n    const center = [0, 0, 0];\n    for (let i = 0; i < splatCount; i++) {\n      const splatGlobalIndex = node.data.indexes[i];\n      const centerBase = indexToCenter[splatGlobalIndex];\n      center[0] = sceneCenters[centerBase];\n      center[1] = sceneCenters[centerBase + 1];\n      center[2] = sceneCenters[centerBase + 2];\n      for (let j = 0; j < childrenBounds.length; j++) {\n        if (childrenBounds[j].containsPoint(center)) {\n          splatCounts[j]++;\n          baseIndexes[j].push(splatGlobalIndex);\n        }\n      }\n    }\n\n    for (let i = 0; i < childrenBounds.length; i++) {\n      const childNode = new WorkerSplatTreeNode(\n        childrenBounds[i].min,\n        childrenBounds[i].max,\n        node.depth + 1,\n      );\n      childNode.data = {\n        indexes: baseIndexes[i],\n      };\n      node.children.push(childNode);\n    }\n\n    node.data = {};\n    for (let child of node.children) {\n      processSplatTreeNode(tree, child, indexToCenter, sceneCenters);\n    }\n    return;\n  };\n\n  const buildSubTree = (sceneCenters, maxDepth, maxCentersPerNode) => {\n    const sceneMin = [0, 0, 0];\n    const sceneMax = [0, 0, 0];\n    const indexes = [];\n    const centerCount = Math.floor(sceneCenters.length / 4);\n    for (let i = 0; i < centerCount; i++) {\n      const base = i * 4;\n      const x = sceneCenters[base];\n      const y = sceneCenters[base + 1];\n      const z = sceneCenters[base + 2];\n      const index = Math.round(sceneCenters[base + 3]);\n      if (i === 0 || x < sceneMin[0]) sceneMin[0] = x;\n      if (i === 0 || x > sceneMax[0]) sceneMax[0] = x;\n      if (i === 0 || y < sceneMin[1]) sceneMin[1] = y;\n      if (i === 0 || y > sceneMax[1]) sceneMax[1] = y;\n      if (i === 0 || z < sceneMin[2]) sceneMin[2] = z;\n      if (i === 0 || z > sceneMax[2]) sceneMax[2] = z;\n      indexes.push(index);\n    }\n    const subTree = new WorkerSplatSubTree(maxDepth, maxCentersPerNode);\n    subTree.sceneMin = sceneMin;\n    subTree.sceneMax = sceneMax;\n    subTree.rootNode = new WorkerSplatTreeNode(\n      subTree.sceneMin,\n      subTree.sceneMax,\n      0,\n    );\n    subTree.rootNode.data = {\n      indexes: indexes,\n    };\n\n    return subTree;\n  };\n\n  function createSplatTree(allCenters, maxDepth, maxCentersPerNode) {\n    const indexToCenter = [];\n    for (let sceneCenters of allCenters) {\n      const centerCount = Math.floor(sceneCenters.length / 4);\n      for (let i = 0; i < centerCount; i++) {\n        const base = i * 4;\n        const index = Math.round(sceneCenters[base + 3]);\n        indexToCenter[index] = base;\n      }\n    }\n    const subTrees = [];\n    for (let sceneCenters of allCenters) {\n      const subTree = buildSubTree(sceneCenters, maxDepth, maxCentersPerNode);\n      subTrees.push(subTree);\n      processSplatTreeNode(\n        subTree,\n        subTree.rootNode,\n        indexToCenter,\n        sceneCenters,\n      );\n    }\n    self.postMessage({\n      subTrees: subTrees,\n    });\n  }\n\n  self.onmessage = (e) => {\n    if (e.data.process) {\n      createSplatTree(\n        e.data.process.centers,\n        e.data.process.maxDepth,\n        e.data.process.maxCentersPerNode,\n      );\n    }\n  };\n}\n\nfunction workerProcessCenters(\n  splatTreeWorker,\n  centers,\n  transferBuffers,\n  maxDepth,\n  maxCentersPerNode,\n) {\n  splatTreeWorker.postMessage(\n    {\n      process: {\n        centers: centers,\n        maxDepth: maxDepth,\n        maxCentersPerNode: maxCentersPerNode,\n      },\n    },\n    transferBuffers,\n  );\n}\n\nfunction checkAndCreateWorker() {\n  const splatTreeWorker = new Worker(\n    URL.createObjectURL(\n      new Blob(['(', createSplatTreeWorker.toString(), ')(self)'], {\n        type: 'application/javascript',\n      }),\n    ),\n  );\n  return splatTreeWorker;\n}\n\n/**\n * SplatTree: Octree tailored to splat data from a SplatMesh instance\n */\nexport class SplatTree {\n  constructor(maxDepth, maxCentersPerNode) {\n    this.maxDepth = maxDepth;\n    this.maxCentersPerNode = maxCentersPerNode;\n    this.subTrees = [];\n    this.splatMesh = null;\n  }\n\n  dispose() {\n    this.diposeSplatTreeWorker();\n    this.disposed = true;\n  }\n\n  diposeSplatTreeWorker() {\n    if (this.splatTreeWorker) this.splatTreeWorker.terminate();\n    this.splatTreeWorker = null;\n  }\n\n  /**\n   * Construct this instance of SplatTree from an instance of SplatMesh.\n   *\n   * @param {SplatMesh} splatMesh The instance of SplatMesh from which to construct this splat tree.\n   * @param {function} filterFunc Optional function to filter out unwanted splats.\n   * @param {function} onIndexesUpload Function to be called when the upload of splat centers to the splat tree\n   *                                   builder worker starts and finishes.\n   * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from\n   *                                           the format produced by the splat tree builder worker starts and ends.\n   * @return {undefined}\n   */\n  processSplatMesh = function(\n    splatMesh,\n    filterFunc = () => true,\n    onIndexesUpload,\n    onSplatTreeConstruction,\n  ) {\n    if (!this.splatTreeWorker) this.splatTreeWorker = checkAndCreateWorker();\n\n    this.splatMesh = splatMesh;\n    this.subTrees = [];\n    const center = new THREE.Vector3();\n\n    const addCentersForScene = (splatOffset, splatCount) => {\n      const sceneCenters = new Float32Array(splatCount * 4);\n      let addedCount = 0;\n      for (let i = 0; i < splatCount; i++) {\n        const globalSplatIndex = i + splatOffset;\n        if (filterFunc(globalSplatIndex)) {\n          splatMesh.getSplatCenter(globalSplatIndex, center);\n          const addBase = addedCount * 4;\n          sceneCenters[addBase] = center.x;\n          sceneCenters[addBase + 1] = center.y;\n          sceneCenters[addBase + 2] = center.z;\n          sceneCenters[addBase + 3] = globalSplatIndex;\n          addedCount++;\n        }\n      }\n      return sceneCenters;\n    };\n\n    return new Promise((resolve) => {\n      const checkForEarlyExit = () => {\n        if (this.disposed) {\n          this.diposeSplatTreeWorker();\n          resolve();\n          return true;\n        }\n        return false;\n      };\n\n      if (onIndexesUpload) onIndexesUpload(false);\n\n      delayedExecute(() => {\n        if (checkForEarlyExit()) return;\n\n        const allCenters = [];\n        if (splatMesh.dynamicMode) {\n          let splatOffset = 0;\n          for (let s = 0; s < splatMesh.scenes.length; s++) {\n            const scene = splatMesh.getScene(s);\n            const splatCount = scene.splatBuffer.getSplatCount();\n            const sceneCenters = addCentersForScene(splatOffset, splatCount);\n            allCenters.push(sceneCenters);\n            splatOffset += splatCount;\n          }\n        } else {\n          const sceneCenters = addCentersForScene(0, splatMesh.getSplatCount());\n          allCenters.push(sceneCenters);\n        }\n\n        this.splatTreeWorker.onmessage = (e) => {\n          if (checkForEarlyExit()) return;\n\n          if (e.data.subTrees) {\n            if (onSplatTreeConstruction) onSplatTreeConstruction(false);\n\n            delayedExecute(() => {\n              if (checkForEarlyExit()) return;\n\n              for (let workerSubTree of e.data.subTrees) {\n                const convertedSubTree = SplatSubTree.convertWorkerSubTree(\n                  workerSubTree,\n                  splatMesh,\n                );\n                this.subTrees.push(convertedSubTree);\n              }\n              this.diposeSplatTreeWorker();\n\n              if (onSplatTreeConstruction) onSplatTreeConstruction(true);\n\n              delayedExecute(() => {\n                resolve();\n              });\n            });\n          }\n        };\n\n        delayedExecute(() => {\n          if (checkForEarlyExit()) return;\n          if (onIndexesUpload) onIndexesUpload(true);\n          const transferBuffers = allCenters.map((array) => array.buffer);\n          workerProcessCenters(\n            this.splatTreeWorker,\n            allCenters,\n            transferBuffers,\n            this.maxDepth,\n            this.maxCentersPerNode,\n          );\n        });\n      });\n    });\n  };\n\n  countLeaves() {\n    let leafCount = 0;\n    this.visitLeaves(() => {\n      leafCount++;\n    });\n\n    return leafCount;\n  }\n\n  visitLeaves(visitFunc) {\n    const visitLeavesFromNode = (node, visitFunc) => {\n      if (node.children.length === 0) visitFunc(node);\n      for (let child of node.children) {\n        visitLeavesFromNode(child, visitFunc);\n      }\n    };\n\n    for (let subTree of this.subTrees) {\n      visitLeavesFromNode(subTree.rootNode, visitFunc);\n    }\n  }\n}\n","function WebGLExtensions(gl) {\n  const extensions = {};\n\n  function getExtension(name) {\n    if (extensions[name] !== undefined) {\n      return extensions[name];\n    }\n\n    let extension;\n\n    switch (name) {\n      case 'WEBGL_depth_texture':\n        extension =\n          gl.getExtension('WEBGL_depth_texture') ||\n          gl.getExtension('MOZ_WEBGL_depth_texture') ||\n          gl.getExtension('WEBKIT_WEBGL_depth_texture');\n        break;\n\n      case 'EXT_texture_filter_anisotropic':\n        extension =\n          gl.getExtension('EXT_texture_filter_anisotropic') ||\n          gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||\n          gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n        break;\n\n      case 'WEBGL_compressed_texture_s3tc':\n        extension =\n          gl.getExtension('WEBGL_compressed_texture_s3tc') ||\n          gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||\n          gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n        break;\n\n      case 'WEBGL_compressed_texture_pvrtc':\n        extension =\n          gl.getExtension('WEBGL_compressed_texture_pvrtc') ||\n          gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n        break;\n\n      default:\n        extension = gl.getExtension(name);\n    }\n\n    extensions[name] = extension;\n\n    return extension;\n  }\n\n  return {\n    has: function(name) {\n      return getExtension(name) !== null;\n    },\n\n    init: function(capabilities) {\n      if (capabilities.isWebGL2) {\n        getExtension('EXT_color_buffer_float');\n        getExtension('WEBGL_clip_cull_distance');\n      } else {\n        getExtension('WEBGL_depth_texture');\n        getExtension('OES_texture_float');\n        getExtension('OES_texture_half_float');\n        getExtension('OES_texture_half_float_linear');\n        getExtension('OES_standard_derivatives');\n        getExtension('OES_element_index_uint');\n        getExtension('OES_vertex_array_object');\n        getExtension('ANGLE_instanced_arrays');\n      }\n\n      getExtension('OES_texture_float_linear');\n      getExtension('EXT_color_buffer_half_float');\n      getExtension('WEBGL_multisampled_render_to_texture');\n    },\n\n    get: function(name) {\n      const extension = getExtension(name);\n\n      if (extension === null) {\n        console.warn(\n          'THREE.WebGLRenderer: ' + name + ' extension not supported.',\n        );\n      }\n\n      return extension;\n    },\n  };\n}\n\nexport { WebGLExtensions };\n","function WebGLCapabilities(gl, extensions, parameters) {\n  let maxAnisotropy;\n\n  function getMaxAnisotropy() {\n    if (maxAnisotropy !== undefined) return maxAnisotropy;\n\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n\n      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      maxAnisotropy = 0;\n    }\n\n    return maxAnisotropy;\n  }\n\n  function getMaxPrecision(precision) {\n    if (precision === 'highp') {\n      if (\n        gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision >\n          0 &&\n        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)\n          .precision > 0\n      ) {\n        return 'highp';\n      }\n\n      precision = 'mediump';\n    }\n\n    if (precision === 'mediump') {\n      if (\n        gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT)\n          .precision > 0 &&\n        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT)\n          .precision > 0\n      ) {\n        return 'mediump';\n      }\n    }\n\n    return 'lowp';\n  }\n\n  const isWebGL2 =\n    typeof WebGL2RenderingContext !== 'undefined' &&\n    gl.constructor.name === 'WebGL2RenderingContext';\n\n  let precision =\n    parameters.precision !== undefined ? parameters.precision : 'highp';\n  const maxPrecision = getMaxPrecision(precision);\n\n  if (maxPrecision !== precision) {\n    console.warn(\n      'THREE.WebGLRenderer:',\n      precision,\n      'not supported, using',\n      maxPrecision,\n      'instead.',\n    );\n    precision = maxPrecision;\n  }\n\n  const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');\n\n  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\n  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);\n  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\n  const vertexTextures = maxVertexTextures > 0;\n  const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');\n  const floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n  const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;\n\n  return {\n    isWebGL2: isWebGL2,\n\n    drawBuffers: drawBuffers,\n\n    getMaxAnisotropy: getMaxAnisotropy,\n    getMaxPrecision: getMaxPrecision,\n\n    precision: precision,\n    logarithmicDepthBuffer: logarithmicDepthBuffer,\n\n    maxTextures: maxTextures,\n    maxVertexTextures: maxVertexTextures,\n    maxTextureSize: maxTextureSize,\n    maxCubemapSize: maxCubemapSize,\n\n    maxAttributes: maxAttributes,\n    maxVertexUniforms: maxVertexUniforms,\n    maxVaryings: maxVaryings,\n    maxFragmentUniforms: maxFragmentUniforms,\n\n    vertexTextures: vertexTextures,\n    floatFragmentTextures: floatFragmentTextures,\n    floatVertexTextures: floatVertexTextures,\n\n    maxSamples: maxSamples,\n  };\n}\n\nexport { WebGLCapabilities };\n","import * as THREE from 'three';\nimport { SplatMaterial3D } from './SplatMaterial3D.js';\nimport { SplatMaterial2D } from './SplatMaterial2D.js';\nimport { SplatGeometry } from './SplatGeometry.js';\nimport { SplatScene } from './SplatScene.js';\nimport { SplatTree } from '../splattree/SplatTree.js';\nimport { WebGLExtensions } from '../three-shim/WebGLExtensions.js';\nimport { WebGLCapabilities } from '../three-shim/WebGLCapabilities.js';\nimport { uintEncodedFloat, rgbaArrayToInteger } from '../Util.js';\nimport { Constants } from '../Constants.js';\nimport { SceneRevealMode } from '../SceneRevealMode.js';\nimport { SplatRenderMode } from '../SplatRenderMode.js';\nimport { LogLevel } from '../LogLevel.js';\nimport {\n  clamp,\n  getSphericalHarmonicsComponentCountForDegree,\n} from '../Util.js';\n\nconst dummyGeometry = new THREE.BufferGeometry();\nconst dummyMaterial = new THREE.MeshBasicMaterial();\n\nconst COVARIANCES_ELEMENTS_PER_SPLAT = 6;\nconst CENTER_COLORS_ELEMENTS_PER_SPLAT = 4;\n\nconst COVARIANCES_ELEMENTS_PER_TEXEL_STORED = 4;\nconst COVARIANCES_ELEMENTS_PER_TEXEL_ALLOCATED = 4;\nconst COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_STORED = 6;\nconst COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_ALLOCATED = 8;\nconst SCALES_ROTATIONS_ELEMENTS_PER_TEXEL = 4;\nconst CENTER_COLORS_ELEMENTS_PER_TEXEL = 4;\nconst SCENE_INDEXES_ELEMENTS_PER_TEXEL = 1;\n\nconst SCENE_FADEIN_RATE_FAST = 0.012;\nconst SCENE_FADEIN_RATE_GRADUAL = 0.003;\n\nconst VISIBLE_REGION_EXPANSION_DELTA = 1;\n\n// Based on my own observations across multiple devices, OSes and browsers, using textures that have one dimension\n// greater than 4096 while the other is greater than or equal to 4096 causes issues (Essentially any texture larger\n// than 4096 x 4096 (16777216) texels). Specifically it seems all texture data beyond the 4096 x 4096 texel boundary\n// is corrupted, while data below that boundary is usable. In these cases the texture has been valid in the eyes of\n// both Three.js and WebGL, and the texel format (RG, RGBA, etc.) has not mattered. More investigation will be needed,\n// but for now the work-around is to split the spherical harmonics into three textures (one for each color channel).\nconst MAX_TEXTURE_TEXELS = 16777216;\n\n/**\n * SplatMesh: Container for one or more splat scenes, abstracting them into a single unified container for\n * splat data. Additionally contains data structures and code to make the splat data renderable as a Three.js mesh.\n */\nexport class SplatMesh extends THREE.Mesh {\n  constructor(\n    splatRenderMode = SplatRenderMode.ThreeD,\n    dynamicMode = false,\n    enableOptionalEffects = false,\n    halfPrecisionCovariancesOnGPU = false,\n    devicePixelRatio = 1,\n    enableDistancesComputationOnGPU = true,\n    integerBasedDistancesComputation = false,\n    antialiased = false,\n    maxScreenSpaceSplatSize = 1024,\n    logLevel = LogLevel.None,\n    sphericalHarmonicsDegree = 0,\n    sceneFadeInRateMultiplier = 1.0,\n  ) {\n    super(dummyGeometry, dummyMaterial);\n\n    // Reference to a Three.js renderer\n    this.renderer = undefined;\n\n    // Determine how the splats are rendered\n    this.splatRenderMode = splatRenderMode;\n\n    // When 'dynamicMode' is true, scenes are assumed to be non-static. Dynamic scenes are handled differently\n    // and certain optimizations cannot be made for them. Additionally, by default, all splat data retrieved from\n    // this splat mesh will not have their scene transform applied to them if the splat mesh is dynamic. That\n    // can be overriden via parameters to the individual functions that are used to retrieve splat data.\n    this.dynamicMode = dynamicMode;\n\n    // When true, allows for usage of extra properties and attributes during rendering for effects such as opacity adjustment.\n    // Default is false for performance reasons. These properties are separate from transform properties (scale, rotation, position)\n    // that are enabled by the 'dynamicScene' parameter.\n    this.enableOptionalEffects = enableOptionalEffects;\n\n    // Use 16-bit floating point values when storing splat covariance data in textures, instead of 32-bit\n    this.halfPrecisionCovariancesOnGPU = halfPrecisionCovariancesOnGPU;\n\n    // Ratio of the resolution in physical pixels to the resolution in CSS pixels for the current display device\n    this.devicePixelRatio = devicePixelRatio;\n\n    // Use a transform feedback to calculate splat distances from the camera\n    this.enableDistancesComputationOnGPU = enableDistancesComputationOnGPU;\n\n    // Use a faster integer-based approach for calculating splat distances from the camera\n    this.integerBasedDistancesComputation = integerBasedDistancesComputation;\n\n    // When true, will perform additional steps during rendering to address artifacts caused by the rendering of gaussians at a\n    // substantially different resolution than that at which they were rendered during training. This will only work correctly\n    // for models that were trained using a process that utilizes this compensation calculation. For more details:\n    // https://github.com/nerfstudio-project/gsplat/pull/117\n    // https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093\n    this.antialiased = antialiased;\n\n    // Specify the maximum clip space splat size, can help deal with large splats that get too unwieldy\n    this.maxScreenSpaceSplatSize = maxScreenSpaceSplatSize;\n\n    // The verbosity of console logging\n    this.logLevel = logLevel;\n\n    // Degree 0 means no spherical harmonics\n    this.sphericalHarmonicsDegree = sphericalHarmonicsDegree;\n    this.minSphericalHarmonicsDegree = 0;\n\n    this.sceneFadeInRateMultiplier = sceneFadeInRateMultiplier;\n\n    // The individual splat scenes stored in this splat mesh, each containing their own transform\n    this.scenes = [];\n\n    // Special octree tailored to SplatMesh instances\n    this.splatTree = null;\n    this.baseSplatTree = null;\n\n    // Cache textures and the intermediate data used to populate them\n    this.splatDataTextures = {};\n\n    this.distancesTransformFeedback = {\n      id: null,\n      vertexShader: null,\n      fragmentShader: null,\n      program: null,\n      centersBuffer: null,\n      sceneIndexesBuffer: null,\n      outDistancesBuffer: null,\n      centersLoc: -1,\n      modelViewProjLoc: -1,\n      sceneIndexesLoc: -1,\n      transformsLocs: [],\n    };\n\n    this.globalSplatIndexToLocalSplatIndexMap = [];\n    this.globalSplatIndexToSceneIndexMap = [];\n\n    this.lastBuildSplatCount = 0;\n    this.lastBuildScenes = [];\n    this.lastBuildMaxSplatCount = 0;\n    this.lastBuildSceneCount = 0;\n    this.firstRenderTime = -1;\n    this.finalBuild = false;\n\n    this.webGLUtils = null;\n\n    this.boundingBox = new THREE.Box3();\n    this.calculatedSceneCenter = new THREE.Vector3();\n    this.maxSplatDistanceFromSceneCenter = 0;\n    this.visibleRegionBufferRadius = 0;\n    this.visibleRegionRadius = 0;\n    this.visibleRegionFadeStartRadius = 0;\n    this.visibleRegionChanging = false;\n\n    this.splatScale = 1.0;\n    this.pointCloudModeEnabled = false;\n\n    this.disposed = false;\n    this.lastRenderer = null;\n    this.visible = false;\n\n    //This is used to define how to modify the material\n    this.setupIDMode = this.setupIDMaterialMode.bind(this);\n  }\n\n  setupIDMaterialMode = status => {\n    this.material.uniforms.uSetID.value = Number(status);\n    this.material.transparent = !status;\n  }\n\n  /**\n   * Build a container for each scene managed by this splat mesh based on an instance of SplatBuffer, along with optional\n   * transform data (position, scale, rotation) passed to the splat mesh during the build process.\n   * @param {Array<THREE.Matrix4>} splatBuffers SplatBuffer instances containing splats for each scene\n   * @param {Array<object>} sceneOptions Array of options objects: {\n   *\n   *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n   *\n   *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n   *\n   *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n   * }\n   * @return {Array<THREE.Matrix4>}\n   */\n  static buildScenes(parentObject, splatBuffers, sceneOptions) {\n    const scenes = [];\n    scenes.length = splatBuffers.length;\n    for (let i = 0; i < splatBuffers.length; i++) {\n      const splatBuffer = splatBuffers[i];\n      const options = sceneOptions[i] || {};\n      let positionArray = options['position'] || [0, 0, 0];\n      let rotationArray = options['rotation'] || [0, 0, 0, 1];\n      let scaleArray = options['scale'] || [1, 1, 1];\n      const position = new THREE.Vector3().fromArray(positionArray);\n      const rotation = new THREE.Quaternion().fromArray(rotationArray);\n      const scale = new THREE.Vector3().fromArray(scaleArray);\n      const scene = SplatMesh.createScene(\n        splatBuffer,\n        position,\n        rotation,\n        scale,\n        options.splatAlphaRemovalThreshold || 1,\n        options.opacity,\n        options.visible,\n      );\n      parentObject.add(scene);\n      scenes[i] = scene;\n    }\n    return scenes;\n  }\n\n  static createScene(\n    splatBuffer,\n    position,\n    rotation,\n    scale,\n    minimumAlpha,\n    opacity = 1.0,\n    visible = true,\n  ) {\n    return new SplatScene(\n      splatBuffer,\n      position,\n      rotation,\n      scale,\n      minimumAlpha,\n      opacity,\n      visible,\n    );\n  }\n\n  /**\n   * Build data structures that map global splat indexes (based on a unified index across all splat buffers) to\n   * local data within a single scene.\n   * @param {Array<SplatBuffer>} splatBuffers Instances of SplatBuffer off which to build the maps\n   * @return {object}\n   */\n  static buildSplatIndexMaps(splatBuffers) {\n    const localSplatIndexMap = [];\n    const sceneIndexMap = [];\n    let totalSplatCount = 0;\n    for (let s = 0; s < splatBuffers.length; s++) {\n      const splatBuffer = splatBuffers[s];\n      const maxSplatCount = splatBuffer.getMaxSplatCount();\n      for (let i = 0; i < maxSplatCount; i++) {\n        localSplatIndexMap[totalSplatCount] = i;\n        sceneIndexMap[totalSplatCount] = s;\n        totalSplatCount++;\n      }\n    }\n    return {\n      localSplatIndexMap,\n      sceneIndexMap,\n    };\n  }\n\n  /**\n   * Build an instance of SplatTree (a specialized octree) for the given splat mesh.\n   * @param {Array<number>} minAlphas Array of minimum splat slphas for each scene\n   * @param {function} onSplatTreeIndexesUpload Function to be called when the upload of splat centers to the splat tree\n   *                                            builder worker starts and finishes.\n   * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from\n   *                                           the format produced by the splat tree builder worker starts and ends.\n   * @return {SplatTree}\n   */\n  buildSplatTree = function(\n    minAlphas = [],\n    onSplatTreeIndexesUpload,\n    onSplatTreeConstruction,\n  ) {\n    return new Promise((resolve) => {\n      this.disposeSplatTree();\n      // TODO: expose SplatTree constructor parameters (maximumDepth and maxCentersPerNode) so that they can\n      // be configured on a per-scene basis\n      this.baseSplatTree = new SplatTree(8, 1000);\n      const buildStartTime = performance.now();\n      const splatColor = new THREE.Vector4();\n      this.baseSplatTree\n        .processSplatMesh(\n          this,\n          (splatIndex) => {\n            this.getSplatColor(splatIndex, splatColor);\n            const sceneIndex = this.getSceneIndexForSplat(splatIndex);\n            const minAlpha = minAlphas[sceneIndex] || 1;\n            return splatColor.w >= minAlpha;\n          },\n          onSplatTreeIndexesUpload,\n          onSplatTreeConstruction,\n        )\n        .then(() => {\n          const buildTime = performance.now() - buildStartTime;\n          if (this.logLevel >= LogLevel.Info) {\n            console.log('SplatTree build: ' + buildTime + ' ms');\n          }\n          if (this.disposed) {\n            resolve();\n          } else {\n            this.splatTree = this.baseSplatTree;\n            this.baseSplatTree = null;\n\n            let leavesWithVertices = 0;\n            let avgSplatCount = 0;\n            let maxSplatCount = 0;\n            let nodeCount = 0;\n\n            this.splatTree.visitLeaves((node) => {\n              const nodeSplatCount = node.data.indexes.length;\n              if (nodeSplatCount > 0) {\n                avgSplatCount += nodeSplatCount;\n                maxSplatCount = Math.max(maxSplatCount, nodeSplatCount);\n                nodeCount++;\n                leavesWithVertices++;\n              }\n            });\n            if (this.logLevel >= LogLevel.Info) {\n              console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`);\n              console.log(`SplatTree leaves with splats:${leavesWithVertices}`);\n              avgSplatCount = avgSplatCount / nodeCount;\n              console.log(`Avg splat count per node: ${avgSplatCount}`);\n              console.log(`Total splat count: ${this.getSplatCount()}`);\n            }\n            resolve();\n          }\n        });\n    });\n  };\n\n  /**\n   * Construct this instance of SplatMesh.\n   * @param {Array<SplatBuffer>} splatBuffers The base splat data, instances of SplatBuffer\n   * @param {Array<object>} sceneOptions Dynamic options for each scene {\n   *\n   *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n   *                                     value (valid range: 0 - 255), defaults to 1\n   *\n   *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n   *\n   *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n   *\n   *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n   *\n   * }\n   * @param {boolean} keepSceneTransforms For a scene that already exists and is being overwritten, this flag\n   *                                      says to keep the transform from the existing scene.\n   * @param {boolean} finalBuild Will the splat mesh be in its final state after this build?\n   * @param {function} onSplatTreeIndexesUpload Function to be called when the upload of splat centers to the splat tree\n   *                                            builder worker starts and finishes.\n   * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from\n   *                                           the format produced by the splat tree builder worker starts and ends.\n   * @return {object} Object containing info about the splats that are updated\n   */\n  build(\n    splatBuffers,\n    sceneOptions,\n    keepSceneTransforms = true,\n    finalBuild = false,\n    onSplatTreeIndexesUpload,\n    onSplatTreeConstruction,\n    preserveVisibleRegion = true,\n  ) {\n    this.sceneOptions = sceneOptions;\n    this.finalBuild = finalBuild;\n\n    const maxSplatCount =\n      SplatMesh.getTotalMaxSplatCountForSplatBuffers(splatBuffers);\n\n    const newScenes = SplatMesh.buildScenes(this, splatBuffers, sceneOptions);\n    if (keepSceneTransforms) {\n      for (let i = 0; i < this.scenes.length && i < newScenes.length; i++) {\n        const newScene = newScenes[i];\n        const existingScene = this.getScene(i);\n        newScene.copyTransformData(existingScene);\n      }\n    }\n    this.scenes = newScenes;\n\n    let minSphericalHarmonicsDegree = 3;\n    for (let splatBuffer of splatBuffers) {\n      const splatBufferSphericalHarmonicsDegree =\n        splatBuffer.getMinSphericalHarmonicsDegree();\n      if (splatBufferSphericalHarmonicsDegree < minSphericalHarmonicsDegree) {\n        minSphericalHarmonicsDegree = splatBufferSphericalHarmonicsDegree;\n      }\n    }\n    this.minSphericalHarmonicsDegree = Math.min(\n      minSphericalHarmonicsDegree,\n      this.sphericalHarmonicsDegree,\n    );\n\n    let splatBuffersChanged = false;\n    if (splatBuffers.length !== this.lastBuildScenes.length) {\n      splatBuffersChanged = true;\n    } else {\n      for (let i = 0; i < splatBuffers.length; i++) {\n        const splatBuffer = splatBuffers[i];\n        if (splatBuffer !== this.lastBuildScenes[i].splatBuffer) {\n          splatBuffersChanged = true;\n          break;\n        }\n      }\n    }\n\n    let isUpdateBuild = true;\n    if (\n      this.scenes.length !== 1 ||\n      this.lastBuildSceneCount !== this.scenes.length ||\n      this.lastBuildMaxSplatCount !== maxSplatCount ||\n      splatBuffersChanged\n    ) {\n      isUpdateBuild = false;\n    }\n\n    if (!isUpdateBuild) {\n      this.boundingBox = new THREE.Box3();\n      if (!preserveVisibleRegion) {\n        this.maxSplatDistanceFromSceneCenter = 0;\n        this.visibleRegionBufferRadius = 0;\n        this.visibleRegionRadius = 0;\n        this.visibleRegionFadeStartRadius = 0;\n        this.firstRenderTime = -1;\n      }\n      this.lastBuildScenes = [];\n      this.lastBuildSplatCount = 0;\n      this.lastBuildMaxSplatCount = 0;\n      this.disposeMeshData();\n      this.geometry = SplatGeometry.build(maxSplatCount);\n      if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n        this.material = SplatMaterial3D.build(\n          this.dynamicMode,\n          this.enableOptionalEffects,\n          this.antialiased,\n          this.maxScreenSpaceSplatSize,\n          this.splatScale,\n          this.pointCloudModeEnabled,\n          this.minSphericalHarmonicsDegree,\n        );\n      } else {\n        this.material = SplatMaterial2D.build(\n          this.dynamicMode,\n          this.enableOptionalEffects,\n          this.splatScale,\n          this.pointCloudModeEnabled,\n          this.minSphericalHarmonicsDegree,\n        );\n      }\n\n      const indexMaps = SplatMesh.buildSplatIndexMaps(splatBuffers);\n      this.globalSplatIndexToLocalSplatIndexMap = indexMaps.localSplatIndexMap;\n      this.globalSplatIndexToSceneIndexMap = indexMaps.sceneIndexMap;\n    }\n\n    const splatBufferSplatCount = this.getSplatCount(true);\n    if (this.enableDistancesComputationOnGPU) {\n      this.setupDistancesComputationTransformFeedback();\n    }\n    const dataUpdateResults =\n      this.refreshGPUDataFromSplatBuffers(isUpdateBuild);\n\n    for (let i = 0; i < this.scenes.length; i++) {\n      this.lastBuildScenes[i] = this.scenes[i];\n    }\n    this.lastBuildSplatCount = splatBufferSplatCount;\n    this.lastBuildMaxSplatCount = this.getMaxSplatCount();\n    this.lastBuildSceneCount = this.scenes.length;\n\n    if (finalBuild && this.scenes.length > 0) {\n      this.buildSplatTree(\n        sceneOptions.map((options) => options.splatAlphaRemovalThreshold || 1),\n        onSplatTreeIndexesUpload,\n        onSplatTreeConstruction,\n      ).then(() => {\n        if (this.onSplatTreeReadyCallback) {\n          this.onSplatTreeReadyCallback(this.splatTree);\n        }\n        this.onSplatTreeReadyCallback = null;\n      });\n    }\n\n    this.visible = this.scenes.length > 0;\n\n    return dataUpdateResults;\n  }\n\n  freeIntermediateSplatData() {\n    const deleteTextureData = (texture) => {\n      delete texture.source.data;\n      delete texture.image;\n      texture.onUpdate = null;\n    };\n\n    delete this.splatDataTextures.baseData.covariances;\n    delete this.splatDataTextures.baseData.centers;\n    delete this.splatDataTextures.baseData.colors;\n    delete this.splatDataTextures.baseData.sphericalHarmonics;\n\n    delete this.splatDataTextures.centerColors.data;\n    delete this.splatDataTextures.covariances.data;\n    if (this.splatDataTextures.sphericalHarmonics) {\n      delete this.splatDataTextures.sphericalHarmonics.data;\n    }\n    if (this.splatDataTextures.sceneIndexes) {\n      delete this.splatDataTextures.sceneIndexes.data;\n    }\n\n    this.splatDataTextures.centerColors.texture.needsUpdate = true;\n    this.splatDataTextures.centerColors.texture.onUpdate = () => {\n      deleteTextureData(this.splatDataTextures.centerColors.texture);\n    };\n\n    this.splatDataTextures.covariances.texture.needsUpdate = true;\n    this.splatDataTextures.covariances.texture.onUpdate = () => {\n      deleteTextureData(this.splatDataTextures.covariances.texture);\n    };\n\n    if (this.splatDataTextures.sphericalHarmonics) {\n      if (this.splatDataTextures.sphericalHarmonics.texture) {\n        this.splatDataTextures.sphericalHarmonics.texture.needsUpdate = true;\n        this.splatDataTextures.sphericalHarmonics.texture.onUpdate = () => {\n          deleteTextureData(this.splatDataTextures.sphericalHarmonics.texture);\n        };\n      } else {\n        this.splatDataTextures.sphericalHarmonics.textures.forEach(\n          (texture) => {\n            texture.needsUpdate = true;\n            texture.onUpdate = () => {\n              deleteTextureData(texture);\n            };\n          },\n        );\n      }\n    }\n    if (this.splatDataTextures.sceneIndexes) {\n      this.splatDataTextures.sceneIndexes.texture.needsUpdate = true;\n      this.splatDataTextures.sceneIndexes.texture.onUpdate = () => {\n        deleteTextureData(this.splatDataTextures.sceneIndexes.texture);\n      };\n    }\n  }\n  /**\n   * Dispose all resources held by the splat mesh\n   */\n  dispose() {\n    this.disposeMeshData();\n    this.disposeTextures();\n    this.disposeSplatTree();\n    if (this.enableDistancesComputationOnGPU) {\n      if (this.computeDistancesOnGPUSyncTimeout) {\n        clearTimeout(this.computeDistancesOnGPUSyncTimeout);\n        this.computeDistancesOnGPUSyncTimeout = null;\n      }\n      this.disposeDistancesComputationGPUResources();\n    }\n    this.scenes = [];\n    this.distancesTransformFeedback = {\n      id: null,\n      vertexShader: null,\n      fragmentShader: null,\n      program: null,\n      centersBuffer: null,\n      sceneIndexesBuffer: null,\n      outDistancesBuffer: null,\n      centersLoc: -1,\n      modelViewProjLoc: -1,\n      sceneIndexesLoc: -1,\n      transformsLocs: [],\n    };\n    this.renderer = null;\n\n    this.globalSplatIndexToLocalSplatIndexMap = [];\n    this.globalSplatIndexToSceneIndexMap = [];\n\n    this.lastBuildSplatCount = 0;\n    this.lastBuildScenes = [];\n    this.lastBuildMaxSplatCount = 0;\n    this.lastBuildSceneCount = 0;\n    this.firstRenderTime = -1;\n    this.finalBuild = false;\n\n    this.webGLUtils = null;\n\n    this.boundingBox = new THREE.Box3();\n    this.calculatedSceneCenter = new THREE.Vector3();\n    this.maxSplatDistanceFromSceneCenter = 0;\n    this.visibleRegionBufferRadius = 0;\n    this.visibleRegionRadius = 0;\n    this.visibleRegionFadeStartRadius = 0;\n    this.visibleRegionChanging = false;\n\n    this.splatScale = 1.0;\n    this.pointCloudModeEnabled = false;\n\n    this.disposed = true;\n    this.lastRenderer = null;\n    this.visible = false;\n  }\n\n  /**\n   * Dispose of only the Three.js mesh resources (geometry, material, and texture)\n   */\n  disposeMeshData() {\n    if (this.geometry && this.geometry !== dummyGeometry) {\n      this.geometry.dispose();\n      this.geometry = null;\n    }\n    if (this.material) {\n      this.material.dispose();\n      this.material = null;\n    }\n  }\n\n  disposeTextures() {\n    for (let textureKey in this.splatDataTextures) {\n      if (this.splatDataTextures.hasOwnProperty(textureKey)) {\n        const textureContainer = this.splatDataTextures[textureKey];\n        if (textureContainer.texture) {\n          textureContainer.texture.dispose();\n          textureContainer.texture = null;\n        }\n      }\n    }\n    this.splatDataTextures = null;\n  }\n\n  disposeSplatTree() {\n    if (this.splatTree) {\n      this.splatTree.dispose();\n      this.splatTree = null;\n    }\n    if (this.baseSplatTree) {\n      this.baseSplatTree.dispose();\n      this.baseSplatTree = null;\n    }\n  }\n\n  getSplatTree() {\n    return this.splatTree;\n  }\n\n  onSplatTreeReady(callback) {\n    this.onSplatTreeReadyCallback = callback;\n  }\n\n  /**\n   * Get copies of data that are necessary for splat distance computation: splat center positions and splat\n   * scene indexes (necessary for applying dynamic scene transformations during distance computation)\n   * @param {*} start The index at which to start copying data\n   * @param {*} end  The index at which to stop copying data\n   * @return {object}\n   */\n  getDataForDistancesComputation(start, end) {\n    const centers = this.integerBasedDistancesComputation ?\n      this.getIntegerCenters(start, end, true) :\n      this.getFloatCenters(start, end, true);\n    const sceneIndexes = this.getSceneIndexes(start, end);\n    return {\n      centers,\n      sceneIndexes,\n    };\n  }\n\n  /**\n   * Refresh data textures and GPU buffers with splat data from the splat buffers belonging to this mesh.\n   * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.\n   * @return {object}\n   */\n  refreshGPUDataFromSplatBuffers(sinceLastBuildOnly) {\n    const splatCount = this.getSplatCount(true);\n    this.refreshDataTexturesFromSplatBuffers(sinceLastBuildOnly);\n    const updateStart = sinceLastBuildOnly ? this.lastBuildSplatCount : 0;\n    const { centers, sceneIndexes } = this.getDataForDistancesComputation(\n      updateStart,\n      splatCount - 1,\n    );\n    if (this.enableDistancesComputationOnGPU) {\n      this.refreshGPUBuffersForDistancesComputation(\n        centers,\n        sceneIndexes,\n        sinceLastBuildOnly,\n      );\n    }\n    return {\n      from: updateStart,\n      to: splatCount - 1,\n      count: splatCount - updateStart,\n      centers: centers,\n      sceneIndexes: sceneIndexes,\n    };\n  }\n\n  /**\n   * Update the GPU buffers that are used for computing splat distances on the GPU.\n   * @param {Array<number>} centers Splat center positions\n   * @param {Array<number>} sceneIndexes Indexes of the scene to which each splat belongs\n   * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.\n   */\n  refreshGPUBuffersForDistancesComputation(\n    centers,\n    sceneIndexes,\n    sinceLastBuildOnly = false,\n  ) {\n    const offset = sinceLastBuildOnly ? this.lastBuildSplatCount : 0;\n    this.updateGPUCentersBufferForDistancesComputation(\n      sinceLastBuildOnly,\n      centers,\n      offset,\n    );\n    this.updateGPUTransformIndexesBufferForDistancesComputation(\n      sinceLastBuildOnly,\n      sceneIndexes,\n      offset,\n    );\n  }\n\n  /**\n   * Refresh data textures with data from the splat buffers for this mesh.\n   * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.\n   */\n  refreshDataTexturesFromSplatBuffers(sinceLastBuildOnly) {\n    const splatCount = this.getSplatCount(true);\n    const fromSplat = this.lastBuildSplatCount;\n    const toSplat = splatCount - 1;\n\n    if (!sinceLastBuildOnly) {\n      this.setupDataTextures();\n      this.updateBaseDataFromSplatBuffers();\n    } else {\n      this.updateBaseDataFromSplatBuffers(fromSplat, toSplat);\n    }\n\n    this.updateDataTexturesFromBaseData(fromSplat, toSplat);\n    this.updateVisibleRegion(sinceLastBuildOnly);\n  }\n\n  setupDataTextures() {\n    const maxSplatCount = this.getMaxSplatCount();\n    const splatCount = this.getSplatCount(true);\n\n    this.disposeTextures();\n\n    const computeDataTextureSize = (elementsPerTexel, elementsPerSplat) => {\n      const texSize = new THREE.Vector2(4096, 1024);\n      while (\n        texSize.x * texSize.y * elementsPerTexel <\n        maxSplatCount * elementsPerSplat\n      ) {\n        texSize.y *= 2;\n      }\n      return texSize;\n    };\n\n    const getCovariancesElementsPertexelStored = (compressionLevel) => {\n      return compressionLevel >= 1 ?\n        COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_STORED :\n        COVARIANCES_ELEMENTS_PER_TEXEL_STORED;\n    };\n\n    const getCovariancesInitialTextureSpecs = (compressionLevel) => {\n      const elementsPerTexelStored =\n        getCovariancesElementsPertexelStored(compressionLevel);\n      const texSize = computeDataTextureSize(elementsPerTexelStored, 6);\n      return { elementsPerTexelStored, texSize };\n    };\n\n    let covarianceCompressionLevel = this.getTargetCovarianceCompressionLevel();\n    const scaleRotationCompressionLevel = 0;\n    const shCompressionLevel =\n      this.getTargetSphericalHarmonicsCompressionLevel();\n\n    let covariances;\n    let scales;\n    let rotations;\n    if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n      const initialCovTexSpecs = getCovariancesInitialTextureSpecs(\n        covarianceCompressionLevel,\n      );\n      if (\n        initialCovTexSpecs.texSize.x * initialCovTexSpecs.texSize.y >\n          MAX_TEXTURE_TEXELS &&\n        covarianceCompressionLevel === 0\n      ) {\n        covarianceCompressionLevel = 1;\n      }\n      covariances = new Float32Array(\n        maxSplatCount * COVARIANCES_ELEMENTS_PER_SPLAT,\n      );\n    } else {\n      scales = new Float32Array(maxSplatCount * 3);\n      rotations = new Float32Array(maxSplatCount * 4);\n    }\n\n    const centers = new Float32Array(maxSplatCount * 3);\n    const colors = new Uint8Array(maxSplatCount * 4);\n\n    let SphericalHarmonicsArrayType = Float32Array;\n    if (shCompressionLevel === 1) SphericalHarmonicsArrayType = Uint16Array;\n    else if (shCompressionLevel === 2) SphericalHarmonicsArrayType = Uint8Array;\n    const shComponentCount = getSphericalHarmonicsComponentCountForDegree(\n      this.minSphericalHarmonicsDegree,\n    );\n    const shData = this.minSphericalHarmonicsDegree ?\n      new SphericalHarmonicsArrayType(maxSplatCount * shComponentCount) :\n      undefined;\n\n    // set up centers/colors data texture\n    const centersColsTexSize = computeDataTextureSize(\n      CENTER_COLORS_ELEMENTS_PER_TEXEL,\n      4,\n    );\n    const paddedCentersCols = new Uint32Array(\n      centersColsTexSize.x *\n        centersColsTexSize.y *\n        CENTER_COLORS_ELEMENTS_PER_TEXEL,\n    );\n    SplatMesh.updateCenterColorsPaddedData(\n      0,\n      splatCount - 1,\n      centers,\n      colors,\n      paddedCentersCols,\n    );\n\n    const centersColsTex = new THREE.DataTexture(\n      paddedCentersCols,\n      centersColsTexSize.x,\n      centersColsTexSize.y,\n      THREE.RGBAIntegerFormat,\n      THREE.UnsignedIntType,\n    );\n    centersColsTex.internalFormat = 'RGBA32UI';\n    centersColsTex.needsUpdate = true;\n    this.material.uniforms.centersColorsTexture.value = centersColsTex;\n    this.material.uniforms.centersColorsTextureSize.value.copy(\n      centersColsTexSize,\n    );\n    this.material.uniformsNeedUpdate = true;\n\n    this.splatDataTextures = {\n      baseData: {\n        covariances: covariances,\n        scales: scales,\n        rotations: rotations,\n        centers: centers,\n        colors: colors,\n        sphericalHarmonics: shData,\n      },\n      centerColors: {\n        data: paddedCentersCols,\n        texture: centersColsTex,\n        size: centersColsTexSize,\n      },\n    };\n\n    if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n      // set up covariances data texture\n\n      const covTexSpecs = getCovariancesInitialTextureSpecs(\n        covarianceCompressionLevel,\n      );\n      const covariancesElementsPerTexelStored =\n        covTexSpecs.elementsPerTexelStored;\n      const covTexSize = covTexSpecs.texSize;\n\n      let CovariancesDataType =\n        covarianceCompressionLevel >= 1 ? Uint32Array : Float32Array;\n      const covariancesElementsPerTexelAllocated =\n        covarianceCompressionLevel >= 1 ?\n          COVARIANCES_ELEMENTS_PER_TEXEL_COMPRESSED_ALLOCATED :\n          COVARIANCES_ELEMENTS_PER_TEXEL_ALLOCATED;\n      const covariancesTextureData = new CovariancesDataType(\n        covTexSize.x * covTexSize.y * covariancesElementsPerTexelAllocated,\n      );\n\n      if (covarianceCompressionLevel === 0) {\n        covariancesTextureData.set(covariances);\n      } else {\n        SplatMesh.updatePaddedCompressedCovariancesTextureData(\n          covariances,\n          covariancesTextureData,\n          0,\n          0,\n          covariances.length,\n        );\n      }\n\n      let covTex;\n      if (covarianceCompressionLevel >= 1) {\n        covTex = new THREE.DataTexture(\n          covariancesTextureData,\n          covTexSize.x,\n          covTexSize.y,\n          THREE.RGBAIntegerFormat,\n          THREE.UnsignedIntType,\n        );\n        covTex.internalFormat = 'RGBA32UI';\n        this.material.uniforms.covariancesTextureHalfFloat.value = covTex;\n      } else {\n        covTex = new THREE.DataTexture(\n          covariancesTextureData,\n          covTexSize.x,\n          covTexSize.y,\n          THREE.RGBAFormat,\n          THREE.FloatType,\n        );\n        this.material.uniforms.covariancesTexture.value = covTex;\n\n        // For some reason a usampler2D needs to have a valid texture attached or WebGL complains\n        const dummyTex = new THREE.DataTexture(\n          new Uint32Array(32),\n          2,\n          2,\n          THREE.RGBAIntegerFormat,\n          THREE.UnsignedIntType,\n        );\n        dummyTex.internalFormat = 'RGBA32UI';\n        this.material.uniforms.covariancesTextureHalfFloat.value = dummyTex;\n        dummyTex.needsUpdate = true;\n      }\n      covTex.needsUpdate = true;\n\n      this.material.uniforms.covariancesAreHalfFloat.value =\n        covarianceCompressionLevel >= 1 ? 1 : 0;\n      this.material.uniforms.covariancesTextureSize.value.copy(covTexSize);\n\n      this.splatDataTextures['covariances'] = {\n        data: covariancesTextureData,\n        texture: covTex,\n        size: covTexSize,\n        compressionLevel: covarianceCompressionLevel,\n        elementsPerTexelStored: covariancesElementsPerTexelStored,\n        elementsPerTexelAllocated: covariancesElementsPerTexelAllocated,\n      };\n    } else {\n      // set up scale & rotations data texture\n      const elementsPerSplat = 6;\n      const scaleRotationsTexSize = computeDataTextureSize(\n        SCALES_ROTATIONS_ELEMENTS_PER_TEXEL,\n        elementsPerSplat,\n      );\n      let ScaleRotationsDataType =\n        scaleRotationCompressionLevel >= 1 ? Uint16Array : Float32Array;\n      let scaleRotationsTextureType =\n        scaleRotationCompressionLevel >= 1 ?\n          THREE.HalfFloatType :\n          THREE.FloatType;\n      const paddedScaleRotations = new ScaleRotationsDataType(\n        scaleRotationsTexSize.x *\n          scaleRotationsTexSize.y *\n          SCALES_ROTATIONS_ELEMENTS_PER_TEXEL,\n      );\n\n      SplatMesh.updateScaleRotationsPaddedData(\n        0,\n        splatCount - 1,\n        scales,\n        rotations,\n        paddedScaleRotations,\n      );\n\n      const scaleRotationsTex = new THREE.DataTexture(\n        paddedScaleRotations,\n        scaleRotationsTexSize.x,\n        scaleRotationsTexSize.y,\n        THREE.RGBAFormat,\n        scaleRotationsTextureType,\n      );\n      scaleRotationsTex.needsUpdate = true;\n      this.material.uniforms.scaleRotationsTexture.value = scaleRotationsTex;\n      this.material.uniforms.scaleRotationsTextureSize.value.copy(\n        scaleRotationsTexSize,\n      );\n\n      this.splatDataTextures['scaleRotations'] = {\n        data: paddedScaleRotations,\n        texture: scaleRotationsTex,\n        size: scaleRotationsTexSize,\n        compressionLevel: scaleRotationCompressionLevel,\n      };\n    }\n\n    if (shData) {\n      const shTextureType =\n        shCompressionLevel === 2 ? THREE.UnsignedByteType : THREE.HalfFloatType;\n\n      let paddedSHComponentCount = shComponentCount;\n      if (paddedSHComponentCount % 2 !== 0) paddedSHComponentCount++;\n      const shElementsPerTexel = this.minSphericalHarmonicsDegree === 2 ? 4 : 2;\n      const texelFormat =\n        shElementsPerTexel === 4 ? THREE.RGBAFormat : THREE.RGFormat;\n      let shTexSize = computeDataTextureSize(\n        shElementsPerTexel,\n        paddedSHComponentCount,\n      );\n\n      // Use one texture for all spherical harmonics data\n      if (shTexSize.x * shTexSize.y <= MAX_TEXTURE_TEXELS) {\n        const paddedSHArraySize =\n          shTexSize.x * shTexSize.y * shElementsPerTexel;\n        const paddedSHArray = new SphericalHarmonicsArrayType(\n          paddedSHArraySize,\n        );\n        for (let c = 0; c < splatCount; c++) {\n          const srcBase = shComponentCount * c;\n          const destBase = paddedSHComponentCount * c;\n          for (let i = 0; i < shComponentCount; i++) {\n            paddedSHArray[destBase + i] = shData[srcBase + i];\n          }\n        }\n\n        const shTexture = new THREE.DataTexture(\n          paddedSHArray,\n          shTexSize.x,\n          shTexSize.y,\n          texelFormat,\n          shTextureType,\n        );\n        shTexture.needsUpdate = true;\n        this.material.uniforms.sphericalHarmonicsTexture.value = shTexture;\n        this.splatDataTextures['sphericalHarmonics'] = {\n          componentCount: shComponentCount,\n          paddedComponentCount: paddedSHComponentCount,\n          data: paddedSHArray,\n          textureCount: 1,\n          texture: shTexture,\n          size: shTexSize,\n          compressionLevel: shCompressionLevel,\n          elementsPerTexel: shElementsPerTexel,\n        };\n        // Use three textures for spherical harmonics data, one per color channel\n      } else {\n        const shComponentCountPerChannel = shComponentCount / 3;\n        paddedSHComponentCount = shComponentCountPerChannel;\n        if (paddedSHComponentCount % 2 !== 0) paddedSHComponentCount++;\n        shTexSize = computeDataTextureSize(\n          shElementsPerTexel,\n          paddedSHComponentCount,\n        );\n\n        const paddedSHArraySize =\n          shTexSize.x * shTexSize.y * shElementsPerTexel;\n        const textureUniforms = [\n          this.material.uniforms.sphericalHarmonicsTextureR,\n          this.material.uniforms.sphericalHarmonicsTextureG,\n          this.material.uniforms.sphericalHarmonicsTextureB,\n        ];\n        const paddedSHArrays = [];\n        const shTextures = [];\n        for (let t = 0; t < 3; t++) {\n          const paddedSHArray = new SphericalHarmonicsArrayType(\n            paddedSHArraySize,\n          );\n          paddedSHArrays.push(paddedSHArray);\n          for (let c = 0; c < splatCount; c++) {\n            const srcBase = shComponentCount * c;\n            const destBase = paddedSHComponentCount * c;\n            if (shComponentCountPerChannel >= 3) {\n              for (let i = 0; i < 3; i++) {\n                paddedSHArray[destBase + i] = shData[srcBase + t * 3 + i];\n              }\n              if (shComponentCountPerChannel >= 8) {\n                for (let i = 0; i < 5; i++) {\n                  paddedSHArray[destBase + 3 + i] =\n                    shData[srcBase + 9 + t * 5 + i];\n                }\n              }\n            }\n          }\n\n          const shTexture = new THREE.DataTexture(\n            paddedSHArray,\n            shTexSize.x,\n            shTexSize.y,\n            texelFormat,\n            shTextureType,\n          );\n          shTextures.push(shTexture);\n          shTexture.needsUpdate = true;\n          textureUniforms[t].value = shTexture;\n        }\n\n        this.material.uniforms.sphericalHarmonicsMultiTextureMode.value = 1;\n        this.splatDataTextures['sphericalHarmonics'] = {\n          componentCount: shComponentCount,\n          componentCountPerChannel: shComponentCountPerChannel,\n          paddedComponentCount: paddedSHComponentCount,\n          data: paddedSHArrays,\n          textureCount: 3,\n          textures: shTextures,\n          size: shTexSize,\n          compressionLevel: shCompressionLevel,\n          elementsPerTexel: shElementsPerTexel,\n        };\n      }\n\n      this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(\n        shTexSize,\n      );\n      this.material.uniforms.sphericalHarmonics8BitMode.value =\n        shCompressionLevel === 2 ? 1 : 0;\n      for (let s = 0; s < this.scenes.length; s++) {\n        const splatBuffer = this.scenes[s].splatBuffer;\n        this.material.uniforms.sphericalHarmonics8BitCompressionRangeMin.value[\n          s\n        ] = splatBuffer.minSphericalHarmonicsCoeff;\n        this.material.uniforms.sphericalHarmonics8BitCompressionRangeMax.value[\n          s\n        ] = splatBuffer.maxSphericalHarmonicsCoeff;\n      }\n      this.material.uniformsNeedUpdate = true;\n    }\n\n    const sceneIndexesTexSize = computeDataTextureSize(\n      SCENE_INDEXES_ELEMENTS_PER_TEXEL,\n      4,\n    );\n    const paddedTransformIndexes = new Uint32Array(\n      sceneIndexesTexSize.x *\n        sceneIndexesTexSize.y *\n        SCENE_INDEXES_ELEMENTS_PER_TEXEL,\n    );\n    for (let c = 0; c < splatCount; c++) {\n      paddedTransformIndexes[c] = this.globalSplatIndexToSceneIndexMap[c];\n    }\n    const sceneIndexesTexture = new THREE.DataTexture(\n      paddedTransformIndexes,\n      sceneIndexesTexSize.x,\n      sceneIndexesTexSize.y,\n      THREE.RedIntegerFormat,\n      THREE.UnsignedIntType,\n    );\n    sceneIndexesTexture.internalFormat = 'R32UI';\n    sceneIndexesTexture.needsUpdate = true;\n    this.material.uniforms.sceneIndexesTexture.value = sceneIndexesTexture;\n    this.material.uniforms.sceneIndexesTextureSize.value.copy(\n      sceneIndexesTexSize,\n    );\n    this.material.uniformsNeedUpdate = true;\n    this.splatDataTextures['sceneIndexes'] = {\n      data: paddedTransformIndexes,\n      texture: sceneIndexesTexture,\n      size: sceneIndexesTexSize,\n    };\n    this.material.uniforms.sceneCount.value = this.scenes.length;\n  }\n\n  updateBaseDataFromSplatBuffers(fromSplat, toSplat) {\n    const covarancesTextureDesc = this.splatDataTextures['covariances'];\n    const covarianceCompressionLevel = covarancesTextureDesc ?\n      covarancesTextureDesc.compressionLevel :\n      undefined;\n    const scaleRotationsTextureDesc = this.splatDataTextures['scaleRotations'];\n    const scaleRotationCompressionLevel = scaleRotationsTextureDesc ?\n      scaleRotationsTextureDesc.compressionLevel :\n      undefined;\n    const shITextureDesc = this.splatDataTextures['sphericalHarmonics'];\n    const shCompressionLevel = shITextureDesc ?\n      shITextureDesc.compressionLevel :\n      0;\n\n    this.fillSplatDataArrays(\n      this.splatDataTextures.baseData.covariances,\n      this.splatDataTextures.baseData.scales,\n      this.splatDataTextures.baseData.rotations,\n      this.splatDataTextures.baseData.centers,\n      this.splatDataTextures.baseData.colors,\n      this.splatDataTextures.baseData.sphericalHarmonics,\n      undefined,\n      covarianceCompressionLevel,\n      scaleRotationCompressionLevel,\n      shCompressionLevel,\n      fromSplat,\n      toSplat,\n      fromSplat,\n    );\n  }\n\n  updateDataTexturesFromBaseData(fromSplat, toSplat) {\n    const covarancesTextureDesc = this.splatDataTextures['covariances'];\n    const covarianceCompressionLevel = covarancesTextureDesc ?\n      covarancesTextureDesc.compressionLevel :\n      undefined;\n    const scaleRotationsTextureDesc = this.splatDataTextures['scaleRotations'];\n    const scaleRotationCompressionLevel = scaleRotationsTextureDesc ?\n      scaleRotationsTextureDesc.compressionLevel :\n      undefined;\n    const shTextureDesc = this.splatDataTextures['sphericalHarmonics'];\n    const shCompressionLevel = shTextureDesc ?\n      shTextureDesc.compressionLevel :\n      0;\n\n    // Update center & color data texture\n    const centerColorsTextureDescriptor =\n      this.splatDataTextures['centerColors'];\n    const paddedCenterColors = centerColorsTextureDescriptor.data;\n    const centerColorsTexture = centerColorsTextureDescriptor.texture;\n    SplatMesh.updateCenterColorsPaddedData(\n      fromSplat,\n      toSplat,\n      this.splatDataTextures.baseData.centers,\n      this.splatDataTextures.baseData.colors,\n      paddedCenterColors,\n    );\n    const centerColorsTextureProps = this.renderer ?\n      this.renderer.properties.get(centerColorsTexture) :\n      null;\n    if (!centerColorsTextureProps || !centerColorsTextureProps.__webglTexture) {\n      centerColorsTexture.needsUpdate = true;\n    } else {\n      this.updateDataTexture(\n        paddedCenterColors,\n        centerColorsTextureDescriptor.texture,\n        centerColorsTextureDescriptor.size,\n        centerColorsTextureProps,\n        CENTER_COLORS_ELEMENTS_PER_TEXEL,\n        CENTER_COLORS_ELEMENTS_PER_SPLAT,\n        4,\n        fromSplat,\n        toSplat,\n      );\n    }\n\n    // update covariance data texture\n    if (covarancesTextureDesc) {\n      const covariancesTexture = covarancesTextureDesc.texture;\n      const covarancesStartElement = fromSplat * COVARIANCES_ELEMENTS_PER_SPLAT;\n      const covariancesEndElement = toSplat * COVARIANCES_ELEMENTS_PER_SPLAT;\n\n      if (covarianceCompressionLevel === 0) {\n        for (let i = covarancesStartElement; i <= covariancesEndElement; i++) {\n          const covariance = this.splatDataTextures.baseData.covariances[i];\n          covarancesTextureDesc.data[i] = covariance;\n        }\n      } else {\n        SplatMesh.updatePaddedCompressedCovariancesTextureData(\n          this.splatDataTextures.baseData.covariances,\n          covarancesTextureDesc.data,\n          fromSplat * covarancesTextureDesc.elementsPerTexelAllocated,\n          covarancesStartElement,\n          covariancesEndElement,\n        );\n      }\n\n      const covariancesTextureProps = this.renderer ?\n        this.renderer.properties.get(covariancesTexture) :\n        null;\n      if (!covariancesTextureProps || !covariancesTextureProps.__webglTexture) {\n        covariancesTexture.needsUpdate = true;\n      } else {\n        if (covarianceCompressionLevel === 0) {\n          this.updateDataTexture(\n            covarancesTextureDesc.data,\n            covarancesTextureDesc.texture,\n            covarancesTextureDesc.size,\n            covariancesTextureProps,\n            covarancesTextureDesc.elementsPerTexelStored,\n            COVARIANCES_ELEMENTS_PER_SPLAT,\n            4,\n            fromSplat,\n            toSplat,\n          );\n        } else {\n          this.updateDataTexture(\n            covarancesTextureDesc.data,\n            covarancesTextureDesc.texture,\n            covarancesTextureDesc.size,\n            covariancesTextureProps,\n            covarancesTextureDesc.elementsPerTexelAllocated,\n            covarancesTextureDesc.elementsPerTexelAllocated,\n            2,\n            fromSplat,\n            toSplat,\n          );\n        }\n      }\n    }\n\n    // update scale and rotation data texture\n    if (scaleRotationsTextureDesc) {\n      const paddedScaleRotations = scaleRotationsTextureDesc.data;\n      const scaleRotationsTexture = scaleRotationsTextureDesc.texture;\n      const elementsPerSplat = 6;\n      const bytesPerElement = scaleRotationCompressionLevel === 0 ? 4 : 2;\n\n      SplatMesh.updateScaleRotationsPaddedData(\n        fromSplat,\n        toSplat,\n        this.splatDataTextures.baseData.scales,\n        this.splatDataTextures.baseData.rotations,\n        paddedScaleRotations,\n      );\n      const scaleRotationsTextureProps = this.renderer ?\n        this.renderer.properties.get(scaleRotationsTexture) :\n        null;\n      if (\n        !scaleRotationsTextureProps ||\n        !scaleRotationsTextureProps.__webglTexture\n      ) {\n        scaleRotationsTexture.needsUpdate = true;\n      } else {\n        this.updateDataTexture(\n          paddedScaleRotations,\n          scaleRotationsTextureDesc.texture,\n          scaleRotationsTextureDesc.size,\n          scaleRotationsTextureProps,\n          SCALES_ROTATIONS_ELEMENTS_PER_TEXEL,\n          elementsPerSplat,\n          bytesPerElement,\n          fromSplat,\n          toSplat,\n        );\n      }\n    }\n\n    // update spherical harmonics data texture\n    const shData = this.splatDataTextures.baseData.sphericalHarmonics;\n    if (shData) {\n      let shBytesPerElement = 4;\n      if (shCompressionLevel === 1) shBytesPerElement = 2;\n      else if (shCompressionLevel === 2) shBytesPerElement = 1;\n\n      const updateTexture = (\n        shTexture,\n        shTextureSize,\n        elementsPerTexel,\n        paddedSHArray,\n        paddedSHComponentCount,\n      ) => {\n        const shTextureProps = this.renderer ?\n          this.renderer.properties.get(shTexture) :\n          null;\n        if (!shTextureProps || !shTextureProps.__webglTexture) {\n          shTexture.needsUpdate = true;\n        } else {\n          this.updateDataTexture(\n            paddedSHArray,\n            shTexture,\n            shTextureSize,\n            shTextureProps,\n            elementsPerTexel,\n            paddedSHComponentCount,\n            shBytesPerElement,\n            fromSplat,\n            toSplat,\n          );\n        }\n      };\n\n      const shComponentCount = shTextureDesc.componentCount;\n      const paddedSHComponentCount = shTextureDesc.paddedComponentCount;\n\n      // Update for the case of a single texture for all spherical harmonics data\n      if (shTextureDesc.textureCount === 1) {\n        const paddedSHArray = shTextureDesc.data;\n        for (let c = fromSplat; c <= toSplat; c++) {\n          const srcBase = shComponentCount * c;\n          const destBase = paddedSHComponentCount * c;\n          for (let i = 0; i < shComponentCount; i++) {\n            paddedSHArray[destBase + i] = shData[srcBase + i];\n          }\n        }\n        updateTexture(\n          shTextureDesc.texture,\n          shTextureDesc.size,\n          shTextureDesc.elementsPerTexel,\n          paddedSHArray,\n          paddedSHComponentCount,\n        );\n        // Update for the case of spherical harmonics data split among three textures, one for each color channel\n      } else {\n        const shComponentCountPerChannel =\n          shTextureDesc.componentCountPerChannel;\n        for (let t = 0; t < 3; t++) {\n          const paddedSHArray = shTextureDesc.data[t];\n          for (let c = fromSplat; c <= toSplat; c++) {\n            const srcBase = shComponentCount * c;\n            const destBase = paddedSHComponentCount * c;\n            if (shComponentCountPerChannel >= 3) {\n              for (let i = 0; i < 3; i++) {\n                paddedSHArray[destBase + i] = shData[srcBase + t * 3 + i];\n              }\n              if (shComponentCountPerChannel >= 8) {\n                for (let i = 0; i < 5; i++) {\n                  paddedSHArray[destBase + 3 + i] =\n                    shData[srcBase + 9 + t * 5 + i];\n                }\n              }\n            }\n          }\n          updateTexture(\n            shTextureDesc.textures[t],\n            shTextureDesc.size,\n            shTextureDesc.elementsPerTexel,\n            paddedSHArray,\n            paddedSHComponentCount,\n          );\n        }\n      }\n    }\n\n    // update scene index & transform data\n    const sceneIndexesTexDesc = this.splatDataTextures['sceneIndexes'];\n    const paddedSceneIndexes = sceneIndexesTexDesc.data;\n    for (let c = this.lastBuildSplatCount; c <= toSplat; c++) {\n      paddedSceneIndexes[c] = this.globalSplatIndexToSceneIndexMap[c];\n    }\n    const sceneIndexesTexture = sceneIndexesTexDesc.texture;\n    const sceneIndexesTextureProps = this.renderer ?\n      this.renderer.properties.get(sceneIndexesTexture) :\n      null;\n    if (!sceneIndexesTextureProps || !sceneIndexesTextureProps.__webglTexture) {\n      sceneIndexesTexture.needsUpdate = true;\n    } else {\n      this.updateDataTexture(\n        paddedSceneIndexes,\n        sceneIndexesTexDesc.texture,\n        sceneIndexesTexDesc.size,\n        sceneIndexesTextureProps,\n        1,\n        1,\n        1,\n        this.lastBuildSplatCount,\n        toSplat,\n      );\n    }\n  }\n\n  getTargetCovarianceCompressionLevel() {\n    return this.halfPrecisionCovariancesOnGPU ? 1 : 0;\n  }\n\n  getTargetSphericalHarmonicsCompressionLevel() {\n    return Math.max(1, this.getMaximumSplatBufferCompressionLevel());\n  }\n\n  getMaximumSplatBufferCompressionLevel() {\n    let maxCompressionLevel;\n    for (let i = 0; i < this.scenes.length; i++) {\n      const scene = this.getScene(i);\n      const splatBuffer = scene.splatBuffer;\n      if (i === 0 || splatBuffer.compressionLevel > maxCompressionLevel) {\n        maxCompressionLevel = splatBuffer.compressionLevel;\n      }\n    }\n    return maxCompressionLevel;\n  }\n\n  getMinimumSplatBufferCompressionLevel() {\n    let minCompressionLevel;\n    for (let i = 0; i < this.scenes.length; i++) {\n      const scene = this.getScene(i);\n      const splatBuffer = scene.splatBuffer;\n      if (i === 0 || splatBuffer.compressionLevel < minCompressionLevel) {\n        minCompressionLevel = splatBuffer.compressionLevel;\n      }\n    }\n    return minCompressionLevel;\n  }\n\n  static computeTextureUpdateRegion(\n    startSplat,\n    endSplat,\n    textureWidth,\n    elementsPerTexel,\n    elementsPerSplat,\n  ) {\n    const texelsPerSplat = elementsPerSplat / elementsPerTexel;\n\n    const startSplatTexels = startSplat * texelsPerSplat;\n    const startRow = Math.floor(startSplatTexels / textureWidth);\n    const startRowElement = startRow * textureWidth * elementsPerTexel;\n\n    const endSplatTexels = endSplat * texelsPerSplat;\n    const endRow = Math.floor(endSplatTexels / textureWidth);\n    const endRowEndElement =\n      endRow * textureWidth * elementsPerTexel +\n      textureWidth * elementsPerTexel;\n\n    return {\n      dataStart: startRowElement,\n      dataEnd: endRowEndElement,\n      startRow: startRow,\n      endRow: endRow,\n    };\n  }\n\n  updateDataTexture(\n    paddedData,\n    texture,\n    textureSize,\n    textureProps,\n    elementsPerTexel,\n    elementsPerSplat,\n    bytesPerElement,\n    from,\n    to,\n  ) {\n    const gl = this.renderer.getContext();\n    const updateRegion = SplatMesh.computeTextureUpdateRegion(\n      from,\n      to,\n      textureSize.x,\n      elementsPerTexel,\n      elementsPerSplat,\n    );\n    const updateElementCount = updateRegion.dataEnd - updateRegion.dataStart;\n    const updateDataView = new paddedData.constructor(\n      paddedData.buffer,\n      updateRegion.dataStart * bytesPerElement,\n      updateElementCount,\n    );\n    const updateHeight = updateRegion.endRow - updateRegion.startRow + 1;\n    const glType = this.webGLUtils.convert(texture.type);\n    const glFormat = this.webGLUtils.convert(\n      texture.format,\n      texture.colorSpace,\n    );\n    const currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\n    gl.bindTexture(gl.TEXTURE_2D, textureProps.__webglTexture);\n    gl.texSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      0,\n      updateRegion.startRow,\n      textureSize.x,\n      updateHeight,\n      glFormat,\n      glType,\n      updateDataView,\n    );\n    gl.bindTexture(gl.TEXTURE_2D, currentTexture);\n  }\n\n  static updatePaddedCompressedCovariancesTextureData(\n    sourceData,\n    textureData,\n    textureDataStartIndex,\n    fromElement,\n    toElement,\n  ) {\n    let textureDataView = new DataView(textureData.buffer);\n    let textureDataIndex = textureDataStartIndex;\n    let sequentialCount = 0;\n    for (let i = fromElement; i <= toElement; i += 2) {\n      textureDataView.setUint16(textureDataIndex * 2, sourceData[i], true);\n      textureDataView.setUint16(\n        textureDataIndex * 2 + 2,\n        sourceData[i + 1],\n        true,\n      );\n      textureDataIndex += 2;\n      sequentialCount++;\n      if (sequentialCount >= 3) {\n        textureDataIndex += 2;\n        sequentialCount = 0;\n      }\n    }\n  }\n\n  static updateCenterColorsPaddedData(\n    from,\n    to,\n    centers,\n    colors,\n    paddedCenterColors,\n  ) {\n    for (let c = from; c <= to; c++) {\n      const colorsBase = c * 4;\n      const centersBase = c * 3;\n      const centerColorsBase = c * 4;\n      paddedCenterColors[centerColorsBase] = rgbaArrayToInteger(\n        colors,\n        colorsBase,\n      );\n      paddedCenterColors[centerColorsBase + 1] = uintEncodedFloat(\n        centers[centersBase],\n      );\n      paddedCenterColors[centerColorsBase + 2] = uintEncodedFloat(\n        centers[centersBase + 1],\n      );\n      paddedCenterColors[centerColorsBase + 3] = uintEncodedFloat(\n        centers[centersBase + 2],\n      );\n    }\n  }\n\n  static updateScaleRotationsPaddedData(\n    from,\n    to,\n    scales,\n    rotations,\n    paddedScaleRotations,\n  ) {\n    const combinedSize = 6;\n    for (let c = from; c <= to; c++) {\n      const scaleBase = c * 3;\n      const rotationBase = c * 4;\n      const scaleRotationsBase = c * combinedSize;\n\n      paddedScaleRotations[scaleRotationsBase] = scales[scaleBase];\n      paddedScaleRotations[scaleRotationsBase + 1] = scales[scaleBase + 1];\n      paddedScaleRotations[scaleRotationsBase + 2] = scales[scaleBase + 2];\n\n      paddedScaleRotations[scaleRotationsBase + 3] = rotations[rotationBase];\n      paddedScaleRotations[scaleRotationsBase + 4] =\n        rotations[rotationBase + 1];\n      paddedScaleRotations[scaleRotationsBase + 5] =\n        rotations[rotationBase + 2];\n    }\n  }\n\n  updateVisibleRegion(sinceLastBuildOnly) {\n    const splatCount = this.getSplatCount(true);\n    const tempCenter = new THREE.Vector3();\n    if (!sinceLastBuildOnly) {\n      const avgCenter = new THREE.Vector3();\n      this.scenes.forEach((scene) => {\n        avgCenter.add(scene.splatBuffer.sceneCenter);\n      });\n      avgCenter.multiplyScalar(1.0 / this.scenes.length);\n      this.calculatedSceneCenter.copy(avgCenter);\n      this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter);\n      this.material.uniformsNeedUpdate = true;\n    }\n\n    const startSplatFormMaxDistanceCalc = sinceLastBuildOnly ?\n      this.lastBuildSplatCount :\n      0;\n    for (let i = startSplatFormMaxDistanceCalc; i < splatCount; i++) {\n      this.getSplatCenter(i, tempCenter, true);\n      const distFromCSceneCenter = tempCenter\n        .sub(this.calculatedSceneCenter)\n        .length();\n      if (distFromCSceneCenter > this.maxSplatDistanceFromSceneCenter) {\n        this.maxSplatDistanceFromSceneCenter = distFromCSceneCenter;\n      }\n    }\n\n    if (\n      this.maxSplatDistanceFromSceneCenter - this.visibleRegionBufferRadius >\n      VISIBLE_REGION_EXPANSION_DELTA\n    ) {\n      this.visibleRegionBufferRadius = this.maxSplatDistanceFromSceneCenter;\n      this.visibleRegionRadius = Math.max(\n        this.visibleRegionBufferRadius - VISIBLE_REGION_EXPANSION_DELTA,\n        0.0,\n      );\n    }\n    if (this.finalBuild) {\n      this.visibleRegionRadius = this.visibleRegionBufferRadius =\n        this.maxSplatDistanceFromSceneCenter;\n    }\n    this.updateVisibleRegionFadeDistance();\n  }\n\n  updateVisibleRegionFadeDistance(sceneRevealMode = SceneRevealMode.Default) {\n    const fastFadeRate =\n      SCENE_FADEIN_RATE_FAST * this.sceneFadeInRateMultiplier;\n    const gradualFadeRate =\n      SCENE_FADEIN_RATE_GRADUAL * this.sceneFadeInRateMultiplier;\n    const defaultFadeInRate = this.finalBuild ? fastFadeRate : gradualFadeRate;\n    const fadeInRate =\n      sceneRevealMode === SceneRevealMode.Default ?\n        defaultFadeInRate :\n        gradualFadeRate;\n    this.visibleRegionFadeStartRadius =\n      (this.visibleRegionRadius - this.visibleRegionFadeStartRadius) *\n        fadeInRate +\n      this.visibleRegionFadeStartRadius;\n    const fadeInPercentage =\n      this.visibleRegionBufferRadius > 0 ?\n        this.visibleRegionFadeStartRadius / this.visibleRegionBufferRadius :\n        0;\n    const fadeInComplete = fadeInPercentage > 0.99;\n    const shaderFadeInComplete =\n      fadeInComplete || sceneRevealMode === SceneRevealMode.Instant ? 1 : 0;\n\n    this.material.uniforms.visibleRegionFadeStartRadius.value =\n      this.visibleRegionFadeStartRadius;\n    this.material.uniforms.visibleRegionRadius.value = this.visibleRegionRadius;\n    this.material.uniforms.firstRenderTime.value = this.firstRenderTime;\n    this.material.uniforms.currentTime.value = performance.now();\n    this.material.uniforms.fadeInComplete.value = shaderFadeInComplete;\n    this.material.uniformsNeedUpdate = true;\n    this.visibleRegionChanging = !fadeInComplete;\n  }\n\n  /**\n   * Set the indexes of splats that should be rendered; should be sorted in desired render order.\n   * @param {Uint32Array} globalIndexes Sorted index list of splats to be rendered\n   * @param {number} renderSplatCount Total number of splats to be rendered. Necessary because we may not want to render\n   *                                  every splat.\n   */\n  updateRenderIndexes(globalIndexes, renderSplatCount) {\n    const geometry = this.geometry;\n    geometry.attributes.splatIndex.set(globalIndexes);\n    geometry.attributes.splatIndex.needsUpdate = true;\n    if (renderSplatCount > 0 && this.firstRenderTime === -1) {\n      this.firstRenderTime = performance.now();\n    }\n    geometry.instanceCount = renderSplatCount;\n    geometry.setDrawRange(0, renderSplatCount);\n  }\n\n  /**\n   * Update the transforms for each scene in this splat mesh from their individual components (position,\n   * quaternion, and scale)\n   */\n  updateTransforms() {\n    for (let i = 0; i < this.scenes.length; i++) {\n      const scene = this.getScene(i);\n      scene.updateTransform(this.dynamicMode);\n    }\n  }\n\n  updateUniforms = (function() {\n    const viewport = new THREE.Vector2();\n\n    return function(\n      renderDimensions,\n      cameraFocalLengthX,\n      cameraFocalLengthY,\n      orthographicMode,\n      orthographicZoom,\n      inverseFocalAdjustment,\n    ) {\n      const splatCount = this.getSplatCount();\n      if (splatCount > 0) {\n        viewport.set(\n          renderDimensions.x * this.devicePixelRatio,\n          renderDimensions.y * this.devicePixelRatio,\n        );\n        this.material.uniforms.viewport.value.copy(viewport);\n        this.material.uniforms.basisViewport.value.set(\n          1.0 / viewport.x,\n          1.0 / viewport.y,\n        );\n        this.material.uniforms.focal.value.set(\n          cameraFocalLengthX,\n          cameraFocalLengthY,\n        );\n        this.material.uniforms.orthographicMode.value = orthographicMode ?\n          1 :\n          0;\n        this.material.uniforms.orthoZoom.value = orthographicZoom;\n        this.material.uniforms.inverseFocalAdjustment.value =\n          inverseFocalAdjustment;\n        if (this.dynamicMode) {\n          for (let i = 0; i < this.scenes.length; i++) {\n            this.material.uniforms.transforms.value[i].copy(\n              this.getScene(i).transform,\n            );\n          }\n        }\n        if (this.enableOptionalEffects) {\n          for (let i = 0; i < this.scenes.length; i++) {\n            this.material.uniforms.sceneOpacity.value[i] = clamp(\n              this.getScene(i).opacity,\n              0.0,\n              1.0,\n            );\n            this.material.uniforms.sceneVisibility.value[i] = this.getScene(i)\n              .visible ?\n              1 :\n              0;\n            this.material.uniformsNeedUpdate = true;\n          }\n        }\n        this.material.uniformsNeedUpdate = true;\n      }\n    };\n  })();\n\n  setSplatScale(splatScale = 1) {\n    this.splatScale = splatScale;\n    this.material.uniforms.splatScale.value = splatScale;\n    this.material.uniformsNeedUpdate = true;\n  }\n\n  getSplatScale() {\n    return this.splatScale;\n  }\n\n  setPointCloudModeEnabled(enabled) {\n    this.pointCloudModeEnabled = enabled;\n    this.material.uniforms.pointCloudModeEnabled.value = enabled ? 1 : 0;\n    this.material.uniformsNeedUpdate = true;\n  }\n\n  getPointCloudModeEnabled() {\n    return this.pointCloudModeEnabled;\n  }\n\n  getSplatDataTextures() {\n    return this.splatDataTextures;\n  }\n\n  getSplatCount(includeSinceLastBuild = false) {\n    if (!includeSinceLastBuild) return this.lastBuildSplatCount;\n    else return SplatMesh.getTotalSplatCountForScenes(this.scenes);\n  }\n\n  static getTotalSplatCountForScenes(scenes) {\n    let totalSplatCount = 0;\n    for (let scene of scenes) {\n      if (scene && scene.splatBuffer) {\n        totalSplatCount += scene.splatBuffer.getSplatCount();\n      }\n    }\n    return totalSplatCount;\n  }\n\n  static getTotalSplatCountForSplatBuffers(splatBuffers) {\n    let totalSplatCount = 0;\n    for (let splatBuffer of splatBuffers) {\n      totalSplatCount += splatBuffer.getSplatCount();\n    }\n    return totalSplatCount;\n  }\n\n  getMaxSplatCount() {\n    return SplatMesh.getTotalMaxSplatCountForScenes(this.scenes);\n  }\n\n  static getTotalMaxSplatCountForScenes(scenes) {\n    let totalSplatCount = 0;\n    for (let scene of scenes) {\n      if (scene && scene.splatBuffer) {\n        totalSplatCount += scene.splatBuffer.getMaxSplatCount();\n      }\n    }\n    return totalSplatCount;\n  }\n\n  static getTotalMaxSplatCountForSplatBuffers(splatBuffers) {\n    let totalSplatCount = 0;\n    for (let splatBuffer of splatBuffers) {\n      totalSplatCount += splatBuffer.getMaxSplatCount();\n    }\n    return totalSplatCount;\n  }\n\n  disposeDistancesComputationGPUResources() {\n    if (!this.renderer) return;\n\n    const gl = this.renderer.getContext();\n\n    if (this.distancesTransformFeedback.vao) {\n      gl.deleteVertexArray(this.distancesTransformFeedback.vao);\n      this.distancesTransformFeedback.vao = null;\n    }\n    if (this.distancesTransformFeedback.program) {\n      gl.deleteProgram(this.distancesTransformFeedback.program);\n      gl.deleteShader(this.distancesTransformFeedback.vertexShader);\n      gl.deleteShader(this.distancesTransformFeedback.fragmentShader);\n      this.distancesTransformFeedback.program = null;\n      this.distancesTransformFeedback.vertexShader = null;\n      this.distancesTransformFeedback.fragmentShader = null;\n    }\n    this.disposeDistancesComputationGPUBufferResources();\n    if (this.distancesTransformFeedback.id) {\n      gl.deleteTransformFeedback(this.distancesTransformFeedback.id);\n      this.distancesTransformFeedback.id = null;\n    }\n  }\n\n  disposeDistancesComputationGPUBufferResources() {\n    if (!this.renderer) return;\n\n    const gl = this.renderer.getContext();\n\n    if (this.distancesTransformFeedback.centersBuffer) {\n      this.distancesTransformFeedback.centersBuffer = null;\n      gl.deleteBuffer(this.distancesTransformFeedback.centersBuffer);\n    }\n    if (this.distancesTransformFeedback.outDistancesBuffer) {\n      gl.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer);\n      this.distancesTransformFeedback.outDistancesBuffer = null;\n    }\n  }\n\n  /**\n   * Set the Three.js renderer used by this splat mesh\n   * @param {THREE.WebGLRenderer} renderer Instance of THREE.WebGLRenderer\n   */\n  setRenderer(renderer) {\n    if (renderer !== this.renderer) {\n      this.renderer = renderer;\n      const gl = this.renderer.getContext();\n      const extensions = new WebGLExtensions(gl);\n      const capabilities = new WebGLCapabilities(gl, extensions, {});\n      extensions.init(capabilities);\n      this.webGLUtils = new THREE.WebGLUtils(gl, extensions, capabilities);\n      if (this.enableDistancesComputationOnGPU && this.getSplatCount() > 0) {\n        this.setupDistancesComputationTransformFeedback();\n        const { centers, sceneIndexes } = this.getDataForDistancesComputation(\n          0,\n          this.getSplatCount() - 1,\n        );\n        this.refreshGPUBuffersForDistancesComputation(centers, sceneIndexes);\n      }\n    }\n  }\n\n  setupDistancesComputationTransformFeedback = (function() {\n    let currentMaxSplatCount;\n\n    return function() {\n      const maxSplatCount = this.getMaxSplatCount();\n\n      if (!this.renderer) return;\n\n      const rebuildGPUObjects = this.lastRenderer !== this.renderer;\n      const rebuildBuffers = currentMaxSplatCount !== maxSplatCount;\n\n      if (!rebuildGPUObjects && !rebuildBuffers) return;\n\n      if (rebuildGPUObjects) {\n        this.disposeDistancesComputationGPUResources();\n      } else if (rebuildBuffers) {\n        this.disposeDistancesComputationGPUBufferResources();\n      }\n\n      const gl = this.renderer.getContext();\n\n      const createShader = (gl, type, source) => {\n        const shader = gl.createShader(type);\n        if (!shader) {\n          console.error('Fatal error: gl could not create a shader object.');\n          return null;\n        }\n\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n        if (!compiled) {\n          let typeName = 'unknown';\n          if (type === gl.VERTEX_SHADER) typeName = 'vertex shader';\n          else if (type === gl.FRAGMENT_SHADER) typeName = 'fragement shader';\n          const errors = gl.getShaderInfoLog(shader);\n          console.error(\n            'Failed to compile ' + typeName + ' with these errors:' + errors,\n          );\n          gl.deleteShader(shader);\n          return null;\n        }\n\n        return shader;\n      };\n\n      let vsSource;\n      if (this.integerBasedDistancesComputation) {\n        vsSource = `#version 300 es\n                in ivec4 center;\n                flat out int distance;`;\n        if (this.dynamicMode) {\n          vsSource += `\n                        in uint sceneIndex;\n                        uniform ivec4 transforms[${Constants.MaxScenes}];\n                        void main(void) {\n                            ivec4 transform = transforms[sceneIndex];\n                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;\n                        }\n                    `;\n        } else {\n          vsSource += `\n                        uniform ivec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    `;\n        }\n      } else {\n        vsSource = `#version 300 es\n                in vec4 center;\n                flat out float distance;`;\n        if (this.dynamicMode) {\n          vsSource += `\n                        in uint sceneIndex;\n                        uniform mat4 transforms[${Constants.MaxScenes}];\n                        void main(void) {\n                            vec4 transformedCenter = transforms[sceneIndex] * vec4(center.xyz, 1.0);\n                            distance = transformedCenter.z;\n                        }\n                    `;\n        } else {\n          vsSource += `\n                        uniform vec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    `;\n        }\n      }\n\n      const fsSource = `#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            `;\n\n      const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n      const currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n      const currentProgramDeleted = currentProgram ?\n        gl.getProgramParameter(currentProgram, gl.DELETE_STATUS) :\n        false;\n\n      if (rebuildGPUObjects) {\n        this.distancesTransformFeedback.vao = gl.createVertexArray();\n      }\n\n      gl.bindVertexArray(this.distancesTransformFeedback.vao);\n\n      if (rebuildGPUObjects) {\n        const program = gl.createProgram();\n        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);\n        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);\n        if (!vertexShader || !fragmentShader) {\n          throw new Error(\n            'Could not compile shaders for distances computation on GPU.',\n          );\n        }\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.transformFeedbackVaryings(\n          program,\n          ['distance'],\n          gl.SEPARATE_ATTRIBS,\n        );\n        gl.linkProgram(program);\n\n        const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n        if (!linked) {\n          const error = gl.getProgramInfoLog(program);\n          console.error('Fatal error: Failed to link program: ' + error);\n          gl.deleteProgram(program);\n          gl.deleteShader(fragmentShader);\n          gl.deleteShader(vertexShader);\n          throw new Error(\n            'Could not link shaders for distances computation on GPU.',\n          );\n        }\n\n        this.distancesTransformFeedback.program = program;\n        this.distancesTransformFeedback.vertexShader = vertexShader;\n        this.distancesTransformFeedback.vertexShader = fragmentShader;\n      }\n\n      gl.useProgram(this.distancesTransformFeedback.program);\n\n      this.distancesTransformFeedback.centersLoc = gl.getAttribLocation(\n        this.distancesTransformFeedback.program,\n        'center',\n      );\n      if (this.dynamicMode) {\n        this.distancesTransformFeedback.sceneIndexesLoc = gl.getAttribLocation(\n          this.distancesTransformFeedback.program,\n          'sceneIndex',\n        );\n        for (let i = 0; i < this.scenes.length; i++) {\n          this.distancesTransformFeedback.transformsLocs[i] =\n            gl.getUniformLocation(\n              this.distancesTransformFeedback.program,\n              `transforms[${i}]`,\n            );\n        }\n      } else {\n        this.distancesTransformFeedback.modelViewProjLoc =\n          gl.getUniformLocation(\n            this.distancesTransformFeedback.program,\n            'modelViewProj',\n          );\n      }\n\n      if (rebuildGPUObjects || rebuildBuffers) {\n        this.distancesTransformFeedback.centersBuffer = gl.createBuffer();\n        gl.bindBuffer(\n          gl.ARRAY_BUFFER,\n          this.distancesTransformFeedback.centersBuffer,\n        );\n        gl.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc);\n        if (this.integerBasedDistancesComputation) {\n          gl.vertexAttribIPointer(\n            this.distancesTransformFeedback.centersLoc,\n            4,\n            gl.INT,\n            0,\n            0,\n          );\n        } else {\n          gl.vertexAttribPointer(\n            this.distancesTransformFeedback.centersLoc,\n            4,\n            gl.FLOAT,\n            false,\n            0,\n            0,\n          );\n        }\n\n        if (this.dynamicMode) {\n          this.distancesTransformFeedback.sceneIndexesBuffer =\n            gl.createBuffer();\n          gl.bindBuffer(\n            gl.ARRAY_BUFFER,\n            this.distancesTransformFeedback.sceneIndexesBuffer,\n          );\n          gl.enableVertexAttribArray(\n            this.distancesTransformFeedback.sceneIndexesLoc,\n          );\n          gl.vertexAttribIPointer(\n            this.distancesTransformFeedback.sceneIndexesLoc,\n            1,\n            gl.UNSIGNED_INT,\n            0,\n            0,\n          );\n        }\n      }\n\n      if (rebuildGPUObjects || rebuildBuffers) {\n        this.distancesTransformFeedback.outDistancesBuffer = gl.createBuffer();\n      }\n      gl.bindBuffer(\n        gl.ARRAY_BUFFER,\n        this.distancesTransformFeedback.outDistancesBuffer,\n      );\n      gl.bufferData(gl.ARRAY_BUFFER, maxSplatCount * 4, gl.STATIC_READ);\n\n      if (rebuildGPUObjects) {\n        this.distancesTransformFeedback.id = gl.createTransformFeedback();\n      }\n      gl.bindTransformFeedback(\n        gl.TRANSFORM_FEEDBACK,\n        this.distancesTransformFeedback.id,\n      );\n      gl.bindBufferBase(\n        gl.TRANSFORM_FEEDBACK_BUFFER,\n        0,\n        this.distancesTransformFeedback.outDistancesBuffer,\n      );\n\n      if (currentProgram && currentProgramDeleted !== true) {\n        gl.useProgram(currentProgram);\n      }\n      if (currentVao) gl.bindVertexArray(currentVao);\n\n      this.lastRenderer = this.renderer;\n      currentMaxSplatCount = maxSplatCount;\n    };\n  })();\n\n  /**\n   * Refresh GPU buffers used for computing splat distances with centers data from the scenes for this mesh.\n   * @param {boolean} isUpdate Specify whether or not to update the GPU buffer or to initialize & fill\n   * @param {Array<number>} centers The splat centers data\n   * @param {number} offsetSplats Offset in the GPU buffer at which to start updating data, specified in splats\n   */\n  updateGPUCentersBufferForDistancesComputation(\n    isUpdate,\n    centers,\n    offsetSplats,\n  ) {\n    if (!this.renderer) return;\n\n    const gl = this.renderer.getContext();\n\n    const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n    gl.bindVertexArray(this.distancesTransformFeedback.vao);\n\n    const ArrayType = this.integerBasedDistancesComputation ?\n      Uint32Array :\n      Float32Array;\n    const attributeBytesPerCenter = 16;\n    const subBufferOffset = offsetSplats * attributeBytesPerCenter;\n\n    gl.bindBuffer(\n      gl.ARRAY_BUFFER,\n      this.distancesTransformFeedback.centersBuffer,\n    );\n\n    if (isUpdate) {\n      gl.bufferSubData(gl.ARRAY_BUFFER, subBufferOffset, centers);\n    } else {\n      const maxArray = new ArrayType(\n        this.getMaxSplatCount() * attributeBytesPerCenter,\n      );\n      maxArray.set(centers);\n      gl.bufferData(gl.ARRAY_BUFFER, maxArray, gl.STATIC_DRAW);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n    if (currentVao) gl.bindVertexArray(currentVao);\n  }\n\n  /**\n   * Refresh GPU buffers used for pre-computing splat distances with centers data from the scenes for this mesh.\n   * @param {boolean} isUpdate Specify whether or not to update the GPU buffer or to initialize & fill\n   * @param {Array<number>} sceneIndexes The splat scene indexes\n   * @param {number} offsetSplats Offset in the GPU buffer at which to start updating data, specified in splats\n   */\n  updateGPUTransformIndexesBufferForDistancesComputation(\n    isUpdate,\n    sceneIndexes,\n    offsetSplats,\n  ) {\n    if (!this.renderer || !this.dynamicMode) return;\n\n    const gl = this.renderer.getContext();\n\n    const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n    gl.bindVertexArray(this.distancesTransformFeedback.vao);\n\n    const subBufferOffset = offsetSplats * 4;\n\n    gl.bindBuffer(\n      gl.ARRAY_BUFFER,\n      this.distancesTransformFeedback.sceneIndexesBuffer,\n    );\n\n    if (isUpdate) {\n      gl.bufferSubData(gl.ARRAY_BUFFER, subBufferOffset, sceneIndexes);\n    } else {\n      const maxArray = new Uint32Array(this.getMaxSplatCount() * 4);\n      maxArray.set(sceneIndexes);\n      gl.bufferData(gl.ARRAY_BUFFER, maxArray, gl.STATIC_DRAW);\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n    if (currentVao) gl.bindVertexArray(currentVao);\n  }\n\n  /**\n   * Get a typed array containing a mapping from global splat indexes to their scene index.\n   * @param {number} start Starting splat index to store\n   * @param {number} end Ending splat index to store\n   * @return {Uint32Array}\n   */\n  getSceneIndexes(start, end) {\n    let sceneIndexes;\n    const fillCount = end - start + 1;\n    sceneIndexes = new Uint32Array(fillCount);\n    for (let i = start; i <= end; i++) {\n      sceneIndexes[i] = this.globalSplatIndexToSceneIndexMap[i];\n    }\n\n    return sceneIndexes;\n  }\n\n  /**\n   * Fill 'array' with the transforms for each scene in this splat mesh.\n   * @param {Array} array Empty array to be filled with scene transforms. If not empty, contents will be overwritten.\n   */\n  fillTransformsArray = (function() {\n    const tempArray = [];\n\n    return function(array) {\n      if (tempArray.length !== array.length) tempArray.length = array.length;\n      for (let i = 0; i < this.scenes.length; i++) {\n        const sceneTransform = this.getScene(i).transform;\n        const sceneTransformElements = sceneTransform.elements;\n        for (let j = 0; j < 16; j++) {\n          tempArray[i * 16 + j] = sceneTransformElements[j];\n        }\n      }\n      array.set(tempArray);\n    };\n  })();\n\n  computeDistancesOnGPU = (function() {\n    const tempMatrix = new THREE.Matrix4();\n\n    return function(modelViewProjMatrix, outComputedDistances) {\n      if (!this.renderer) return;\n\n      // console.time(\"gpu_compute_distances\");\n      const gl = this.renderer.getContext();\n\n      const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n      const currentProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n      const currentProgramDeleted = currentProgram ?\n        gl.getProgramParameter(currentProgram, gl.DELETE_STATUS) :\n        false;\n\n      gl.bindVertexArray(this.distancesTransformFeedback.vao);\n      gl.useProgram(this.distancesTransformFeedback.program);\n\n      gl.enable(gl.RASTERIZER_DISCARD);\n\n      if (this.dynamicMode) {\n        for (let i = 0; i < this.scenes.length; i++) {\n          tempMatrix.copy(this.getScene(i).transform);\n          tempMatrix.premultiply(modelViewProjMatrix);\n\n          if (this.integerBasedDistancesComputation) {\n            const iTempMatrix = SplatMesh.getIntegerMatrixArray(tempMatrix);\n            const iTransform = [\n              iTempMatrix[2],\n              iTempMatrix[6],\n              iTempMatrix[10],\n              iTempMatrix[14],\n            ];\n            gl.uniform4i(\n              this.distancesTransformFeedback.transformsLocs[i],\n              iTransform[0],\n              iTransform[1],\n              iTransform[2],\n              iTransform[3],\n            );\n          } else {\n            gl.uniformMatrix4fv(\n              this.distancesTransformFeedback.transformsLocs[i],\n              false,\n              tempMatrix.elements,\n            );\n          }\n        }\n      } else {\n        if (this.integerBasedDistancesComputation) {\n          const iViewProjMatrix =\n            SplatMesh.getIntegerMatrixArray(modelViewProjMatrix);\n          const iViewProj = [\n            iViewProjMatrix[2],\n            iViewProjMatrix[6],\n            iViewProjMatrix[10],\n          ];\n          gl.uniform3i(\n            this.distancesTransformFeedback.modelViewProjLoc,\n            iViewProj[0],\n            iViewProj[1],\n            iViewProj[2],\n          );\n        } else {\n          const viewProj = [\n            modelViewProjMatrix.elements[2],\n            modelViewProjMatrix.elements[6],\n            modelViewProjMatrix.elements[10],\n          ];\n          gl.uniform3f(\n            this.distancesTransformFeedback.modelViewProjLoc,\n            viewProj[0],\n            viewProj[1],\n            viewProj[2],\n          );\n        }\n      }\n\n      gl.bindBuffer(\n        gl.ARRAY_BUFFER,\n        this.distancesTransformFeedback.centersBuffer,\n      );\n      gl.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc);\n      if (this.integerBasedDistancesComputation) {\n        gl.vertexAttribIPointer(\n          this.distancesTransformFeedback.centersLoc,\n          4,\n          gl.INT,\n          0,\n          0,\n        );\n      } else {\n        gl.vertexAttribPointer(\n          this.distancesTransformFeedback.centersLoc,\n          4,\n          gl.FLOAT,\n          false,\n          0,\n          0,\n        );\n      }\n\n      if (this.dynamicMode) {\n        gl.bindBuffer(\n          gl.ARRAY_BUFFER,\n          this.distancesTransformFeedback.sceneIndexesBuffer,\n        );\n        gl.enableVertexAttribArray(\n          this.distancesTransformFeedback.sceneIndexesLoc,\n        );\n        gl.vertexAttribIPointer(\n          this.distancesTransformFeedback.sceneIndexesLoc,\n          1,\n          gl.UNSIGNED_INT,\n          0,\n          0,\n        );\n      }\n\n      gl.bindTransformFeedback(\n        gl.TRANSFORM_FEEDBACK,\n        this.distancesTransformFeedback.id,\n      );\n      gl.bindBufferBase(\n        gl.TRANSFORM_FEEDBACK_BUFFER,\n        0,\n        this.distancesTransformFeedback.outDistancesBuffer,\n      );\n\n      gl.beginTransformFeedback(gl.POINTS);\n      gl.drawArrays(gl.POINTS, 0, this.getSplatCount());\n      gl.endTransformFeedback();\n\n      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);\n      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\n      gl.disable(gl.RASTERIZER_DISCARD);\n\n      const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      const promise = new Promise((resolve) => {\n        const checkSync = () => {\n          if (this.disposed) {\n            resolve();\n          } else {\n            const timeout = 0;\n            const bitflags = 0;\n            const status = gl.clientWaitSync(sync, bitflags, timeout);\n            switch (status) {\n              case gl.TIMEOUT_EXPIRED:\n                this.computeDistancesOnGPUSyncTimeout = setTimeout(checkSync);\n                return this.computeDistancesOnGPUSyncTimeout;\n              case gl.WAIT_FAILED:\n                throw new Error('should never get here');\n              default:\n                this.computeDistancesOnGPUSyncTimeout = null;\n                gl.deleteSync(sync);\n                const currentVao = gl.getParameter(gl.VERTEX_ARRAY_BINDING);\n                gl.bindVertexArray(this.distancesTransformFeedback.vao);\n                gl.bindBuffer(\n                  gl.ARRAY_BUFFER,\n                  this.distancesTransformFeedback.outDistancesBuffer,\n                );\n                gl.getBufferSubData(gl.ARRAY_BUFFER, 0, outComputedDistances);\n                gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n                if (currentVao) gl.bindVertexArray(currentVao);\n\n                // console.timeEnd(\"gpu_compute_distances\");\n\n                resolve();\n            }\n          }\n        };\n        this.computeDistancesOnGPUSyncTimeout = setTimeout(checkSync);\n      });\n\n      if (currentProgram && currentProgramDeleted !== true) {\n        gl.useProgram(currentProgram);\n      }\n      if (currentVao) gl.bindVertexArray(currentVao);\n\n      return promise;\n    };\n  })();\n\n  /**\n   * Given a global splat index, return corresponding local data (splat buffer, index of splat in that splat\n   * buffer, and the corresponding transform)\n   * @param {number} globalIndex Global splat index\n   * @param {object} paramsObj Object in which to store local data\n   * @param {boolean} returnSceneTransform By default, the transform of the scene to which the splat at 'globalIndex' belongs will be\n   *                                       returned via the 'sceneTransform' property of 'paramsObj' only if the splat mesh is static.\n   *                                       If 'returnSceneTransform' is true, the 'sceneTransform' property will always contain the scene\n   *                                       transform, and if 'returnSceneTransform' is false, the 'sceneTransform' property will always\n   *                                       be null.\n   */\n  getLocalSplatParameters(globalIndex, paramsObj, returnSceneTransform) {\n    if (returnSceneTransform === undefined || returnSceneTransform === null) {\n      returnSceneTransform = this.dynamicMode ? false : true;\n    }\n    paramsObj.splatBuffer = this.getSplatBufferForSplat(globalIndex);\n    paramsObj.localIndex = this.getSplatLocalIndex(globalIndex);\n    paramsObj.sceneTransform = returnSceneTransform ?\n      this.getSceneTransformForSplat(globalIndex) :\n      null;\n  }\n\n  /**\n   * Fill arrays with splat data and apply transforms if appropriate. Each array is optional.\n   * @param {Float32Array} covariances Target storage for splat covariances\n   * @param {Float32Array} scales Target storage for splat scales\n   * @param {Float32Array} rotations Target storage for splat rotations\n   * @param {Float32Array} centers Target storage for splat centers\n   * @param {Uint8Array} colors Target storage for splat colors\n   * @param {Float32Array} sphericalHarmonics Target storage for spherical harmonics\n   * @param {boolean} applySceneTransform By default, scene transforms are applied to relevant splat data only if the splat mesh is\n   *                                      static. If 'applySceneTransform' is true, scene transforms will always be applied and if\n   *                                      it is false, they will never be applied. If undefined, the default behavior will apply.\n   * @param {number} covarianceCompressionLevel The compression level for covariances in the destination array\n   * @param {number} sphericalHarmonicsCompressionLevel The compression level for spherical harmonics in the destination array\n   * @param {number} srcStart The start location from which to pull source data\n   * @param {number} srcEnd The end location from which to pull source data\n   * @param {number} destStart The start location from which to write data\n   */\n  fillSplatDataArrays(\n    covariances,\n    scales,\n    rotations,\n    centers,\n    colors,\n    sphericalHarmonics,\n    applySceneTransform,\n    covarianceCompressionLevel = 0,\n    scaleRotationCompressionLevel = 0,\n    sphericalHarmonicsCompressionLevel = 1,\n    srcStart,\n    srcEnd,\n    destStart = 0,\n    sceneIndex,\n  ) {\n    const scaleOverride = new THREE.Vector3();\n    scaleOverride.x = undefined;\n    scaleOverride.y = undefined;\n    if (this.splatRenderMode === SplatRenderMode.ThreeD) {\n      scaleOverride.z = undefined;\n    } else {\n      scaleOverride.z = 1;\n    }\n    const tempTransform = new THREE.Matrix4();\n\n    let startSceneIndex = 0;\n    let endSceneIndex = this.scenes.length - 1;\n    if (\n      sceneIndex !== undefined &&\n      sceneIndex !== null &&\n      sceneIndex >= 0 &&\n      sceneIndex <= this.scenes.length\n    ) {\n      startSceneIndex = sceneIndex;\n      endSceneIndex = sceneIndex;\n    }\n    for (let i = startSceneIndex; i <= endSceneIndex; i++) {\n      if (applySceneTransform === undefined || applySceneTransform === null) {\n        applySceneTransform = this.dynamicMode ? false : true;\n      }\n\n      const scene = this.getScene(i);\n      const splatBuffer = scene.splatBuffer;\n      let sceneTransform;\n      if (applySceneTransform) {\n        this.getSceneTransform(i, tempTransform);\n        sceneTransform = tempTransform;\n      }\n      if (covariances) {\n        splatBuffer.fillSplatCovarianceArray(\n          covariances,\n          sceneTransform,\n          srcStart,\n          srcEnd,\n          destStart,\n          covarianceCompressionLevel,\n        );\n      }\n      if (scales || rotations) {\n        if (!scales || !rotations) {\n          throw new Error(\n            'SplatMesh::fillSplatDataArrays() -> \"scales\" and \"rotations\" must both be valid.',\n          );\n        }\n        splatBuffer.fillSplatScaleRotationArray(\n          scales,\n          rotations,\n          sceneTransform,\n          srcStart,\n          srcEnd,\n          destStart,\n          scaleRotationCompressionLevel,\n          scaleOverride,\n        );\n      }\n      if (centers) {\n        splatBuffer.fillSplatCenterArray(\n          centers,\n          sceneTransform,\n          srcStart,\n          srcEnd,\n          destStart,\n        );\n      }\n      if (colors) {\n        splatBuffer.fillSplatColorArray(\n          colors,\n          scene.minimumAlpha,\n          srcStart,\n          srcEnd,\n          destStart,\n        );\n      }\n      if (sphericalHarmonics) {\n        splatBuffer.fillSphericalHarmonicsArray(\n          sphericalHarmonics,\n          this.minSphericalHarmonicsDegree,\n          sceneTransform,\n          srcStart,\n          srcEnd,\n          destStart,\n          sphericalHarmonicsCompressionLevel,\n        );\n      }\n      destStart += splatBuffer.getSplatCount();\n    }\n  }\n\n  /**\n   * Convert splat centers, which are floating point values, to an array of integers and multiply\n   * each by 1000. Centers will get transformed as appropriate before conversion to integer.\n   * @param {number} start The index at which to start retrieving data\n   * @param {number} end The index at which to stop retrieving data\n   * @param {boolean} padFour Enforce alignment of 4 by inserting a 1 after every 3 values\n   * @return {Int32Array}\n   */\n  getIntegerCenters(start, end, padFour = false) {\n    const splatCount = end - start + 1;\n    const floatCenters = new Float32Array(splatCount * 3);\n    this.fillSplatDataArrays(\n      null,\n      null,\n      null,\n      floatCenters,\n      null,\n      null,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      start,\n    );\n    let intCenters;\n    let componentCount = padFour ? 4 : 3;\n    intCenters = new Int32Array(splatCount * componentCount);\n    for (let i = 0; i < splatCount; i++) {\n      for (let t = 0; t < 3; t++) {\n        intCenters[i * componentCount + t] = Math.round(\n          floatCenters[i * 3 + t] * 1000.0,\n        );\n      }\n      if (padFour) intCenters[i * componentCount + 3] = 1000;\n    }\n    return intCenters;\n  }\n\n  /**\n   * Returns an array of splat centers, transformed as appropriate, optionally padded.\n   * @param {number} start The index at which to start retrieving data\n   * @param {number} end The index at which to stop retrieving data\n   * @param {boolean} padFour Enforce alignment of 4 by inserting a 1 after every 3 values\n   * @return {Float32Array}\n   */\n  getFloatCenters(start, end, padFour = false) {\n    const splatCount = end - start + 1;\n    const floatCenters = new Float32Array(splatCount * 3);\n    this.fillSplatDataArrays(\n      null,\n      null,\n      null,\n      floatCenters,\n      null,\n      null,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      start,\n    );\n    if (!padFour) return floatCenters;\n    let paddedFloatCenters = new Float32Array(splatCount * 4);\n    for (let i = 0; i < splatCount; i++) {\n      for (let t = 0; t < 3; t++) {\n        paddedFloatCenters[i * 4 + t] = floatCenters[i * 3 + t];\n      }\n      paddedFloatCenters[i * 4 + 3] = 1.0;\n    }\n    return paddedFloatCenters;\n  }\n\n  /**\n   * Get the center for a splat, transformed as appropriate.\n   * @param {number} globalIndex Global index of splat\n   * @param {THREE.Vector3} outCenter THREE.Vector3 instance in which to store splat center\n   * @param {boolean} applySceneTransform By default, if the splat mesh is static, the transform of the scene to which the splat at\n   *                                      'globalIndex' belongs will be applied to the splat center. If 'applySceneTransform' is true,\n   *                                      the scene transform will always be applied and if 'applySceneTransform' is false, the\n   *                                      scene transform will never be applied. If undefined, the default behavior will apply.\n   */\n  getSplatCenter = (function() {\n    const paramsObj = {};\n\n    return function(globalIndex, outCenter, applySceneTransform) {\n      this.getLocalSplatParameters(globalIndex, paramsObj, applySceneTransform);\n      paramsObj.splatBuffer.getSplatCenter(\n        paramsObj.localIndex,\n        outCenter,\n        paramsObj.sceneTransform,\n      );\n    };\n  })();\n\n  /**\n   * Get the scale and rotation for a splat, transformed as appropriate.\n   * @param {number} globalIndex Global index of splat\n   * @param {THREE.Vector3} outScale THREE.Vector3 instance in which to store splat scale\n   * @param {THREE.Quaternion} outRotation THREE.Quaternion instance in which to store splat rotation\n   * @param {boolean} applySceneTransform By default, if the splat mesh is static, the transform of the scene to which the splat at\n   *                                      'globalIndex' belongs will be applied to the splat scale and rotation. If\n   *                                      'applySceneTransform' is true, the scene transform will always be applied and if\n   *                                      'applySceneTransform' is false, the scene transform will never be applied. If undefined,\n   *                                      the default behavior will apply.\n   */\n  getSplatScaleAndRotation = (function() {\n    const paramsObj = {};\n    const scaleOverride = new THREE.Vector3();\n\n    return function(globalIndex, outScale, outRotation, applySceneTransform) {\n      this.getLocalSplatParameters(globalIndex, paramsObj, applySceneTransform);\n      scaleOverride.x = undefined;\n      scaleOverride.y = undefined;\n      scaleOverride.z = undefined;\n      if (this.splatRenderMode === SplatRenderMode.TwoD) scaleOverride.z = 0;\n      paramsObj.splatBuffer.getSplatScaleAndRotation(\n        paramsObj.localIndex,\n        outScale,\n        outRotation,\n        paramsObj.sceneTransform,\n        scaleOverride,\n      );\n    };\n  })();\n\n  /**\n   * Get the color for a splat.\n   * @param {number} globalIndex Global index of splat\n   * @param {THREE.Vector4} outColor THREE.Vector4 instance in which to store splat color\n   */\n  getSplatColor = (function() {\n    const paramsObj = {};\n\n    return function(globalIndex, outColor) {\n      this.getLocalSplatParameters(globalIndex, paramsObj);\n      paramsObj.splatBuffer.getSplatColor(paramsObj.localIndex, outColor);\n    };\n  })();\n\n  /**\n   * Store the transform of the scene at 'sceneIndex' in 'outTransform'.\n   * @param {number} sceneIndex Index of the desired scene\n   * @param {THREE.Matrix4} outTransform Instance of THREE.Matrix4 in which to store the scene's transform\n   */\n  getSceneTransform(sceneIndex, outTransform) {\n    const scene = this.getScene(sceneIndex);\n    scene.updateTransform(this.dynamicMode);\n    outTransform.copy(scene.transform);\n  }\n\n  /**\n   * Get the scene at 'sceneIndex'.\n   * @param {number} sceneIndex Index of the desired scene\n   * @return {SplatScene}\n   */\n  getScene(sceneIndex) {\n    if (sceneIndex < 0 || sceneIndex >= this.scenes.length) {\n      throw new Error('SplatMesh::getScene() -> Invalid scene index.');\n    }\n    return this.scenes[sceneIndex];\n  }\n\n  getSceneCount() {\n    return this.scenes.length;\n  }\n\n  getSplatBufferForSplat(globalIndex) {\n    return this.getScene(this.globalSplatIndexToSceneIndexMap[globalIndex])\n      .splatBuffer;\n  }\n\n  getSceneIndexForSplat(globalIndex) {\n    return this.globalSplatIndexToSceneIndexMap[globalIndex];\n  }\n\n  getSceneTransformForSplat(globalIndex) {\n    return this.getScene(this.globalSplatIndexToSceneIndexMap[globalIndex])\n      .transform;\n  }\n\n  getSplatLocalIndex(globalIndex) {\n    return this.globalSplatIndexToLocalSplatIndexMap[globalIndex];\n  }\n\n  static getIntegerMatrixArray(matrix) {\n    const matrixElements = matrix.elements;\n    const intMatrixArray = [];\n    for (let i = 0; i < 16; i++) {\n      intMatrixArray[i] = Math.round(matrixElements[i] * 1000.0);\n    }\n    return intMatrixArray;\n  }\n\n  computeBoundingBox(applySceneTransforms = false, sceneIndex) {\n    let splatCount = this.getSplatCount();\n    if (sceneIndex !== undefined && sceneIndex !== null) {\n      if (sceneIndex < 0 || sceneIndex >= this.scenes.length) {\n        throw new Error(\n          'SplatMesh::computeBoundingBox() -> Invalid scene index.',\n        );\n      }\n      splatCount = this.scenes[sceneIndex].splatBuffer.getSplatCount();\n    }\n\n    const floatCenters = new Float32Array(splatCount * 3);\n    this.fillSplatDataArrays(\n      null,\n      null,\n      null,\n      floatCenters,\n      null,\n      null,\n      applySceneTransforms,\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      sceneIndex,\n    );\n\n    const min = new THREE.Vector3();\n    const max = new THREE.Vector3();\n    for (let i = 0; i < splatCount; i++) {\n      const offset = i * 3;\n      const x = floatCenters[offset];\n      const y = floatCenters[offset + 1];\n      const z = floatCenters[offset + 2];\n      if (i === 0 || x < min.x) min.x = x;\n      if (i === 0 || y < min.y) min.y = y;\n      if (i === 0 || z < min.z) min.z = z;\n      if (i === 0 || x > max.x) max.x = x;\n      if (i === 0 || y > max.y) max.y = y;\n      if (i === 0 || z > max.z) max.z = z;\n    }\n\n    return new THREE.Box3(min, max);\n  }\n}\n","export class InfoPanel {\n  constructor(container) {\n    this.container = container || document.body;\n\n    this.infoCells = {};\n\n    const layout = [\n      ['Camera position', 'cameraPosition'],\n      ['Camera look-at', 'cameraLookAt'],\n      ['Camera up', 'cameraUp'],\n      ['Camera mode', 'orthographicCamera'],\n      ['Cursor position', 'cursorPosition'],\n      ['FPS', 'fps'],\n      ['Rendering:', 'renderSplatCount'],\n      ['Sort time', 'sortTime'],\n      ['Render window', 'renderWindow'],\n      ['Focal adjustment', 'focalAdjustment'],\n      ['Splat scale', 'splatScale'],\n      ['Point cloud mode', 'pointCloudMode'],\n    ];\n\n    this.infoPanelContainer = document.createElement('div');\n    const style = document.createElement('style');\n    style.innerHTML = `\n\n            .infoPanel {\n                width: 430px;\n                padding: 10px;\n                background-color: rgba(50, 50, 50, 0.85);\n                border: #555555 2px solid;\n                color: #dddddd;\n                border-radius: 10px;\n                z-index: 9999;\n                font-family: arial;\n                font-size: 11pt;\n                text-align: left;\n                margin: 0;\n                top: 10px;\n                left:10px;\n                position: absolute;\n                pointer-events: auto;\n            }\n\n            .info-panel-cell {\n                margin-bottom: 5px;\n                padding-bottom: 2px;\n            }\n\n            .label-cell {\n                font-weight: bold;\n                font-size: 12pt;\n                width: 140px;\n            }\n\n        `;\n    this.infoPanelContainer.append(style);\n\n    this.infoPanel = document.createElement('div');\n    this.infoPanel.className = 'infoPanel';\n\n    const infoTable = document.createElement('div');\n    infoTable.style.display = 'table';\n\n    for (let layoutEntry of layout) {\n      const row = document.createElement('div');\n      row.style.display = 'table-row';\n      row.className = 'info-panel-row';\n\n      const labelCell = document.createElement('div');\n      labelCell.style.display = 'table-cell';\n      labelCell.innerHTML = `${layoutEntry[0]}: `;\n      labelCell.classList.add('info-panel-cell', 'label-cell');\n\n      const spacerCell = document.createElement('div');\n      spacerCell.style.display = 'table-cell';\n      spacerCell.style.width = '10px';\n      spacerCell.innerHTML = ' ';\n      spacerCell.className = 'info-panel-cell';\n\n      const infoCell = document.createElement('div');\n      infoCell.style.display = 'table-cell';\n      infoCell.innerHTML = '';\n      infoCell.className = 'info-panel-cell';\n\n      this.infoCells[layoutEntry[1]] = infoCell;\n\n      row.appendChild(labelCell);\n      row.appendChild(spacerCell);\n      row.appendChild(infoCell);\n\n      infoTable.appendChild(row);\n    }\n\n    this.infoPanel.appendChild(infoTable);\n    this.infoPanelContainer.append(this.infoPanel);\n    this.infoPanelContainer.style.display = 'none';\n    this.container.appendChild(this.infoPanelContainer);\n\n    this.visible = false;\n  }\n\n  update = function(\n    renderDimensions,\n    cameraPosition,\n    cameraLookAtPosition,\n    cameraUp,\n    orthographicCamera,\n    meshCursorPosition,\n    currentFPS,\n    splatCount,\n    splatRenderCount,\n    splatRenderCountPct,\n    lastSortTime,\n    focalAdjustment,\n    splatScale,\n    pointCloudMode,\n  ) {\n    const cameraPosString = `${cameraPosition.x.toFixed(\n      5,\n    )}, ${cameraPosition.y.toFixed(5)}, ${cameraPosition.z.toFixed(5)}`;\n    if (this.infoCells.cameraPosition.innerHTML !== cameraPosString) {\n      this.infoCells.cameraPosition.innerHTML = cameraPosString;\n    }\n\n    if (cameraLookAtPosition) {\n      const cla = cameraLookAtPosition;\n      const cameraLookAtString = `${cla.x.toFixed(5)}, ${cla.y.toFixed(\n        5,\n      )}, ${cla.z.toFixed(5)}`;\n      if (this.infoCells.cameraLookAt.innerHTML !== cameraLookAtString) {\n        this.infoCells.cameraLookAt.innerHTML = cameraLookAtString;\n      }\n    }\n\n    const cameraUpString = `${cameraUp.x.toFixed(5)}, ${cameraUp.y.toFixed(\n      5,\n    )}, ${cameraUp.z.toFixed(5)}`;\n    if (this.infoCells.cameraUp.innerHTML !== cameraUpString) {\n      this.infoCells.cameraUp.innerHTML = cameraUpString;\n    }\n\n    this.infoCells.orthographicCamera.innerHTML = orthographicCamera ?\n      'Orthographic' :\n      'Perspective';\n\n    if (meshCursorPosition) {\n      const cursPos = meshCursorPosition;\n      const cursorPosString = `${cursPos.x.toFixed(5)}, ${cursPos.y.toFixed(\n        5,\n      )}, ${cursPos.z.toFixed(5)}`;\n      this.infoCells.cursorPosition.innerHTML = cursorPosString;\n    } else {\n      this.infoCells.cursorPosition.innerHTML = 'N/A';\n    }\n\n    this.infoCells.fps.innerHTML = currentFPS;\n    this.infoCells.renderWindow.innerHTML = `${renderDimensions.x} x ${renderDimensions.y}`;\n\n    this.infoCells.renderSplatCount.innerHTML = `${splatRenderCount} splats out of ${splatCount} (${splatRenderCountPct.toFixed(\n      2,\n    )}%)`;\n\n    this.infoCells.sortTime.innerHTML = `${lastSortTime.toFixed(3)} ms`;\n    this.infoCells.focalAdjustment.innerHTML = `${focalAdjustment.toFixed(3)}`;\n    this.infoCells.splatScale.innerHTML = `${splatScale.toFixed(3)}`;\n    this.infoCells.pointCloudMode.innerHTML = `${pointCloudMode}`;\n  };\n\n  setContainer(container) {\n    if (\n      this.container &&\n      this.infoPanelContainer.parentElement === this.container\n    ) {\n      this.container.removeChild(this.infoPanelContainer);\n    }\n    if (container) {\n      this.container = container;\n      this.container.appendChild(this.infoPanelContainer);\n      this.infoPanelContainer.style.zIndex = this.container.style.zIndex + 1;\n    }\n  }\n\n  show() {\n    this.infoPanelContainer.style.display = 'block';\n    this.visible = true;\n  }\n\n  hide() {\n    this.infoPanelContainer.style.display = 'none';\n    this.visible = false;\n  }\n}\n","export class LoadingProgressBar {\n  constructor(container) {\n    this.idGen = 0;\n\n    this.tasks = [];\n\n    this.container = container || document.body;\n\n    this.progressBarContainerOuter = document.createElement('div');\n    this.progressBarContainerOuter.className = 'progressBarOuterContainer';\n    this.progressBarContainerOuter.style.display = 'none';\n\n    this.progressBarBox = document.createElement('div');\n    this.progressBarBox.className = 'progressBarBox';\n\n    this.progressBarBackground = document.createElement('div');\n    this.progressBarBackground.className = 'progressBarBackground';\n\n    this.progressBar = document.createElement('div');\n    this.progressBar.className = 'progressBar';\n\n    this.progressBarBackground.appendChild(this.progressBar);\n    this.progressBarBox.appendChild(this.progressBarBackground);\n    this.progressBarContainerOuter.appendChild(this.progressBarBox);\n\n    const style = document.createElement('style');\n    style.innerHTML = `\n\n            .progressBarOuterContainer {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .progressBarBox {\n                z-index:99999;\n                padding: 7px 9px 5px 7px;\n                background-color: rgba(190, 190, 190, 0.75);\n                border: #555555 1px solid;\n                border-radius: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                width: 180px;\n                height: 30px;\n                pointer-events: auto;\n            }\n\n            .progressBarBackground {\n                width: 100%;\n                height: 25px;\n                border-radius:10px;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #444444 1px solid;\n                box-shadow: inset 0 0 10px #333333;\n            }\n\n            .progressBar {\n                height: 25px;\n                width: 0px;\n                border-radius:10px;\n                background-color: rgba(0, 200, 0, 0.75);\n                box-shadow: inset 0 0 10px #003300;\n            }\n\n        `;\n    this.progressBarContainerOuter.appendChild(style);\n    this.container.appendChild(this.progressBarContainerOuter);\n  }\n\n  show() {\n    this.progressBarContainerOuter.style.display = 'block';\n  }\n\n  hide() {\n    this.progressBarContainerOuter.style.display = 'none';\n  }\n\n  setProgress(progress) {\n    this.progressBar.style.width = progress + '%';\n  }\n\n  setContainer(container) {\n    if (\n      this.container &&\n      this.progressBarContainerOuter.parentElement === this.container\n    ) {\n      this.container.removeChild(this.progressBarContainerOuter);\n    }\n    if (container) {\n      this.container = container;\n      this.container.appendChild(this.progressBarContainerOuter);\n      this.progressBarContainerOuter.style.zIndex =\n        this.container.style.zIndex + 1;\n    }\n  }\n}\n","import { fadeElement } from './Util.js';\n\nconst STANDARD_FADE_DURATION = 500;\n\nexport class LoadingSpinner {\n  static elementIDGen = 0;\n\n  constructor(message, container) {\n    this.taskIDGen = 0;\n    this.elementID = LoadingSpinner.elementIDGen++;\n\n    this.tasks = [];\n\n    this.message = message || 'Loading...';\n    this.container = container || document.body;\n\n    this.spinnerContainerOuter = document.createElement('div');\n    this.spinnerContainerOuter.className = `spinnerOuterContainer${this.elementID}`;\n    this.spinnerContainerOuter.style.display = 'none';\n\n    this.spinnerContainerPrimary = document.createElement('div');\n    this.spinnerContainerPrimary.className = `spinnerContainerPrimary${this.elementID}`;\n    this.spinnerPrimary = document.createElement('div');\n    this.spinnerPrimary.classList.add(\n      `spinner${this.elementID}`,\n      `spinnerPrimary${this.elementID}`,\n    );\n    this.messageContainerPrimary = document.createElement('div');\n    this.messageContainerPrimary.classList.add(\n      `messageContainer${this.elementID}`,\n      `messageContainerPrimary${this.elementID}`,\n    );\n    this.messageContainerPrimary.innerHTML = this.message;\n\n    this.spinnerContainerMin = document.createElement('div');\n    this.spinnerContainerMin.className = `spinnerContainerMin${this.elementID}`;\n    this.spinnerMin = document.createElement('div');\n    this.spinnerMin.classList.add(\n      `spinner${this.elementID}`,\n      `spinnerMin${this.elementID}`,\n    );\n    this.messageContainerMin = document.createElement('div');\n    this.messageContainerMin.classList.add(\n      `messageContainer${this.elementID}`,\n      `messageContainerMin${this.elementID}`,\n    );\n    this.messageContainerMin.innerHTML = this.message;\n\n    this.spinnerContainerPrimary.appendChild(this.spinnerPrimary);\n    this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary);\n    this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary);\n\n    this.spinnerContainerMin.appendChild(this.spinnerMin);\n    this.spinnerContainerMin.appendChild(this.messageContainerMin);\n    this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);\n\n    const style = document.createElement('style');\n    style.innerHTML = `\n\n            .spinnerOuterContainer${this.elementID} {\n                width: 100%;\n                height: 100%;\n                margin: 0;\n                top: 0;\n                left: 0;\n                position: absolute;\n                pointer-events: none;\n            }\n\n            .messageContainer${this.elementID} {\n                height: 20px;\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                vertical-align: middle;\n            }\n\n            .spinner${this.elementID} {\n                padding: 15px;\n                background: #07e8d6;\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n            }\n\n            .spinnerContainerPrimary${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 10px;\n                margin: 0;\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n                pointer-events: auto;\n            }\n\n            .spinnerPrimary${this.elementID} {\n                width: 120px;\n                margin-left: 30px;\n            }\n\n            .messageContainerPrimary${this.elementID} {\n                padding-top: 15px;\n            }\n\n            .spinnerContainerMin${this.elementID} {\n                z-index:99999;\n                background-color: rgba(128, 128, 128, 0.75);\n                border: #666666 1px solid;\n                border-radius: 5px;\n                padding-top: 20px;\n                padding-bottom: 15px;\n                margin: 0;\n                position: absolute;\n                bottom: 50px;\n                left: 50%;\n                transform: translate(-50%, 0);\n                display: flex;\n                flex-direction: left;\n                pointer-events: auto;\n                min-width: 250px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                margin-right: 15px;\n            }\n\n            .spinnerMin${this.elementID} {\n                width: 50px;\n                height: 50px;\n                margin-left: 15px;\n                margin-right: 25px;\n            }\n\n            .messageContainerMin${this.elementID} {\n                padding-top: 15px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        `;\n    this.spinnerContainerOuter.appendChild(style);\n    this.container.appendChild(this.spinnerContainerOuter);\n\n    this.setMinimized(false, true);\n\n    this.fadeTransitions = [];\n  }\n\n  addTask(message) {\n    const newTask = {\n      message: message,\n      id: this.taskIDGen++,\n    };\n    this.tasks.push(newTask);\n    this.update();\n    return newTask.id;\n  }\n\n  removeTask(id) {\n    let index = 0;\n    for (let task of this.tasks) {\n      if (task.id === id) {\n        this.tasks.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n    this.update();\n  }\n\n  removeAllTasks() {\n    this.tasks = [];\n    this.update();\n  }\n\n  setMessageForTask(id, message) {\n    for (let task of this.tasks) {\n      if (task.id === id) {\n        task.message = message;\n        break;\n      }\n    }\n    this.update();\n  }\n\n  update() {\n    if (this.tasks.length > 0) {\n      this.show();\n      this.setMessage(this.tasks[this.tasks.length - 1].message);\n    } else {\n      this.hide();\n    }\n  }\n\n  show() {\n    this.spinnerContainerOuter.style.display = 'block';\n    this.visible = true;\n  }\n\n  hide() {\n    this.spinnerContainerOuter.style.display = 'none';\n    this.visible = false;\n  }\n\n  setContainer(container) {\n    if (\n      this.container &&\n      this.spinnerContainerOuter.parentElement === this.container\n    ) {\n      this.container.removeChild(this.spinnerContainerOuter);\n    }\n    if (container) {\n      this.container = container;\n      this.container.appendChild(this.spinnerContainerOuter);\n      this.spinnerContainerOuter.style.zIndex = this.container.style.zIndex + 1;\n    }\n  }\n\n  setMinimized(minimized, instant) {\n    const showHideSpinner = (\n      element,\n      show,\n      instant,\n      displayStyle,\n      fadeTransitionsIndex,\n    ) => {\n      if (instant) {\n        element.style.display = show ? displayStyle : 'none';\n      } else {\n        this.fadeTransitions[fadeTransitionsIndex] = fadeElement(\n          element,\n          !show,\n          displayStyle,\n          STANDARD_FADE_DURATION,\n          () => {\n            this.fadeTransitions[fadeTransitionsIndex] = null;\n          },\n        );\n      }\n    };\n    showHideSpinner(\n      this.spinnerContainerPrimary,\n      !minimized,\n      instant,\n      'block',\n      0,\n    );\n    showHideSpinner(this.spinnerContainerMin, minimized, instant, 'flex', 1);\n    this.minimized = minimized;\n  }\n\n  setMessage(msg) {\n    this.messageContainerPrimary.innerHTML = msg;\n    this.messageContainerMin.innerHTML = msg;\n  }\n}\n","export const fadeElement = (\n  element,\n  out,\n  displayStyle,\n  duration,\n  onComplete,\n) => {\n  const startTime = performance.now();\n\n  let startOpacity =\n    element.style.display === 'none' ? 0 : parseFloat(element.style.opacity);\n  if (isNaN(startOpacity)) startOpacity = 1;\n\n  const interval = window.setInterval(() => {\n    const currentTime = performance.now();\n    const elapsed = currentTime - startTime;\n\n    let t = Math.min(elapsed / duration, 1.0);\n    if (t > 0.999) t = 1;\n\n    let opacity;\n    if (out) {\n      opacity = (1.0 - t) * startOpacity;\n      if (opacity < 0.0001) opacity = 0;\n    } else {\n      opacity = (1.0 - startOpacity) * t + startOpacity;\n    }\n\n    if (opacity > 0) {\n      element.style.display = displayStyle;\n      element.style.opacity = opacity;\n    } else {\n      element.style.display = 'none';\n    }\n\n    if (t >= 1) {\n      if (onComplete) onComplete();\n      window.clearInterval(interval);\n    }\n  }, 16);\n  return interval;\n};\n\nexport const cancelFade = (interval) => {\n  window.clearInterval(interval);\n};\n","/*\nCopyright  2010-2024 three.js authors & Mark Kellogg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n*/\n\nexport class ARButton {\n  static createButton(renderer, sessionInit = {}) {\n    const button = document.createElement('button');\n\n    function showStartAR(/* device */) {\n      if (sessionInit.domOverlay === undefined) {\n        const overlay = document.createElement('div');\n        overlay.style.display = 'none';\n        document.body.appendChild(overlay);\n\n        const svg = document.createElementNS(\n          'http://www.w3.org/2000/svg',\n          'svg',\n        );\n        svg.setAttribute('width', 38);\n        svg.setAttribute('height', 38);\n        svg.style.position = 'absolute';\n        svg.style.right = '20px';\n        svg.style.top = '20px';\n        svg.addEventListener('click', function() {\n          currentSession.end();\n        });\n        overlay.appendChild(svg);\n\n        const path = document.createElementNS(\n          'http://www.w3.org/2000/svg',\n          'path',\n        );\n        path.setAttribute('d', 'M 12,12 L 28,28 M 28,12 12,28');\n        path.setAttribute('stroke', '#fff');\n        path.setAttribute('stroke-width', 2);\n        svg.appendChild(path);\n\n        if (sessionInit.optionalFeatures === undefined) {\n          sessionInit.optionalFeatures = [];\n        }\n\n        sessionInit.optionalFeatures.push('dom-overlay');\n        sessionInit.domOverlay = { root: overlay };\n      }\n\n      //\n\n      let currentSession = null;\n\n      async function onSessionStarted(session) {\n        session.addEventListener('end', onSessionEnded);\n\n        renderer.xr.setReferenceSpaceType('local');\n\n        await renderer.xr.setSession(session);\n\n        button.textContent = 'STOP AR';\n        sessionInit.domOverlay.root.style.display = '';\n\n        currentSession = session;\n      }\n\n      function onSessionEnded(/* event */) {\n        currentSession.removeEventListener('end', onSessionEnded);\n\n        button.textContent = 'START AR';\n        sessionInit.domOverlay.root.style.display = 'none';\n\n        currentSession = null;\n      }\n\n      //\n\n      button.style.display = '';\n\n      button.style.cursor = 'pointer';\n      button.style.left = 'calc(50% - 50px)';\n      button.style.width = '100px';\n\n      button.textContent = 'START AR';\n\n      button.onmouseenter = function() {\n        button.style.opacity = '1.0';\n      };\n\n      button.onmouseleave = function() {\n        button.style.opacity = '0.5';\n      };\n\n      button.onclick = function() {\n        if (currentSession === null) {\n          navigator.xr\n            .requestSession('immersive-ar', sessionInit)\n            .then(onSessionStarted);\n        } else {\n          currentSession.end();\n\n          if (navigator.xr.offerSession !== undefined) {\n            navigator.xr\n              .offerSession('immersive-ar', sessionInit)\n              .then(onSessionStarted)\n              .catch((err) => {\n                console.warn(err);\n              });\n          }\n        }\n      };\n\n      if (navigator.xr.offerSession !== undefined) {\n        navigator.xr\n          .offerSession('immersive-ar', sessionInit)\n          .then(onSessionStarted)\n          .catch((err) => {\n            console.warn(err);\n          });\n      }\n    }\n\n    function disableButton() {\n      button.style.display = '';\n\n      button.style.cursor = 'auto';\n      button.style.left = 'calc(50% - 75px)';\n      button.style.width = '150px';\n\n      button.onmouseenter = null;\n      button.onmouseleave = null;\n\n      button.onclick = null;\n    }\n\n    function showARNotSupported() {\n      disableButton();\n\n      button.textContent = 'AR NOT SUPPORTED';\n    }\n\n    function showARNotAllowed(exception) {\n      disableButton();\n\n      console.warn(\n        'Exception when trying to call xr.isSessionSupported',\n        exception,\n      );\n\n      button.textContent = 'AR NOT ALLOWED';\n    }\n\n    function stylizeElement(element) {\n      element.style.position = 'absolute';\n      element.style.bottom = '20px';\n      element.style.padding = '12px 6px';\n      element.style.border = '1px solid #fff';\n      element.style.borderRadius = '4px';\n      element.style.background = 'rgba(0,0,0,0.1)';\n      element.style.color = '#fff';\n      element.style.font = 'normal 13px sans-serif';\n      element.style.textAlign = 'center';\n      element.style.opacity = '0.5';\n      element.style.outline = 'none';\n      element.style.zIndex = '999';\n    }\n\n    if ('xr' in navigator) {\n      button.id = 'ARButton';\n      button.style.display = 'none';\n\n      stylizeElement(button);\n\n      navigator.xr\n        .isSessionSupported('immersive-ar')\n        .then(function(supported) {\n          supported ? showStartAR() : showARNotSupported();\n        })\n        .catch(showARNotAllowed);\n\n      return button;\n    } else {\n      const message = document.createElement('a');\n\n      if (window.isSecureContext === false) {\n        message.href = document.location.href.replace(/^http:/, 'https:');\n        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n      } else {\n        message.href = 'https://immersiveweb.dev/';\n        message.innerHTML = 'WEBXR NOT AVAILABLE';\n      }\n\n      message.style.left = 'calc(50% - 90px)';\n      message.style.width = '180px';\n      message.style.textDecoration = 'none';\n\n      stylizeElement(message);\n\n      return message;\n    }\n  }\n}\n","/*\nCopyright  2010-2024 three.js authors & Mark Kellogg\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n*/\n\nexport class VRButton {\n  static createButton(renderer, sessionInit = {}) {\n    const button = document.createElement('button');\n\n    function showEnterVR(/* device */) {\n      let currentSession = null;\n\n      async function onSessionStarted(session) {\n        session.addEventListener('end', onSessionEnded);\n\n        await renderer.xr.setSession(session);\n        button.textContent = 'EXIT VR';\n\n        currentSession = session;\n      }\n\n      function onSessionEnded(/* event */) {\n        currentSession.removeEventListener('end', onSessionEnded);\n\n        button.textContent = 'ENTER VR';\n\n        currentSession = null;\n      }\n\n      //\n\n      button.style.display = '';\n\n      button.style.cursor = 'pointer';\n      button.style.left = 'calc(50% - 50px)';\n      button.style.width = '100px';\n\n      button.textContent = 'ENTER VR';\n\n      // WebXR's requestReferenceSpace only works if the corresponding feature\n      // was requested at session creation time. For simplicity, just ask for\n      // the interesting ones as optional features, but be aware that the\n      // requestReferenceSpace call will fail if it turns out to be unavailable.\n      // ('local' is always available for immersive sessions and doesn't need to\n      // be requested separately.)\n\n      const sessionOptions = {\n        ...sessionInit,\n        optionalFeatures: [\n          'local-floor',\n          'bounded-floor',\n          'layers',\n          ...(sessionInit.optionalFeatures || []),\n        ],\n      };\n\n      button.onmouseenter = function() {\n        button.style.opacity = '1.0';\n      };\n\n      button.onmouseleave = function() {\n        button.style.opacity = '0.5';\n      };\n\n      button.onclick = function() {\n        if (currentSession === null) {\n          navigator.xr\n            .requestSession('immersive-vr', sessionOptions)\n            .then(onSessionStarted);\n        } else {\n          currentSession.end();\n\n          if (navigator.xr.offerSession !== undefined) {\n            navigator.xr\n              .offerSession('immersive-vr', sessionOptions)\n              .then(onSessionStarted)\n              .catch((err) => {\n                console.warn(err);\n              });\n          }\n        }\n      };\n\n      if (navigator.xr.offerSession !== undefined) {\n        navigator.xr\n          .offerSession('immersive-vr', sessionOptions)\n          .then(onSessionStarted)\n          .catch((err) => {\n            console.warn(err);\n          });\n      }\n    }\n\n    function disableButton() {\n      button.style.display = '';\n\n      button.style.cursor = 'auto';\n      button.style.left = 'calc(50% - 75px)';\n      button.style.width = '150px';\n\n      button.onmouseenter = null;\n      button.onmouseleave = null;\n\n      button.onclick = null;\n    }\n\n    function showWebXRNotFound() {\n      disableButton();\n\n      button.textContent = 'VR NOT SUPPORTED';\n    }\n\n    function showVRNotAllowed(exception) {\n      disableButton();\n\n      console.warn(\n        'Exception when trying to call xr.isSessionSupported',\n        exception,\n      );\n\n      button.textContent = 'VR NOT ALLOWED';\n    }\n\n    function stylizeElement(element) {\n      element.style.position = 'absolute';\n      element.style.bottom = '20px';\n      element.style.padding = '12px 6px';\n      element.style.border = '1px solid #fff';\n      element.style.borderRadius = '4px';\n      element.style.background = 'rgba(0,0,0,0.1)';\n      element.style.color = '#fff';\n      element.style.font = 'normal 13px sans-serif';\n      element.style.textAlign = 'center';\n      element.style.opacity = '0.5';\n      element.style.outline = 'none';\n      element.style.zIndex = '999';\n    }\n\n    if ('xr' in navigator) {\n      button.id = 'VRButton';\n      button.style.display = 'none';\n\n      stylizeElement(button);\n\n      navigator.xr\n        .isSessionSupported('immersive-vr')\n        .then(function(supported) {\n          supported ? showEnterVR() : showWebXRNotFound();\n\n          if (supported && VRButton.xrSessionIsGranted) {\n            button.click();\n          }\n        })\n        .catch(showVRNotAllowed);\n\n      return button;\n    } else {\n      const message = document.createElement('a');\n\n      if (window.isSecureContext === false) {\n        message.href = document.location.href.replace(/^http:/, 'https:');\n        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\n      } else {\n        message.href = 'https://immersiveweb.dev/';\n        message.innerHTML = 'WEBXR NOT AVAILABLE';\n      }\n\n      message.style.left = 'calc(50% - 90px)';\n      message.style.width = '180px';\n      message.style.textDecoration = 'none';\n\n      stylizeElement(message);\n\n      return message;\n    }\n  }\n\n  static registerSessionGrantedListener() {\n    if (typeof navigator !== 'undefined' && 'xr' in navigator) {\n      // WebXRViewer (based on Firefox) has a bug where addEventListener\n      // throws a silent exception and aborts execution entirely.\n      if (/WebXRViewer\\//i.test(navigator.userAgent)) return;\n\n      navigator.xr.addEventListener('sessiongranted', () => {\n        VRButton.xrSessionIsGranted = true;\n      });\n    }\n  }\n}\n\nVRButton.xrSessionIsGranted = false;\nVRButton.registerSessionGrantedListener();\n","export const WebXRMode = {\n  None: 0,\n  VR: 1,\n  AR: 2,\n};\n","\u0000asm\u0001\u0000\u0000\u0000\u0000\u000f\bdylink.0\u0001\u0004\u0000\u0000\u0000\u0000\u0001\u001b\u0003`\u0000\u0000`\u0010\u0000`\u0000\u0001\u0002\u0012\u0001\u0003env\u0006memory\u0002\u0003\u0000\u0004\u0003\u0004\u0003\u0000\u0001\u0002\u0007T\u0004\u0011__wasm_call_ctors\u0000\u0000\u0018__wasm_apply_data_relocs\u0000\u0000\u000bsortIndexes\u0000\u0001\u0013emscripten_tls_init\u0000\u0002\n\u0010\u0003\u0003\u0000\u0001\u000b\u0010\u0004\u0001|\u0003{\u0003\u0003} \u000b \nk!\f\u0002@\u0002@ \u000e\u0004@ \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0003 \f!\u0001\u0003@ \u0003 \u0001A\u0002t\"\u0005j \u0002 \u0000 \u0005j(\u0002\u0000A\u0002tj(\u0002\u0000\"\u00056\u0002\u0000 \u0005 \n \u0005 \nH\u001b!\n \u0005 \r \u0005 \rJ\u001b!\r \u0001A\u0001j\"\u0001 \u000bG\r\u0000\u000b\f\u0003\u000b \u000f\u0004@ \u000b \fM\r\u0002A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u0015j(\u0002\u0000\"\u0016A\u0002tj(\u0002\u0000\"\u0014G\u0004@\u0002 \u0005\t\u00028 \b \u0014A\u0006tj\"\u000e\t\u0002\f \u000e*\u0002\u001c \u0001 \u000e*\u0002, \u0002 \u000e*\u0002< \u0003\u0001 \u0005\t\u0002( \u000e\t\u0002\b \u000e*\u0002\u0018 \u0001 \u000e*\u0002( \u0002 \u000e*\u00028 \u0003\u0001 \u0005\t\u0002\b \u000e\t\u0002\u0000 \u000e*\u0002\u0010 \u0001 \u000e*\u0002  \u0002 \u000e*\u00020 \u0003\u0001 \u0005\t\u0002\u0018 \u000e\t\u0002\u0004 \u000e*\u0002\u0014 \u0001 \u000e*\u0002$ \u0002 \u000e*\u00024 \u0003\u0001\u0001\u0001\u0001\"\u0011_\f\u0000\u0000\u0000\u0000\u0000@@\u0000\u0000\u0000\u0000\u0000@@\"\u0012\u0001\"\u0013!\u0001\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e\u0002 \u0013!\u0000\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\u0011 \u000e\u001c\u0001\u0002 \u0011 \u0011\r\b\t\n\u000b\f\r\u000e\u000f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000_ \u0012\u0001\"\u0011!\u0000\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\u001c\u0002\u0002 \u0011!\u0001\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\u001c\u0003!\u0012 \u0014!\u000f\u000b \u0003 \u0015j \u0001 \u0016A\u0004tj\u0000\u0000\u0000 \u0012\u0001\"\u0011\u001b\u0000 \u0011\u001b\u0001j \u0011\u001b\u0002j \u0011\u001b\u0003j\"\u000e6\u0002\u0000 \u000e \n \n \u000eJ\u001b!\n \u000e \r \r \u000eH\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0003\u000b\u0002 \u0005*\u0002\b\u0014 \u0005*\u0002\u0018\"\u0001\f\u0000\u0000\u0000\u0000\u0000@@\u0000\u0000\u0000\u0000\u0000@@\u0001\"\u0011!\u0001\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e\u0002 \u0011!\u0000\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0002\u0002 \u0005*\u0002(D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0005A\u0007!\nAx!\r \u000b \fM\r\u0002 \u0002\u0011 \u000e\u001c\u0001 \u0005\u001c\u0002!\u0012 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0002j \u0001 \u0000 \u0002j(\u0002\u0000A\u0004tj\u0000\u0000\u0000 \u0012\u0001\"\u0011\u001b\u0000 \u0011\u001b\u0001j \u0011\u001b\u0002j\"\u00026\u0002\u0000 \u0002 \n \u0002 \nH\u001b!\n \u0002 \r \u0002 \rJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0002 \f!\u0001\u0003@ \u0003 \u0001A\u0002t\"\u0005j\u0002 \u0002 \u0000 \u0005j(\u0002\u0000A\u0002tj*\u0002\u0000D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0001A\u0001j\"\u0001 \u000bG\r\u0000\u000b\f\u0002\u000b \u000fE\u0004@ \u000b \fM\r\u0001 \u0005*\u0002(!\u0017 \u0005*\u0002\u0018!\u0018 \u0005*\u0002\b!\u0019A\u0007!\nAx!\r \f!\u0005\u0003@\u0002 \u0017 \u0001 \u0000 \u0005A\u0002t\"\u0007j(\u0002\u0000A\u0004tj\"\u0002*\u0002\b \u0019 \u0002*\u0002\u0000 \u0018 \u0002*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e \u0003 \u0007j \u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \u000b \fM\r\u0000A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u0014j(\u0002\u0000A\u0002t\"\u0015j(\u0002\u0000\"\u000eG\u0004@ \u0005\t\u00028 \b \u000eA\u0006tj\"\u000f\t\u0002\f \u000f*\u0002\u001c \u0001 \u000f*\u0002, \u0002 \u000f*\u0002< \u0003\u0001 \u0005\t\u0002( \u000f\t\u0002\b \u000f*\u0002\u0018 \u0001 \u000f*\u0002( \u0002 \u000f*\u00028 \u0003\u0001 \u0005\t\u0002\b \u000f\t\u0002\u0000 \u000f*\u0002\u0010 \u0001 \u000f*\u0002  \u0002 \u000f*\u00020 \u0003\u0001 \u0005\t\u0002\u0018 \u000f\t\u0002\u0004 \u000f*\u0002\u0014 \u0001 \u000f*\u0002$ \u0002 \u000f*\u00024 \u0003\u0001\u0001\u0001\u0001!\u0011 \u000e!\u000f\u000b \u0003 \u0014j\u0002 \u0011\u001f\u0003 \u0001 \u0015A\u0002t\"\u000eA\frj*\u0002\u0000 \u0011\u001f\u0002 \u0001 \u000eA\brj*\u0002\u0000 \u0011\u001f\u0000 \u0001 \u000ej*\u0002\u0000 \u0011\u001f\u0001 \u0001 \u000eA\u0004rj*\u0002\u0000D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0001\u000bAx!\rA\u0007!\n\u000b \u000b \fK\u0004@ \tA\u0001k \r \n!\u0017 \f!\r\u0003@\u0002 \u0017 \u0003 \rA\u0002tj\"\u0001(\u0002\u0000 \nk\"\u0018C\u0000\u0000\u0000O]\u0004@ \u0018\f\u0001\u000bAx\u000b!\u000e \u0001 \u000e6\u0002\u0000 \u0004 \u000eA\u0002tj\"\u0001 \u0001(\u0002\u0000A\u0001j6\u0002\u0000 \rA\u0001j\"\r \u000bG\r\u0000\u000b\u000b \tA\u0002O\u0004@ \u0004(\u0002\u0000!\rA\u0001!\n\u0003@ \u0004 \nA\u0002tj\"\u0001 \u0001(\u0002\u0000 \rj\"\r6\u0002\u0000 \nA\u0001j\"\n \tG\r\u0000\u000b\u000b \fA\u0000J\u0004@ \f!\n\u0003@ \u0006 \nA\u0001k\"\u0001A\u0002t\"\u0002j \u0000 \u0002j(\u0002\u00006\u0002\u0000 \nA\u0001K!\u0002 \u0001!\n \u0002\r\u0000\u000b\u000b \u000b \fJ\u0004@ \u000b!\n\u0003@ \u0006 \u000b \u0004 \u0003 \nA\u0001k\"\nA\u0002t\"\u0001j(\u0002\u0000A\u0002tj\"\u0002(\u0002\u0000\"\u0005kA\u0002tj \u0000 \u0001j(\u0002\u00006\u0002\u0000 \u0002 \u0005A\u0001k6\u0002\u0000 \n \fJ\r\u0000\u000b\u000b\u000b\u0004\u0000A\u0000\u000b","\u0000asm\u0001\u0000\u0000\u0000\u0000\u000f\bdylink.0\u0001\u0004\u0000\u0000\u0000\u0000\u0001\u0017\u0002`\u0000\u0000`\u0010\u0000\u0002\u0012\u0001\u0003env\u0006memory\u0002\u0003\u0000\u0004\u0003\u0003\u0002\u0000\u0001\u0007>\u0003\u0011__wasm_call_ctors\u0000\u0000\u0018__wasm_apply_data_relocs\u0000\u0000\u000bsortIndexes\u0000\u0001\n\u000f\u0002\u0002\u0000\u000b\u000f\u0003\u0001|\u0007}\u0006 \u000b \nk!\f\u0002@\u0002@ \u000e\u0004@ \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0003 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0001j \u0002 \u0000 \u0001j(\u0002\u0000A\u0002tj(\u0002\u0000\"\u00016\u0002\u0000 \u0001 \n \u0001 \nH\u001b!\n \u0001 \r \u0001 \rJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0003\u000b \u000f\u0004@ \u000b \fM\r\u0002A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u001aj(\u0002\u0000A\u0002t\"\u001bj(\u0002\u0000\"\u000eG\u0004@\u0002 \u0005*\u00028\"\u0011 \b \u000eA\u0006tj\"\u000f*\u0002< \u0005*\u0002(\"\u0012 \u000f*\u00028 \u0005*\u0002\b\"\u0013 \u000f*\u00020 \u0005*\u0002\u0018\"\u0014 \u000f*\u00024D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0018\u0002 \u0011 \u000f*\u0002, \u0012 \u000f*\u0002( \u0013 \u000f*\u0002  \u0014 \u000f*\u0002$D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0019\u0002 \u0011 \u000f*\u0002\u001c \u0012 \u000f*\u0002\u0018 \u0013 \u000f*\u0002\u0010 \u0014 \u000f*\u0002\u0014D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u001c\u0002 \u0011 \u000f*\u0002\f \u0012 \u000f*\u0002\b \u0013 \u000f*\u0002\u0000 \u0014 \u000f*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u001d \u000e!\u000f\u000b \u0003 \u001aj \u0001 \u001bA\u0002tj\"\u000e(\u0002\u0004 \u001cl \u000e(\u0002\u0000 \u001dlj \u000e(\u0002\b \u0019lj \u000e(\u0002\f \u0018lj\"\u000e6\u0002\u0000 \u000e \n \n \u000eJ\u001b!\n \u000e \r \r \u000eH\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0003\u000b\u0002 \u0005*\u0002(D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0002\u0002 \u0005*\u0002\u0018D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0007 \u000b \fM\u0002 \u0005*\u0002\bD\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000fA\u0007!\nAx!\r\r\u0002 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\bj \u0001 \u0000 \bj(\u0002\u0000A\u0004tj\"\b(\u0002\u0004 \u0007l \b(\u0002\u0000 \u000flj \b(\u0002\b \u0002lj\"\b6\u0002\u0000 \b \n \b \nH\u001b!\n \b \r \b \rJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0002 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0001j\u0002 \u0002 \u0000 \u0001j(\u0002\u0000A\u0002tj*\u0002\u0000D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \u000fE\u0004@ \u000b \fM\r\u0001 \u0005*\u0002(!\u0011 \u0005*\u0002\u0018!\u0012 \u0005*\u0002\b!\u0013A\u0007!\nAx!\r \f!\u0005\u0003@\u0002 \u0011 \u0001 \u0000 \u0005A\u0002t\"\u0007j(\u0002\u0000A\u0004tj\"\u0002*\u0002\b \u0013 \u0002*\u0002\u0000 \u0012 \u0002*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e \u0003 \u0007j \u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \u000b \fM\r\u0000A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u0018j(\u0002\u0000A\u0002t\"\u0019j(\u0002\u0000\"\u000eG\u0004@ \u0005*\u00028\"\u0011 \b \u000eA\u0006tj\"\u000f*\u0002< \u0005*\u0002(\"\u0012 \u000f*\u00028 \u0005*\u0002\b\"\u0013 \u000f*\u00020 \u0005*\u0002\u0018\"\u0014 \u000f*\u00024!\u0015 \u0011 \u000f*\u0002, \u0012 \u000f*\u0002( \u0013 \u000f*\u0002  \u0014 \u000f*\u0002$!\u0016 \u0011 \u000f*\u0002\u001c \u0012 \u000f*\u0002\u0018 \u0013 \u000f*\u0002\u0010 \u0014 \u000f*\u0002\u0014!\u0017 \u0011 \u000f*\u0002\f \u0012 \u000f*\u0002\b \u0013 \u000f*\u0002\u0000 \u0014 \u000f*\u0002\u0004!\u0011 \u000e!\u000f\u000b \u0003 \u0018j\u0002 \u0015 \u0001 \u0019A\u0002tj\"\u000e*\u0002\f \u0016 \u000e*\u0002\b \u0011 \u000e*\u0002\u0000 \u0017 \u000e*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0001\u000bAx!\rA\u0007!\n\u000b \u000b \fK\u0004@ \tA\u0001k \r \n!\u0011 \f!\r\u0003@\u0002 \u0011 \u0003 \rA\u0002tj\"\u0001(\u0002\u0000 \nk\"\u0012C\u0000\u0000\u0000O]\u0004@ \u0012\f\u0001\u000bAx\u000b!\u000e \u0001 \u000e6\u0002\u0000 \u0004 \u000eA\u0002tj\"\u0001 \u0001(\u0002\u0000A\u0001j6\u0002\u0000 \rA\u0001j\"\r \u000bG\r\u0000\u000b\u000b \tA\u0002O\u0004@ \u0004(\u0002\u0000!\rA\u0001!\n\u0003@ \u0004 \nA\u0002tj\"\u0001 \u0001(\u0002\u0000 \rj\"\r6\u0002\u0000 \nA\u0001j\"\n \tG\r\u0000\u000b\u000b \fA\u0000J\u0004@ \f!\n\u0003@ \u0006 \nA\u0001k\"\u0001A\u0002t\"\u0002j \u0000 \u0002j(\u0002\u00006\u0002\u0000 \nA\u0001K \u0001!\n\r\u0000\u000b\u000b \u000b \fJ\u0004@ \u000b!\n\u0003@ \u0006 \u000b \u0004 \u0003 \nA\u0001k\"\nA\u0002t\"\u0001j(\u0002\u0000A\u0002tj\"\u0002(\u0002\u0000\"\u0005kA\u0002tj \u0000 \u0001j(\u0002\u00006\u0002\u0000 \u0002 \u0005A\u0001k6\u0002\u0000 \n \fJ\r\u0000\u000b\u000b\u000b","import SorterWasm from './sorter.wasm';\nimport SorterWasmNoSIMD from './sorter_no_simd.wasm';\nimport SorterWasmNonShared from './sorter_non_shared.wasm';\nimport SorterWasmNoSIMDNonShared from './sorter_no_simd_non_shared.wasm';\nimport { isIOS, getIOSSemever } from '../Util.js';\nimport { Constants } from '../Constants.js';\n\nfunction sortWorker(self) {\n  let wasmInstance;\n  let wasmMemory;\n  let useSharedMemory;\n  let integerBasedSort;\n  let dynamicMode;\n  let splatCount;\n  let indexesToSortOffset;\n  let sortedIndexesOffset;\n  let sceneIndexesOffset;\n  let transformsOffset;\n  let precomputedDistancesOffset;\n  let mappedDistancesOffset;\n  let frequenciesOffset;\n  let centersOffset;\n  let modelViewProjOffset;\n  let countsZero;\n  let sortedIndexesOut;\n  let distanceMapRange;\n  let uploadedSplatCount;\n  let Constants;\n\n  function sort(\n    splatSortCount,\n    splatRenderCount,\n    modelViewProj,\n    usePrecomputedDistances,\n    copyIndexesToSort,\n    copyPrecomputedDistances,\n    copyTransforms,\n  ) {\n    const sortStartTime = performance.now();\n\n    if (!useSharedMemory) {\n      const indexesToSort = new Uint32Array(\n        wasmMemory,\n        indexesToSortOffset,\n        copyIndexesToSort.byteLength / Constants.BytesPerInt,\n      );\n      indexesToSort.set(copyIndexesToSort);\n      const transforms = new Float32Array(\n        wasmMemory,\n        transformsOffset,\n        copyTransforms.byteLength / Constants.BytesPerFloat,\n      );\n      transforms.set(copyTransforms);\n      if (usePrecomputedDistances) {\n        let precomputedDistances;\n        if (integerBasedSort) {\n          precomputedDistances = new Int32Array(\n            wasmMemory,\n            precomputedDistancesOffset,\n            copyPrecomputedDistances.byteLength / Constants.BytesPerInt,\n          );\n        } else {\n          precomputedDistances = new Float32Array(\n            wasmMemory,\n            precomputedDistancesOffset,\n            copyPrecomputedDistances.byteLength / Constants.BytesPerFloat,\n          );\n        }\n        precomputedDistances.set(copyPrecomputedDistances);\n      }\n    }\n\n    if (!countsZero) countsZero = new Uint32Array(distanceMapRange);\n    new Float32Array(wasmMemory, modelViewProjOffset, 16).set(modelViewProj);\n    new Uint32Array(wasmMemory, frequenciesOffset, distanceMapRange).set(\n      countsZero,\n    );\n    wasmInstance.exports.sortIndexes(\n      indexesToSortOffset,\n      centersOffset,\n      precomputedDistancesOffset,\n      mappedDistancesOffset,\n      frequenciesOffset,\n      modelViewProjOffset,\n      sortedIndexesOffset,\n      sceneIndexesOffset,\n      transformsOffset,\n      distanceMapRange,\n      splatSortCount,\n      splatRenderCount,\n      splatCount,\n      usePrecomputedDistances,\n      integerBasedSort,\n      dynamicMode,\n    );\n\n    const sortMessage = {\n      sortDone: true,\n      splatSortCount: splatSortCount,\n      splatRenderCount: splatRenderCount,\n      sortTime: 0,\n    };\n    if (!useSharedMemory) {\n      const sortedIndexes = new Uint32Array(\n        wasmMemory,\n        sortedIndexesOffset,\n        splatRenderCount,\n      );\n      if (!sortedIndexesOut || sortedIndexesOut.length < splatRenderCount) {\n        sortedIndexesOut = new Uint32Array(splatRenderCount);\n      }\n      sortedIndexesOut.set(sortedIndexes);\n      sortMessage.sortedIndexes = sortedIndexesOut;\n    }\n    const sortEndTime = performance.now();\n\n    sortMessage.sortTime = sortEndTime - sortStartTime;\n\n    self.postMessage(sortMessage);\n  }\n\n  self.onmessage = (e) => {\n    if (e.data.centers) {\n      centers = e.data.centers;\n      sceneIndexes = e.data.sceneIndexes;\n      if (integerBasedSort) {\n        new Int32Array(\n          wasmMemory,\n          centersOffset + e.data.range.from * Constants.BytesPerInt * 4,\n          e.data.range.count * 4,\n        ).set(new Int32Array(centers));\n      } else {\n        new Float32Array(\n          wasmMemory,\n          centersOffset + e.data.range.from * Constants.BytesPerFloat * 4,\n          e.data.range.count * 4,\n        ).set(new Float32Array(centers));\n      }\n      if (dynamicMode) {\n        new Uint32Array(\n          wasmMemory,\n          sceneIndexesOffset + e.data.range.from * 4,\n          e.data.range.count,\n        ).set(new Uint32Array(sceneIndexes));\n      }\n      uploadedSplatCount = e.data.range.from + e.data.range.count;\n    } else if (e.data.sort) {\n      const renderCount = Math.min(\n        e.data.sort.splatRenderCount || 0,\n        uploadedSplatCount,\n      );\n      const sortCount = Math.min(\n        e.data.sort.splatSortCount || 0,\n        uploadedSplatCount,\n      );\n      const usePrecomputedDistances = e.data.sort.usePrecomputedDistances;\n\n      let copyIndexesToSort;\n      let copyPrecomputedDistances;\n      let copyTransforms;\n      if (!useSharedMemory) {\n        copyIndexesToSort = e.data.sort.indexesToSort;\n        copyTransforms = e.data.sort.transforms;\n        if (usePrecomputedDistances) {\n          copyPrecomputedDistances = e.data.sort.precomputedDistances;\n        }\n      }\n      sort(\n        sortCount,\n        renderCount,\n        e.data.sort.modelViewProj,\n        usePrecomputedDistances,\n        copyIndexesToSort,\n        copyPrecomputedDistances,\n        copyTransforms,\n      );\n    } else if (e.data.init) {\n      // Yep, this is super hacky and gross :(\n      Constants = e.data.init.Constants;\n\n      splatCount = e.data.init.splatCount;\n      useSharedMemory = e.data.init.useSharedMemory;\n      integerBasedSort = e.data.init.integerBasedSort;\n      dynamicMode = e.data.init.dynamicMode;\n      distanceMapRange = e.data.init.distanceMapRange;\n      uploadedSplatCount = 0;\n\n      const CENTERS_BYTES_PER_ENTRY = integerBasedSort ?\n        Constants.BytesPerInt * 4 :\n        Constants.BytesPerFloat * 4;\n\n      const sorterWasmBytes = new Uint8Array(e.data.init.sorterWasmBytes);\n\n      const matrixSize = 16 * Constants.BytesPerFloat;\n      const memoryRequiredForIndexesToSort = splatCount * Constants.BytesPerInt;\n      const memoryRequiredForCenters = splatCount * CENTERS_BYTES_PER_ENTRY;\n      const memoryRequiredForModelViewProjectionMatrix = matrixSize;\n      const memoryRequiredForPrecomputedDistances = integerBasedSort ?\n        splatCount * Constants.BytesPerInt :\n        splatCount * Constants.BytesPerFloat;\n      const memoryRequiredForMappedDistances =\n        splatCount * Constants.BytesPerInt;\n      const memoryRequiredForSortedIndexes = splatCount * Constants.BytesPerInt;\n      const memoryRequiredForIntermediateSortBuffers = integerBasedSort ?\n        distanceMapRange * Constants.BytesPerInt * 2 :\n        distanceMapRange * Constants.BytesPerFloat * 2;\n      const memoryRequiredforTransformIndexes = dynamicMode ?\n        splatCount * Constants.BytesPerInt :\n        0;\n      const memoryRequiredforTransforms = dynamicMode ?\n        Constants.MaxScenes * matrixSize :\n        0;\n      const extraMemory = Constants.MemoryPageSize * 32;\n\n      const totalRequiredMemory =\n        memoryRequiredForIndexesToSort +\n        memoryRequiredForCenters +\n        memoryRequiredForModelViewProjectionMatrix +\n        memoryRequiredForPrecomputedDistances +\n        memoryRequiredForMappedDistances +\n        memoryRequiredForIntermediateSortBuffers +\n        memoryRequiredForSortedIndexes +\n        memoryRequiredforTransformIndexes +\n        memoryRequiredforTransforms +\n        extraMemory;\n      const totalPagesRequired =\n        Math.floor(totalRequiredMemory / Constants.MemoryPageSize) + 1;\n      const sorterWasmImport = {\n        module: {},\n        env: {\n          memory: new WebAssembly.Memory({\n            initial: totalPagesRequired,\n            maximum: totalPagesRequired,\n            shared: true,\n          }),\n        },\n      };\n      WebAssembly.compile(sorterWasmBytes)\n        .then((wasmModule) => {\n          return WebAssembly.instantiate(wasmModule, sorterWasmImport);\n        })\n        .then((instance) => {\n          wasmInstance = instance;\n          indexesToSortOffset = 0;\n          centersOffset = indexesToSortOffset + memoryRequiredForIndexesToSort;\n          modelViewProjOffset = centersOffset + memoryRequiredForCenters;\n          precomputedDistancesOffset =\n            modelViewProjOffset + memoryRequiredForModelViewProjectionMatrix;\n          mappedDistancesOffset =\n            precomputedDistancesOffset + memoryRequiredForPrecomputedDistances;\n          frequenciesOffset =\n            mappedDistancesOffset + memoryRequiredForMappedDistances;\n          sortedIndexesOffset =\n            frequenciesOffset + memoryRequiredForIntermediateSortBuffers;\n          sceneIndexesOffset =\n            sortedIndexesOffset + memoryRequiredForSortedIndexes;\n          transformsOffset =\n            sceneIndexesOffset + memoryRequiredforTransformIndexes;\n          wasmMemory = sorterWasmImport.env.memory.buffer;\n          if (useSharedMemory) {\n            self.postMessage({\n              sortSetupPhase1Complete: true,\n              indexesToSortBuffer: wasmMemory,\n              indexesToSortOffset: indexesToSortOffset,\n              sortedIndexesBuffer: wasmMemory,\n              sortedIndexesOffset: sortedIndexesOffset,\n              precomputedDistancesBuffer: wasmMemory,\n              precomputedDistancesOffset: precomputedDistancesOffset,\n              transformsBuffer: wasmMemory,\n              transformsOffset: transformsOffset,\n            });\n          } else {\n            self.postMessage({\n              sortSetupPhase1Complete: true,\n            });\n          }\n        });\n    }\n  };\n}\n\nexport function createSortWorker(\n  splatCount,\n  useSharedMemory,\n  enableSIMDInSort,\n  integerBasedSort,\n  dynamicMode,\n  splatSortDistanceMapPrecision = Constants.DefaultSplatSortDistanceMapPrecision,\n) {\n  const worker = new Worker(\n    URL.createObjectURL(\n      new Blob(['(', sortWorker.toString(), ')(self)'], {\n        type: 'application/javascript',\n      }),\n    ),\n  );\n\n  let sourceWasm = SorterWasm;\n\n  // iOS makes choosing the right WebAssembly configuration tricky :(\n  const iOSSemVer = isIOS() ? getIOSSemever() : null;\n  if (!enableSIMDInSort && !useSharedMemory) {\n    sourceWasm = SorterWasmNoSIMD;\n    // Testing on various devices has shown that even when shared memory is disabled, the WASM module with shared\n    // memory can still be used most of the time -- the exception seems to be iOS devices below 16.4\n    if (iOSSemVer && iOSSemVer.major <= 16 && iOSSemVer.minor < 4) {\n      sourceWasm = SorterWasmNoSIMDNonShared;\n    }\n  } else if (!enableSIMDInSort) {\n    sourceWasm = SorterWasmNoSIMD;\n  } else if (!useSharedMemory) {\n    // Same issue with shared memory as above on iOS devices\n    if (iOSSemVer && iOSSemVer.major <= 16 && iOSSemVer.minor < 4) {\n      sourceWasm = SorterWasmNonShared;\n    }\n  }\n\n  const sorterWasmBinaryString = atob(sourceWasm);\n  const sorterWasmBytes = new Uint8Array(sorterWasmBinaryString.length);\n  for (let i = 0; i < sorterWasmBinaryString.length; i++) {\n    sorterWasmBytes[i] = sorterWasmBinaryString.charCodeAt(i);\n  }\n\n  worker.postMessage({\n    init: {\n      sorterWasmBytes: sorterWasmBytes.buffer,\n      splatCount: splatCount,\n      useSharedMemory: useSharedMemory,\n      integerBasedSort: integerBasedSort,\n      dynamicMode: dynamicMode,\n      distanceMapRange: 1 << splatSortDistanceMapPrecision,\n      // Super hacky\n      Constants: {\n        BytesPerFloat: Constants.BytesPerFloat,\n        BytesPerInt: Constants.BytesPerInt,\n        MemoryPageSize: Constants.MemoryPageSize,\n        MaxScenes: Constants.MaxScenes,\n      },\n    },\n  });\n  return worker;\n}\n","import * as THREE from 'three';\nimport { AbortablePromise, AbortedPromiseError } from './AbortablePromise.js';\nimport { Constants } from './Constants.js';\nimport { LogLevel } from './LogLevel.js';\nimport { OrbitControls } from './OrbitControls.js';\nimport { RenderMode } from './RenderMode.js';\nimport { SceneHelper } from './SceneHelper.js';\nimport { SceneRevealMode } from './SceneRevealMode.js';\nimport { SplatRenderMode } from './SplatRenderMode.js';\nimport {\n  abortablePromiseWithExtractedComponents,\n  clamp,\n  delayedExecute,\n  getCurrentTime,\n  getIOSSemever,\n  isIOS,\n  makeProgressiveFetchFunction,\n} from './Util.js';\nimport { DirectLoadError } from './loaders/DirectLoadError.js';\nimport { LoaderStatus } from './loaders/LoaderStatus.js';\nimport { SceneFormat } from './loaders/SceneFormat.js';\nimport { sceneFormatFromPath } from './loaders/Utils.js';\nimport { KSplatLoader } from './loaders/ksplat/KSplatLoader.js';\nimport { PlyLoader } from './loaders/ply/PlyLoader.js';\nimport { SplatLoader } from './loaders/splat/SplatLoader.js';\nimport { GLTFLoader } from './loaders/splat/gltf/GLTFLoader.js';\nimport { Raycaster } from './raycaster/Raycaster.js';\nimport { SplatMesh } from './splatmesh/SplatMesh.js';\nimport { InfoPanel } from './ui/InfoPanel.js';\nimport { LoadingProgressBar } from './ui/LoadingProgressBar.js';\nimport { LoadingSpinner } from './ui/LoadingSpinner.js';\nimport { ARButton } from './webxr/ARButton.js';\nimport { VRButton } from './webxr/VRButton.js';\nimport { WebXRMode } from './webxr/WebXRMode.js';\nimport { createSortWorker } from './worker/SortWorker.js';\n\nconst THREE_CAMERA_FOV = 50;\nconst MINIMUM_DISTANCE_TO_NEW_FOCAL_POINT = 0.75;\nconst MIN_SPLAT_COUNT_TO_SHOW_SPLAT_TREE_LOADING_SPINNER = 1500000;\nconst FOCUS_MARKER_FADE_IN_SPEED = 10.0;\nconst FOCUS_MARKER_FADE_OUT_SPEED = 2.5;\nconst CONSECUTIVE_RENDERED_FRAMES_FOR_FPS_CALCULATION = 60;\n\n/**\n * Viewer: Manages the rendering of splat scenes. Manages an instance of SplatMesh as well as a web worker\n * that performs the sort for its splats.\n */\nexport class Viewer {\n  constructor(options = {}) {\n    // The natural 'up' vector for viewing the scene (only has an effect when used with orbit controls and\n    // when the viewer uses its own camera).\n    if (!options.cameraUp) options.cameraUp = [0, 1, 0];\n    this.cameraUp = new THREE.Vector3().fromArray(options.cameraUp);\n\n    // The camera's initial position (only used when the viewer uses its own camera).\n    if (!options.initialCameraPosition) {\n      options.initialCameraPosition = [0, 10, 15];\n    }\n    this.initialCameraPosition = new THREE.Vector3().fromArray(\n      options.initialCameraPosition,\n    );\n\n    // The initial focal point of the camera and center of the camera's orbit (only used when the viewer uses its own camera).\n    if (!options.initialCameraLookAt) options.initialCameraLookAt = [0, 0, 0];\n    this.initialCameraLookAt = new THREE.Vector3().fromArray(\n      options.initialCameraLookAt,\n    );\n\n    // 'dropInMode' is a flag that is used internally to support the usage of the viewer as a Three.js scene object\n    this.dropInMode = options.dropInMode || false;\n\n    // If 'selfDrivenMode' is true, the viewer manages its own update/animation loop via requestAnimationFrame()\n    if (\n      options.selfDrivenMode === undefined ||\n      options.selfDrivenMode === null\n    ) {\n      options.selfDrivenMode = true;\n    }\n    this.selfDrivenMode = options.selfDrivenMode && !this.dropInMode;\n    this.selfDrivenUpdateFunc = this.selfDrivenUpdate.bind(this);\n\n    // If 'useBuiltInControls' is true, the viewer will create its own instance of OrbitControls and attach to the camera\n    if (options.useBuiltInControls === undefined) {\n      options.useBuiltInControls = true;\n    }\n    this.useBuiltInControls = options.useBuiltInControls;\n\n    // parent element of the Three.js renderer canvas\n    this.rootElement = options.rootElement;\n\n    // Tells the viewer to pretend the device pixel ratio is 1, which can boost performance on devices where it is larger,\n    // at a small cost to visual quality\n    this.ignoreDevicePixelRatio = options.ignoreDevicePixelRatio || false;\n    this.devicePixelRatio = this.ignoreDevicePixelRatio ?\n      1 :\n      window.devicePixelRatio;\n\n    // Tells the viewer to use 16-bit floating point values when storing splat covariance data in textures, instead of 32-bit\n    this.halfPrecisionCovariancesOnGPU =\n      options.halfPrecisionCovariancesOnGPU || false;\n\n    // If 'threeScene' is valid, it will be rendered by the viewer along with the splat mesh\n    this.threeScene = options.threeScene;\n    // Allows for usage of an external Three.js renderer\n    this.renderer = options.renderer;\n    // Allows for usage of an external Three.js camera\n    this.camera = options.camera;\n\n    // If 'gpuAcceleratedSort' is true, a partially GPU-accelerated approach to sorting splats will be used.\n    // Currently this means pre-computing splat distances from the camera on the GPU\n    this.gpuAcceleratedSort = options.gpuAcceleratedSort || false;\n\n    // if 'integerBasedSort' is true, the integer version of splat centers as well as other values used to calculate\n    // splat distances are used instead of the float version. This speeds up computation, but introduces the possibility of\n    // overflow in larger scenes.\n    if (\n      options.integerBasedSort === undefined ||\n      options.integerBasedSort === null\n    ) {\n      options.integerBasedSort = true;\n    }\n    this.integerBasedSort = options.integerBasedSort;\n\n    // If 'sharedMemoryForWorkers' is true, a SharedArrayBuffer will be used to communicate with web workers. This method\n    // is faster than copying memory to or from web workers, but comes with security implications as outlined here:\n    // https://web.dev/articles/cross-origin-isolation-guide\n    // If enabled, it requires specific CORS headers to be present in the response from the server that is sent when\n    // loading the application. More information is available in the README.\n    if (\n      options.sharedMemoryForWorkers === undefined ||\n      options.sharedMemoryForWorkers === null\n    ) {\n      options.sharedMemoryForWorkers = true;\n    }\n    this.sharedMemoryForWorkers = options.sharedMemoryForWorkers;\n\n    // if 'dynamicScene' is true, it tells the viewer to assume scene elements are not stationary or that the number of splats in the\n    // scene may change. This prevents optimizations that depend on a static scene from being made. Additionally, if 'dynamicScene' is\n    // true it tells the splat mesh to not apply scene tranforms to splat data that is returned by functions like\n    // SplatMesh.getSplatCenter() by default.\n    this.dynamicScene = !!options.dynamicScene;\n\n    // When true, will perform additional steps during rendering to address artifacts caused by the rendering of gaussians at a\n    // substantially different resolution than that at which they were rendered during training. This will only work correctly\n    // for models that were trained using a process that utilizes this compensation calculation. For more details:\n    // https://github.com/nerfstudio-project/gsplat/pull/117\n    // https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093\n    this.antialiased = options.antialiased || false;\n\n    this.webXRMode = options.webXRMode || WebXRMode.None;\n    if (this.webXRMode !== WebXRMode.None) {\n      this.gpuAcceleratedSort = false;\n    }\n    this.webXRActive = false;\n\n    this.webXRSessionInit = options.webXRSessionInit || {};\n\n    // if 'renderMode' is RenderMode.Always, then the viewer will rrender the scene on every update. If it is RenderMode.OnChange,\n    // it will only render when something in the scene has changed.\n    this.renderMode = options.renderMode || RenderMode.Always;\n\n    // SceneRevealMode.Default results in a nice, slow fade-in effect for progressively loaded scenes,\n    // and a fast fade-in for non progressively loaded scenes.\n    // SceneRevealMode.Gradual will force a slow fade-in for all scenes.\n    // SceneRevealMode.Instant will force all loaded scene data to be immediately visible.\n    this.sceneRevealMode = options.sceneRevealMode || SceneRevealMode.Default;\n\n    // Hacky, experimental, non-scientific parameter for tweaking focal length related calculations. For scenes with very\n    // small gaussians, small details, and small dimensions -- increasing this value can help improve visual quality.\n    this.focalAdjustment = options.focalAdjustment || 1.0;\n\n    // Specify the maximum screen-space splat size, can help deal with large splats that get too unwieldy\n    this.maxScreenSpaceSplatSize = options.maxScreenSpaceSplatSize || 1024;\n\n    // The verbosity of console logging\n    this.logLevel = options.logLevel || LogLevel.None;\n\n    // Degree of spherical harmonics to utilize in rendering splats (assuming the data is present in the splat scene).\n    // Valid values are 0 - 2. Default value is 0.\n    this.sphericalHarmonicsDegree = options.sphericalHarmonicsDegree || 0;\n\n    // When true, allows for usage of extra properties and attributes during rendering for effects such as opacity adjustment.\n    // Default is false for performance reasons. These properties are separate from transform properties (scale, rotation, position)\n    // that are enabled by the 'dynamicScene' parameter.\n    this.enableOptionalEffects = options.enableOptionalEffects || false;\n\n    // Enable the usage of SIMD WebAssembly instructions for the splat sort\n    if (\n      options.enableSIMDInSort === undefined ||\n      options.enableSIMDInSort === null\n    ) {\n      options.enableSIMDInSort = true;\n    }\n    this.enableSIMDInSort = options.enableSIMDInSort;\n\n    // Level to compress non KSPLAT files when loading them for direct rendering\n    if (\n      options.inMemoryCompressionLevel === undefined ||\n      options.inMemoryCompressionLevel === null\n    ) {\n      options.inMemoryCompressionLevel = 0;\n    }\n    this.inMemoryCompressionLevel = options.inMemoryCompressionLevel;\n\n    // Reorder splat data in memory after loading is complete to optimize cache utilization. Default is true.\n    // Does not apply if splat scene is progressively loaded.\n    if (\n      options.optimizeSplatData === undefined ||\n      options.optimizeSplatData === null\n    ) {\n      options.optimizeSplatData = true;\n    }\n    this.optimizeSplatData = options.optimizeSplatData;\n\n    // When true, the intermediate splat data that is the result of decompressing splat bufffer(s) and is used to\n    // populate the data textures will be freed. This will reduces memory usage, but if that data needs to be modified\n    // it will need to be re-populated from the splat buffer(s). Default is false.\n    if (\n      options.freeIntermediateSplatData === undefined ||\n      options.freeIntermediateSplatData === null\n    ) {\n      options.freeIntermediateSplatData = false;\n    }\n    this.freeIntermediateSplatData = options.freeIntermediateSplatData;\n\n    // It appears that for certain iOS versions, special actions need to be taken with the\n    // usage of SIMD instructions and shared memory\n    if (isIOS()) {\n      const semver = getIOSSemever();\n      if (semver.major < 17) {\n        this.enableSIMDInSort = false;\n      }\n      if (semver.major < 16) {\n        this.sharedMemoryForWorkers = false;\n      }\n    }\n\n    // Tell the viewer how to render the splats\n    if (\n      options.splatRenderMode === undefined ||\n      options.splatRenderMode === null\n    ) {\n      options.splatRenderMode = SplatRenderMode.ThreeD;\n    }\n    this.splatRenderMode = options.splatRenderMode;\n\n    // Customize the speed at which the scene is revealed\n    this.sceneFadeInRateMultiplier = options.sceneFadeInRateMultiplier || 1.0;\n\n    // Set the range for the depth map for the counting sort used to sort the splats\n    this.splatSortDistanceMapPrecision =\n      options.splatSortDistanceMapPrecision ||\n      Constants.DefaultSplatSortDistanceMapPrecision;\n    const maxPrecision = this.integerBasedSort ? 20 : 24;\n    this.splatSortDistanceMapPrecision = clamp(\n      this.splatSortDistanceMapPrecision,\n      10,\n      maxPrecision,\n    );\n\n    this.onSplatMeshChangedCallback = null;\n    this.createSplatMesh();\n\n    this.controls = null;\n    this.perspectiveControls = null;\n    this.orthographicControls = null;\n\n    this.orthographicCamera = null;\n    this.perspectiveCamera = null;\n\n    this.showMeshCursor = false;\n    this.showControlPlane = false;\n    this.showInfo = false;\n\n    this.sceneHelper = null;\n\n    this.sortWorker = null;\n    this.sortRunning = false;\n    this.splatRenderCount = 0;\n    this.splatSortCount = 0;\n    this.lastSplatSortCount = 0;\n    this.sortWorkerIndexesToSort = null;\n    this.sortWorkerSortedIndexes = null;\n    this.sortWorkerPrecomputedDistances = null;\n    this.sortWorkerTransforms = null;\n    this.preSortMessages = [];\n    this.runAfterNextSort = [];\n\n    this.selfDrivenModeRunning = false;\n    this.splatRenderReady = false;\n\n    this.raycaster = new Raycaster();\n\n    this.infoPanel = null;\n\n    this.startInOrthographicMode = false;\n\n    this.currentFPS = 0;\n    this.lastSortTime = 0;\n    this.consecutiveRenderFrames = 0;\n\n    this.previousCameraTarget = new THREE.Vector3();\n    this.nextCameraTarget = new THREE.Vector3();\n\n    this.mousePosition = new THREE.Vector2();\n    this.mouseDownPosition = new THREE.Vector2();\n    this.mouseDownTime = null;\n\n    this.resizeObserver = null;\n    this.mouseMoveListener = null;\n    this.mouseDownListener = null;\n    this.mouseUpListener = null;\n    this.keyDownListener = null;\n\n    this.sortPromise = null;\n    this.sortPromiseResolver = null;\n    this.splatSceneDownloadPromises = {};\n    this.splatSceneDownloadAndBuildPromise = null;\n    this.splatSceneRemovalPromise = null;\n\n    this.loadingSpinner = new LoadingSpinner(\n      null,\n      this.rootElement || document.body,\n    );\n    this.loadingSpinner.hide();\n    this.loadingProgressBar = new LoadingProgressBar(\n      this.rootElement || document.body,\n    );\n    this.loadingProgressBar.hide();\n    this.infoPanel = new InfoPanel(this.rootElement || document.body);\n    this.infoPanel.hide();\n\n    this.usingExternalCamera = this.dropInMode || this.camera ? true : false;\n    this.usingExternalRenderer =\n      this.dropInMode || this.renderer ? true : false;\n\n    this.initialized = false;\n    this.disposing = false;\n    this.disposed = false;\n    this.disposePromise = null;\n\n    this.fetch = options.fetch || ((url, opts) => fetch(url, opts));\n    this.fetchWithProgress = makeProgressiveFetchFunction(this.fetch);\n\n    this.unprojectMousePosition = this.unprojectPositionFromSplats.bind(this);\n\n    if (!this.dropInMode) this.init();\n  }\n\n  createSplatMesh() {\n    this.splatMesh = new SplatMesh(\n      this.splatRenderMode,\n      this.dynamicScene,\n      this.enableOptionalEffects,\n      this.halfPrecisionCovariancesOnGPU,\n      this.devicePixelRatio,\n      this.gpuAcceleratedSort,\n      this.integerBasedSort,\n      this.antialiased,\n      this.maxScreenSpaceSplatSize,\n      this.logLevel,\n      this.sphericalHarmonicsDegree,\n      this.sceneFadeInRateMultiplier,\n    );\n    this.splatMesh.frustumCulled = false;\n    if (this.onSplatMeshChangedCallback) this.onSplatMeshChangedCallback();\n  }\n\n  init() {\n    if (this.initialized) return;\n\n    if (!this.rootElement) {\n      if (!this.usingExternalRenderer) {\n        this.rootElement = document.createElement('div');\n        this.rootElement.style.width = '100%';\n        this.rootElement.style.height = '100%';\n        this.rootElement.style.position = 'absolute';\n        document.body.appendChild(this.rootElement);\n      } else {\n        this.rootElement =\n          this.renderer.domElement.parentElement || document.body;\n      }\n    }\n\n    this.setupCamera();\n    this.setupRenderer();\n    this.setupWebXR(this.webXRSessionInit);\n    this.setupControls();\n    this.setupEventHandlers();\n\n    this.threeScene = this.threeScene || new THREE.Scene();\n    this.sceneHelper = new SceneHelper(this.threeScene);\n    this.sceneHelper.setupMeshCursor();\n    this.sceneHelper.setupFocusMarker();\n    this.sceneHelper.setupControlPlane();\n\n    this.loadingProgressBar.setContainer(this.rootElement);\n    this.loadingSpinner.setContainer(this.rootElement);\n    this.infoPanel.setContainer(this.rootElement);\n\n    this.initialized = true;\n  }\n\n  setupCamera() {\n    if (!this.usingExternalCamera) {\n      const renderDimensions = new THREE.Vector2();\n      this.getRenderDimensions(renderDimensions);\n\n      this.perspectiveCamera = new THREE.PerspectiveCamera(\n        THREE_CAMERA_FOV,\n        renderDimensions.x / renderDimensions.y,\n        0.1,\n        1000,\n      );\n      this.orthographicCamera = new THREE.OrthographicCamera(\n        renderDimensions.x / -2,\n        renderDimensions.x / 2,\n        renderDimensions.y / 2,\n        renderDimensions.y / -2,\n        0.1,\n        1000,\n      );\n      this.camera = this.startInOrthographicMode ?\n        this.orthographicCamera :\n        this.perspectiveCamera;\n      this.camera.position.copy(this.initialCameraPosition);\n      this.camera.up.copy(this.cameraUp).normalize();\n      this.camera.lookAt(this.initialCameraLookAt);\n    }\n  }\n\n  setupRenderer() {\n    if (!this.usingExternalRenderer) {\n      const renderDimensions = new THREE.Vector2();\n      this.getRenderDimensions(renderDimensions);\n\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: false,\n        precision: 'highp',\n      });\n      this.renderer.setPixelRatio(this.devicePixelRatio);\n      this.renderer.autoClear = true;\n      this.renderer.setClearColor(new THREE.Color(0x000000), 0.0);\n      this.renderer.setSize(renderDimensions.x, renderDimensions.y);\n\n      this.resizeObserver = new ResizeObserver(() => {\n        this.getRenderDimensions(renderDimensions);\n        this.renderer.setSize(renderDimensions.x, renderDimensions.y);\n        this.forceRenderNextFrame();\n      });\n      this.resizeObserver.observe(this.rootElement);\n      this.rootElement.appendChild(this.renderer.domElement);\n    }\n  }\n\n  setupWebXR(webXRSessionInit) {\n    if (this.webXRMode) {\n      if (this.webXRMode === WebXRMode.VR) {\n        this.rootElement.appendChild(\n          VRButton.createButton(this.renderer, webXRSessionInit),\n        );\n      } else if (this.webXRMode === WebXRMode.AR) {\n        this.rootElement.appendChild(\n          ARButton.createButton(this.renderer, webXRSessionInit),\n        );\n      }\n      this.renderer.xr.addEventListener('sessionstart', (e) => {\n        this.webXRActive = true;\n      });\n      this.renderer.xr.addEventListener('sessionend', (e) => {\n        this.webXRActive = false;\n      });\n      this.renderer.xr.enabled = true;\n      this.camera.position.copy(this.initialCameraPosition);\n      this.camera.up.copy(this.cameraUp).normalize();\n      this.camera.lookAt(this.initialCameraLookAt);\n    }\n  }\n\n  setupControls() {\n    if (this.useBuiltInControls && this.webXRMode === WebXRMode.None) {\n      if (!this.usingExternalCamera) {\n        this.perspectiveControls = new OrbitControls(\n          this.perspectiveCamera,\n          this.renderer.domElement,\n        );\n        this.orthographicControls = new OrbitControls(\n          this.orthographicCamera,\n          this.renderer.domElement,\n        );\n      } else {\n        if (this.camera.isOrthographicCamera) {\n          this.orthographicControls = new OrbitControls(\n            this.camera,\n            this.renderer.domElement,\n          );\n        } else {\n          this.perspectiveControls = new OrbitControls(\n            this.camera,\n            this.renderer.domElement,\n          );\n        }\n      }\n      for (let controls of [\n        this.orthographicControls,\n        this.perspectiveControls,\n      ]) {\n        if (controls) {\n          controls.listenToKeyEvents(window);\n          controls.rotateSpeed = 0.5;\n          controls.maxPolarAngle = Math.PI * 0.75;\n          controls.minPolarAngle = 0.1;\n          controls.enableDamping = true;\n          controls.dampingFactor = 0.05;\n          controls.target.copy(this.initialCameraLookAt);\n          controls.update();\n        }\n      }\n      this.controls = this.camera.isOrthographicCamera ?\n        this.orthographicControls :\n        this.perspectiveControls;\n      this.controls.update();\n    }\n  }\n\n  setupEventHandlers() {\n    if (this.useBuiltInControls && this.webXRMode === WebXRMode.None) {\n      this.mouseMoveListener = this.onMouseMove.bind(this);\n      this.renderer.domElement.addEventListener(\n        'pointermove',\n        this.mouseMoveListener,\n        false,\n      );\n      this.mouseDownListener = this.onMouseDown.bind(this);\n      this.renderer.domElement.addEventListener(\n        'pointerdown',\n        this.mouseDownListener,\n        false,\n      );\n      this.mouseUpListener = this.onMouseUp.bind(this);\n      this.renderer.domElement.addEventListener(\n        'pointerup',\n        this.mouseUpListener,\n        false,\n      );\n      this.keyDownListener = this.onKeyDown.bind(this);\n      window.addEventListener('keydown', this.keyDownListener, false);\n    }\n  }\n\n  removeEventHandlers() {\n    if (this.useBuiltInControls) {\n      this.renderer.domElement.removeEventListener(\n        'pointermove',\n        this.mouseMoveListener,\n      );\n      this.mouseMoveListener = null;\n      this.renderer.domElement.removeEventListener(\n        'pointerdown',\n        this.mouseDownListener,\n      );\n      this.mouseDownListener = null;\n      this.renderer.domElement.removeEventListener(\n        'pointerup',\n        this.mouseUpListener,\n      );\n      this.mouseUpListener = null;\n      window.removeEventListener('keydown', this.keyDownListener);\n      this.keyDownListener = null;\n    }\n  }\n\n  setRenderMode(renderMode) {\n    this.renderMode = renderMode;\n  }\n\n  setActiveSphericalHarmonicsDegrees(activeSphericalHarmonicsDegrees) {\n    this.splatMesh.material.uniforms.sphericalHarmonicsDegree.value =\n      activeSphericalHarmonicsDegrees;\n    this.splatMesh.material.uniformsNeedUpdate = true;\n  }\n\n  onSplatMeshChanged(callback) {\n    this.onSplatMeshChangedCallback = callback;\n  }\n\n  onKeyDown = (function() {\n    const forward = new THREE.Vector3();\n    const tempMatrixLeft = new THREE.Matrix4();\n    const tempMatrixRight = new THREE.Matrix4();\n\n    return function(e) {\n      forward.set(0, 0, -1);\n      forward.transformDirection(this.camera.matrixWorld);\n      tempMatrixLeft.makeRotationAxis(forward, Math.PI / 128);\n      tempMatrixRight.makeRotationAxis(forward, -Math.PI / 128);\n      switch (e.code) {\n        case 'KeyG':\n          this.focalAdjustment += 0.02;\n          this.forceRenderNextFrame();\n          break;\n        case 'KeyF':\n          this.focalAdjustment -= 0.02;\n          this.forceRenderNextFrame();\n          break;\n        case 'ArrowLeft':\n          this.camera.up.transformDirection(tempMatrixLeft);\n          break;\n        case 'ArrowRight':\n          this.camera.up.transformDirection(tempMatrixRight);\n          break;\n        case 'KeyC':\n          this.showMeshCursor = !this.showMeshCursor;\n          break;\n        case 'KeyU':\n          this.showControlPlane = !this.showControlPlane;\n          break;\n        case 'KeyI':\n          this.showInfo = !this.showInfo;\n          if (this.showInfo) {\n            this.infoPanel.show();\n          } else {\n            this.infoPanel.hide();\n          }\n          break;\n        case 'KeyO':\n          if (!this.usingExternalCamera) {\n            this.setOrthographicMode(!this.camera.isOrthographicCamera);\n          }\n          break;\n        case 'KeyP':\n          if (!this.usingExternalCamera) {\n            this.splatMesh.setPointCloudModeEnabled(\n              !this.splatMesh.getPointCloudModeEnabled(),\n            );\n          }\n          break;\n        case 'Equal':\n          if (!this.usingExternalCamera) {\n            this.splatMesh.setSplatScale(this.splatMesh.getSplatScale() + 0.05);\n          }\n          break;\n        case 'Minus':\n          if (!this.usingExternalCamera) {\n            this.splatMesh.setSplatScale(\n              Math.max(this.splatMesh.getSplatScale() - 0.05, 0.0),\n            );\n          }\n          break;\n      }\n    };\n  })();\n\n  onMouseMove(mouse) {\n    this.mousePosition.set(mouse.offsetX, mouse.offsetY);\n  }\n\n  onMouseDown() {\n    this.mouseDownPosition.copy(this.mousePosition);\n    this.mouseDownTime = getCurrentTime();\n  }\n\n  onMouseUp = (function() {\n    const clickOffset = new THREE.Vector2();\n\n    return function(mouse) {\n      clickOffset.copy(this.mousePosition).sub(this.mouseDownPosition);\n      const mouseUpTime = getCurrentTime();\n      const wasClick =\n        mouseUpTime - this.mouseDownTime < 0.5 && clickOffset.length() < 2;\n      if (wasClick) {\n        this.onMouseClick(mouse);\n      }\n    };\n  })();\n\n  onMouseClick(mouse) {\n    this.mousePosition.set(mouse.offsetX, mouse.offsetY);\n    this.checkForFocalPointChange();\n  }\n\n  checkForFocalPointChange = (function() {\n    const renderDimensions = new THREE.Vector2();\n    const toNewFocalPoint = new THREE.Vector3();\n    const outHits = [];\n\n    return function() {\n      if (!this.transitioningCameraTarget) {\n        this.getRenderDimensions(renderDimensions);\n        outHits.length = 0;\n        this.raycaster.setFromCameraAndScreenPosition(\n          this.camera,\n          this.mousePosition,\n          renderDimensions,\n        );\n        this.raycaster.intersectSplatMesh(this.splatMesh, outHits);\n        if (outHits.length > 0) {\n          const hit = outHits[0];\n          const intersectionPoint = hit.origin;\n          toNewFocalPoint.copy(intersectionPoint).sub(this.camera.position);\n          if (toNewFocalPoint.length() > MINIMUM_DISTANCE_TO_NEW_FOCAL_POINT) {\n            this.previousCameraTarget.copy(this.controls.target);\n            this.nextCameraTarget.copy(intersectionPoint);\n            this.transitioningCameraTarget = true;\n            this.transitioningCameraTargetStartTime = getCurrentTime();\n          }\n        }\n      }\n    };\n  })();\n\n   /*\n  Proposed functionality for the interaction with the splats\n  The camera is the persepective camera used to render\n  The mousePosition parameter is the normalised position of the mouse\n  relative to the screen.\n\n  Uses the raycaster to traverse to the different splats to check\n  collisions with the ray and decide which one to use.\n  */\n  unprojectPositionFromSplats(renderer, camera, mousePosition) {\n    const renderDimensions = new THREE.Vector2();\n    const outHits = [];\n    renderer.getSize(renderDimensions);\n    this.raycaster.setFromCameraAndScreenPosition(\n      camera,\n      mousePosition,\n      renderDimensions,\n    );\n    this.raycaster.intersectSplatMesh(this.splatMesh, outHits);\n    if (outHits.length > 0) {\n      const hit = outHits[0];\n      return hit;\n    }\n    return null;\n  }\n\n\n  getRenderDimensions(outDimensions) {\n    if (this.rootElement) {\n      outDimensions.x = this.rootElement.offsetWidth;\n      outDimensions.y = this.rootElement.offsetHeight;\n    } else {\n      this.renderer.getSize(outDimensions);\n    }\n  }\n\n  setOrthographicMode(orthographicMode) {\n    if (orthographicMode === this.camera.isOrthographicCamera) return;\n    const fromCamera = this.camera;\n    const toCamera = orthographicMode ?\n      this.orthographicCamera :\n      this.perspectiveCamera;\n    toCamera.position.copy(fromCamera.position);\n    toCamera.up.copy(fromCamera.up);\n    toCamera.rotation.copy(fromCamera.rotation);\n    toCamera.quaternion.copy(fromCamera.quaternion);\n    toCamera.matrix.copy(fromCamera.matrix);\n    this.camera = toCamera;\n\n    if (this.controls) {\n      const resetControls = (controls) => {\n        controls.saveState();\n        controls.reset();\n      };\n\n      const fromControls = this.controls;\n      const toControls = orthographicMode ?\n        this.orthographicControls :\n        this.perspectiveControls;\n\n      resetControls(toControls);\n      resetControls(fromControls);\n\n      toControls.target.copy(fromControls.target);\n      if (orthographicMode) {\n        Viewer.setCameraZoomFromPosition(toCamera, fromCamera, fromControls);\n      } else {\n        Viewer.setCameraPositionFromZoom(toCamera, fromCamera, toControls);\n      }\n      this.controls = toControls;\n      this.camera.lookAt(this.controls.target);\n    }\n  }\n\n  static setCameraPositionFromZoom = (function() {\n    const tempVector = new THREE.Vector3();\n\n    return function(positionCamera, zoomedCamera, controls) {\n      const toLookAtDistance = 1 / (zoomedCamera.zoom * 0.001);\n      tempVector\n        .copy(controls.target)\n        .sub(positionCamera.position)\n        .normalize()\n        .multiplyScalar(toLookAtDistance)\n        .negate();\n      positionCamera.position.copy(controls.target).add(tempVector);\n    };\n  })();\n\n  static setCameraZoomFromPosition = (function() {\n    const tempVector = new THREE.Vector3();\n\n    return function(zoomCamera, positionZamera, controls) {\n      const toLookAtDistance = tempVector\n        .copy(controls.target)\n        .sub(positionZamera.position)\n        .length();\n      zoomCamera.zoom = 1 / (toLookAtDistance * 0.001);\n    };\n  })();\n\n  updateSplatMesh = (function() {\n    const renderDimensions = new THREE.Vector2();\n\n    return function() {\n      if (!this.splatMesh) return;\n      const splatCount = this.splatMesh.getSplatCount();\n      if (splatCount > 0) {\n        this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode);\n        this.splatMesh.updateTransforms();\n        this.getRenderDimensions(renderDimensions);\n        const focalLengthX =\n          this.camera.projectionMatrix.elements[0] *\n          0.5 *\n          this.devicePixelRatio *\n          renderDimensions.x;\n        const focalLengthY =\n          this.camera.projectionMatrix.elements[5] *\n          0.5 *\n          this.devicePixelRatio *\n          renderDimensions.y;\n\n        const focalMultiplier = this.camera.isOrthographicCamera ?\n          1.0 / this.devicePixelRatio :\n          1.0;\n        const focalAdjustment = this.focalAdjustment * focalMultiplier;\n        const inverseFocalAdjustment = 1.0 / focalAdjustment;\n\n        this.adjustForWebXRStereo(renderDimensions);\n        this.splatMesh.updateUniforms(\n          renderDimensions,\n          focalLengthX * focalAdjustment,\n          focalLengthY * focalAdjustment,\n          this.camera.isOrthographicCamera,\n          this.camera.zoom || 1.0,\n          inverseFocalAdjustment,\n        );\n      }\n    };\n  })();\n\n  adjustForWebXRStereo(renderDimensions) {\n    // TODO: Figure out a less hacky way to determine if stereo rendering is active\n    if (this.camera && this.webXRActive) {\n      const xrCamera = this.renderer.xr.getCamera();\n      const xrCameraProj00 = xrCamera.projectionMatrix.elements[0];\n      const cameraProj00 = this.camera.projectionMatrix.elements[0];\n      renderDimensions.x *= cameraProj00 / xrCameraProj00;\n    }\n  }\n\n  isLoadingOrUnloading() {\n    return (\n      Object.keys(this.splatSceneDownloadPromises).length > 0 ||\n      this.splatSceneDownloadAndBuildPromise !== null ||\n      this.splatSceneRemovalPromise !== null\n    );\n  }\n\n  isDisposingOrDisposed() {\n    return this.disposing || this.disposed;\n  }\n\n  addSplatSceneDownloadPromise(promise) {\n    this.splatSceneDownloadPromises[promise.id] = promise;\n  }\n\n  removeSplatSceneDownloadPromise(promise) {\n    delete this.splatSceneDownloadPromises[promise.id];\n  }\n\n  setSplatSceneDownloadAndBuildPromise(promise) {\n    this.splatSceneDownloadAndBuildPromise = promise;\n  }\n\n  clearSplatSceneDownloadAndBuildPromise() {\n    this.splatSceneDownloadAndBuildPromise = null;\n  }\n\n  /**\n   * Add a splat scene to the viewer and display any loading UI if appropriate.\n   * @param {string} path Path to splat scene to be loaded\n   * @param {object} options {\n   *\n   *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n   *                                     value (valid range: 0 - 255), defaults to 1\n   *\n   *         showLoadingUI:         Display a loading spinner while the scene is loading, defaults to true\n   *\n   *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n   *\n   *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n   *\n   *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n   *\n   *         onProgress:                 Function to be called as file data are received, or other processing occurs\n   *\n   * }\n   * @return {AbortablePromise}\n   */\n  addSplatScene(path, options = {}) {\n    if (this.isLoadingOrUnloading()) {\n      throw new Error(\n        'Cannot add splat scene while another load or unload is already in progress.',\n      );\n    }\n\n    if (this.isDisposingOrDisposed()) {\n      throw new Error('Cannot add splat scene after dispose() is called.');\n    }\n\n    if (\n      options.progressiveLoad &&\n      this.splatMesh.scenes &&\n      this.splatMesh.scenes.length > 0\n    ) {\n      console.log(\n        'addSplatScene(): \"progressiveLoad\" option ignore because there are multiple splat scenes',\n      );\n      options.progressiveLoad = false;\n    }\n\n    const format =\n      options.format !== undefined && options.format !== null ?\n        options.format :\n        sceneFormatFromPath(path);\n    const progressiveLoad =\n      Viewer.isProgressivelyLoadable(format) && options.progressiveLoad;\n    const showLoadingUI =\n      options.showLoadingUI !== undefined && options.showLoadingUI !== null ?\n        options.showLoadingUI :\n        true;\n\n    let loadingUITaskId = null;\n    if (showLoadingUI) {\n      this.loadingSpinner.removeAllTasks();\n      loadingUITaskId = this.loadingSpinner.addTask('Downloading...');\n    }\n    const hideLoadingUI = () => {\n      this.loadingProgressBar.hide();\n      this.loadingSpinner.removeAllTasks();\n    };\n\n    const onProgressUIUpdate = (\n      percentComplete,\n      percentCompleteLabel,\n      loaderStatus,\n    ) => {\n      if (showLoadingUI) {\n        if (loaderStatus === LoaderStatus.Downloading) {\n          if (percentComplete == 100) {\n            this.loadingSpinner.setMessageForTask(\n              loadingUITaskId,\n              'Download complete!',\n            );\n          } else {\n            if (progressiveLoad) {\n              this.loadingSpinner.setMessageForTask(\n                loadingUITaskId,\n                'Downloading splats...',\n              );\n            } else {\n              const suffix = percentCompleteLabel ?\n                `: ${percentCompleteLabel}` :\n                `...`;\n              this.loadingSpinner.setMessageForTask(\n                loadingUITaskId,\n                `Downloading${suffix}`,\n              );\n            }\n          }\n        } else if (loaderStatus === LoaderStatus.Processing) {\n          this.loadingSpinner.setMessageForTask(\n            loadingUITaskId,\n            'Processing splats...',\n          );\n        }\n      }\n    };\n\n    let downloadDone = false;\n    let downloadedPercentage = 0;\n    const splatBuffersAddedUIUpdate = (firstBuild, finalBuild) => {\n      if (showLoadingUI) {\n        if (\n          (firstBuild && progressiveLoad) ||\n          (finalBuild && !progressiveLoad)\n        ) {\n          this.loadingSpinner.removeTask(loadingUITaskId);\n          if (!finalBuild && !downloadDone) this.loadingProgressBar.show();\n        }\n        if (progressiveLoad) {\n          if (finalBuild) {\n            downloadDone = true;\n            this.loadingProgressBar.hide();\n          } else {\n            this.loadingProgressBar.setProgress(downloadedPercentage);\n          }\n        }\n      }\n    };\n\n    const onProgress = (\n      percentComplete,\n      percentCompleteLabel,\n      loaderStatus,\n    ) => {\n      downloadedPercentage = percentComplete;\n      onProgressUIUpdate(percentComplete, percentCompleteLabel, loaderStatus);\n      if (options.onProgress) {\n        options.onProgress(percentComplete, percentCompleteLabel, loaderStatus);\n      }\n    };\n\n    const buildSection = (splatBuffer, firstBuild, finalBuild) => {\n      if (!progressiveLoad && options.onProgress) {\n        options.onProgress(0, '0%', LoaderStatus.Processing);\n      }\n      const addSplatBufferOptions = {\n        rotation: options.rotation || options.orientation,\n        position: options.position,\n        scale: options.scale,\n        splatAlphaRemovalThreshold: options.splatAlphaRemovalThreshold,\n      };\n      return this.addSplatBuffers(\n        [splatBuffer],\n        [addSplatBufferOptions],\n        finalBuild,\n        firstBuild && showLoadingUI,\n        showLoadingUI,\n        progressiveLoad,\n        progressiveLoad,\n      ).then(() => {\n        if (!progressiveLoad && options.onProgress) {\n          options.onProgress(100, '100%', LoaderStatus.Processing);\n        }\n        splatBuffersAddedUIUpdate(firstBuild, finalBuild);\n      });\n    };\n\n    const loadFunc = progressiveLoad ?\n      this.downloadAndBuildSingleSplatSceneProgressiveLoad.bind(this) :\n      this.downloadAndBuildSingleSplatSceneStandardLoad.bind(this);\n    return loadFunc(\n      path,\n      format,\n      options.splatAlphaRemovalThreshold,\n      buildSection.bind(this),\n      onProgress,\n      hideLoadingUI.bind(this),\n    );\n  }\n\n  /**\n   * Download a single splat scene, convert to splat buffer and then rebuild the viewer's splat mesh\n   * by calling 'buildFunc' -- all before displaying the scene. Also sets/clears relevant instance synchronization objects,\n   * and calls appropriate functions on success or failure.\n   * @param {string} path Path to splat scene to be loaded\n   * @param {SceneFormat} format Format of the splat scene file\n   * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified value (valid range: 0 - 255)\n   * @param {function} buildFunc Function to build the viewer's splat mesh with the downloaded splat buffer\n   * @param {function} onProgress Function to be called as file data are received, or other processing occurs\n   * @param {function} onException Function to be called when exception occurs\n   * @return {AbortablePromise}\n   */\n  downloadAndBuildSingleSplatSceneStandardLoad(\n    path,\n    format,\n    splatAlphaRemovalThreshold,\n    buildFunc,\n    onProgress,\n    onException,\n  ) {\n    const downloadPromise = this.downloadSplatSceneToSplatBuffer(\n      path,\n      splatAlphaRemovalThreshold,\n      onProgress,\n      false,\n      undefined,\n      format,\n    );\n    const downloadAndBuildPromise = abortablePromiseWithExtractedComponents(\n      downloadPromise.abortHandler,\n    );\n\n    downloadPromise\n      .then((splatBuffer) => {\n        this.removeSplatSceneDownloadPromise(downloadPromise);\n        return buildFunc(splatBuffer, true, true).then(() => {\n          downloadAndBuildPromise.resolve();\n          this.clearSplatSceneDownloadAndBuildPromise();\n        });\n      })\n      .catch((e) => {\n        if (onException) onException();\n        this.clearSplatSceneDownloadAndBuildPromise();\n        this.removeSplatSceneDownloadPromise(downloadPromise);\n        const error =\n          e instanceof AbortedPromiseError ?\n            e :\n            new Error(`Viewer::addSplatScene -> Could not load file ${path}`);\n        downloadAndBuildPromise.reject(error);\n      });\n\n    this.addSplatSceneDownloadPromise(downloadPromise);\n    this.setSplatSceneDownloadAndBuildPromise(downloadAndBuildPromise.promise);\n\n    return downloadAndBuildPromise.promise;\n  }\n\n  /**\n   * Download a single splat scene and convert to splat buffer in a progressive manner, allowing rendering as the file downloads.\n   * As each section is downloaded, the viewer's splat mesh is rebuilt by calling 'buildFunc'\n   * Also sets/clears relevant instance synchronization objects, and calls appropriate functions on success or failure.\n   * @param {string} path Path to splat scene to be loaded\n   * @param {SceneFormat} format Format of the splat scene file\n   * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified value (valid range: 0 - 255)\n   * @param {function} buildFunc Function to rebuild the viewer's splat mesh after a new splat buffer section is downloaded\n   * @param {function} onDownloadProgress Function to be called as file data are received\n   * @param {function} onDownloadException Function to be called when exception occurs at any point during the full download\n   * @return {AbortablePromise}\n   */\n  downloadAndBuildSingleSplatSceneProgressiveLoad(\n    path,\n    format,\n    splatAlphaRemovalThreshold,\n    buildFunc,\n    onDownloadProgress,\n    onDownloadException,\n  ) {\n    let progressiveLoadedSectionBuildCount = 0;\n    let progressiveLoadedSectionBuilding = false;\n    const queuedProgressiveLoadSectionBuilds = [];\n\n    const checkAndBuildProgressiveLoadSections = () => {\n      if (\n        queuedProgressiveLoadSectionBuilds.length > 0 &&\n        !progressiveLoadedSectionBuilding &&\n        !this.isDisposingOrDisposed()\n      ) {\n        progressiveLoadedSectionBuilding = true;\n        const queuedBuild = queuedProgressiveLoadSectionBuilds.shift();\n        buildFunc(\n          queuedBuild.splatBuffer,\n          queuedBuild.firstBuild,\n          queuedBuild.finalBuild,\n        ).then(() => {\n          progressiveLoadedSectionBuilding = false;\n          if (queuedBuild.firstBuild) {\n            progressiveLoadFirstSectionBuildPromise.resolve();\n          } else if (queuedBuild.finalBuild) {\n            splatSceneDownloadAndBuildPromise.resolve();\n            this.clearSplatSceneDownloadAndBuildPromise();\n          }\n          if (queuedProgressiveLoadSectionBuilds.length > 0) {\n            delayedExecute(() => checkAndBuildProgressiveLoadSections());\n          }\n        });\n      }\n    };\n\n    const onProgressiveLoadSectionProgress = (splatBuffer, finalBuild) => {\n      if (!this.isDisposingOrDisposed()) {\n        if (\n          finalBuild ||\n          queuedProgressiveLoadSectionBuilds.length === 0 ||\n          splatBuffer.getSplatCount() >\n            queuedProgressiveLoadSectionBuilds[0].splatBuffer.getSplatCount()\n        ) {\n          queuedProgressiveLoadSectionBuilds.push({\n            splatBuffer,\n            firstBuild: progressiveLoadedSectionBuildCount === 0,\n            finalBuild,\n          });\n          progressiveLoadedSectionBuildCount++;\n          checkAndBuildProgressiveLoadSections();\n        }\n      }\n    };\n\n    const splatSceneDownloadPromise = this.downloadSplatSceneToSplatBuffer(\n      path,\n      splatAlphaRemovalThreshold,\n      onDownloadProgress,\n      true,\n      onProgressiveLoadSectionProgress,\n      format,\n    );\n\n    const progressiveLoadFirstSectionBuildPromise =\n      abortablePromiseWithExtractedComponents(\n        splatSceneDownloadPromise.abortHandler,\n      );\n    const splatSceneDownloadAndBuildPromise =\n      abortablePromiseWithExtractedComponents();\n\n    this.addSplatSceneDownloadPromise(splatSceneDownloadPromise);\n    this.setSplatSceneDownloadAndBuildPromise(\n      splatSceneDownloadAndBuildPromise.promise,\n    );\n\n    splatSceneDownloadPromise\n      .then(() => {\n        this.removeSplatSceneDownloadPromise(splatSceneDownloadPromise);\n      })\n      .catch((e) => {\n        this.clearSplatSceneDownloadAndBuildPromise();\n        this.removeSplatSceneDownloadPromise(splatSceneDownloadPromise);\n        const error =\n          e instanceof AbortedPromiseError ?\n            e :\n            new Error(\n                `Viewer::addSplatScene -> Could not load one or more scenes`,\n              );\n        progressiveLoadFirstSectionBuildPromise.reject(error);\n        if (onDownloadException) onDownloadException(error);\n      });\n\n    return progressiveLoadFirstSectionBuildPromise.promise;\n  }\n\n  /**\n   * Add multiple splat scenes to the viewer and display any loading UI if appropriate.\n   * @param {Array<object>} sceneOptions Array of per-scene options: {\n   *\n   *         path: Path to splat scene to be loaded\n   *\n   *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n   *                                     value (valid range: 0 - 255), defaults to 1\n   *\n   *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n   *\n   *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n   *\n   *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n   * }\n   * @param {boolean} showLoadingUI Display a loading spinner while the scene is loading, defaults to true\n   * @param {function} onProgress Function to be called as file data are received\n   * @return {AbortablePromise}\n   */\n  addSplatScenes(sceneOptions, showLoadingUI = true, onProgress = undefined) {\n    if (this.isLoadingOrUnloading()) {\n      throw new Error(\n        'Cannot add splat scene while another load or unload is already in progress.',\n      );\n    }\n\n    if (this.isDisposingOrDisposed()) {\n      throw new Error('Cannot add splat scene after dispose() is called.');\n    }\n\n    const fileCount = sceneOptions.length;\n    const percentComplete = [];\n\n    let loadingUITaskId;\n    if (showLoadingUI) {\n      this.loadingSpinner.removeAllTasks();\n      loadingUITaskId = this.loadingSpinner.addTask('Downloading...');\n    }\n\n    const onLoadProgress = (fileIndex, percent, percentLabel, loaderStatus) => {\n      percentComplete[fileIndex] = percent;\n      let totalPercent = 0;\n      for (let i = 0; i < fileCount; i++) {\n        totalPercent += percentComplete[i] || 0;\n      }\n      totalPercent = totalPercent / fileCount;\n      percentLabel = `${totalPercent.toFixed(2)}%`;\n      if (showLoadingUI) {\n        if (loaderStatus === LoaderStatus.Downloading) {\n          this.loadingSpinner.setMessageForTask(\n            loadingUITaskId,\n            totalPercent == 100 ?\n              `Download complete!` :\n              `Downloading: ${percentLabel}`,\n          );\n        }\n      }\n      if (onProgress) onProgress(totalPercent, percentLabel, loaderStatus);\n    };\n\n    const baseDownloadPromises = [];\n    const nativeDownloadPromises = [];\n    for (let i = 0; i < sceneOptions.length; i++) {\n      const options = sceneOptions[i];\n      const format =\n        options.format !== undefined && options.format !== null ?\n          options.format :\n          sceneFormatFromPath(options.path);\n      const baseDownloadPromise = this.downloadSplatSceneToSplatBuffer(\n        options.path,\n        options.splatAlphaRemovalThreshold,\n        onLoadProgress.bind(this, i),\n        false,\n        undefined,\n        format,\n      );\n      baseDownloadPromises.push(baseDownloadPromise);\n      nativeDownloadPromises.push(baseDownloadPromise.promise);\n    }\n\n    const downloadAndBuildPromise = new AbortablePromise(\n      (resolve, reject) => {\n        Promise.all(nativeDownloadPromises)\n          .then((splatBuffers) => {\n            if (showLoadingUI) this.loadingSpinner.removeTask(loadingUITaskId);\n            if (onProgress) onProgress(0, '0%', LoaderStatus.Processing);\n            this.addSplatBuffers(\n              splatBuffers,\n              sceneOptions,\n              true,\n              showLoadingUI,\n              showLoadingUI,\n              false,\n              false,\n            ).then(() => {\n              if (onProgress) onProgress(100, '100%', LoaderStatus.Processing);\n              this.clearSplatSceneDownloadAndBuildPromise();\n              resolve();\n            });\n          })\n          .catch((e) => {\n            if (showLoadingUI) this.loadingSpinner.removeTask(loadingUITaskId);\n            this.clearSplatSceneDownloadAndBuildPromise();\n            const error =\n              e instanceof AbortedPromiseError ?\n                e :\n                new Error(\n                    `Viewer::addSplatScenes -> Could not load one or more splat scenes.`,\n                  );\n            reject(error);\n          })\n          .finally(() => {\n            this.removeSplatSceneDownloadPromise(downloadAndBuildPromise);\n          });\n      },\n      (reason) => {\n        for (let baseDownloadPromise of baseDownloadPromises) {\n          baseDownloadPromise.abort(reason);\n        }\n      },\n    );\n    this.addSplatSceneDownloadPromise(downloadAndBuildPromise);\n    this.setSplatSceneDownloadAndBuildPromise(downloadAndBuildPromise);\n    return downloadAndBuildPromise;\n  }\n\n  /**\n   * Download a splat scene and convert to SplatBuffer instance.\n   * @param {string} path Path to splat scene to be loaded\n   * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified\n   *                                            value (valid range: 0 - 255), defaults to 1\n   *\n   * @param {function} onProgress Function to be called as file data are received\n   * @param {boolean} progressiveBuild Construct file sections into splat buffers as they are downloaded\n   * @param {function} onSectionBuilt Function to be called when new section is added to the file\n   * @param {string} format File format of the scene\n   * @return {AbortablePromise}\n   */\n  downloadSplatSceneToSplatBuffer(\n    path,\n    splatAlphaRemovalThreshold = 1,\n    onProgress = undefined,\n    progressiveBuild = false,\n    onSectionBuilt = undefined,\n    format,\n  ) {\n    const optimizeSplatData = progressiveBuild ? false : this.optimizeSplatData;\n    try {\n      if (format === SceneFormat.Splat) {\n        return SplatLoader.loadFromURL(\n          path,\n          onProgress,\n          progressiveBuild,\n          onSectionBuilt,\n          splatAlphaRemovalThreshold,\n          this.inMemoryCompressionLevel,\n          optimizeSplatData,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          this.fetchWithProgress,\n        );\n      } else if (format === SceneFormat.KSplat) {\n        return KSplatLoader.loadFromURL(\n          path,\n          onProgress,\n          progressiveBuild,\n          onSectionBuilt,\n          this.fetchWithProgress,\n        );\n      } else if (format === SceneFormat.Ply) {\n        return PlyLoader.loadFromURL(\n          path,\n          onProgress,\n          progressiveBuild,\n          onSectionBuilt,\n          splatAlphaRemovalThreshold,\n          this.inMemoryCompressionLevel,\n          optimizeSplatData,\n          this.sphericalHarmonicsDegree,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          this.fetchWithProgress,\n        );\n      } else if (format === SceneFormat.GLTF) {\n        return new GLTFLoader(this).loadFromURL(path);\n      }\n    } catch (e) {\n      if (e instanceof DirectLoadError) {\n        throw new Error(\n          'File type or server does not support progressive loading.',\n        );\n      } else {\n        throw e;\n      }\n    }\n\n    throw new Error(\n      `Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${path}`,\n    );\n  }\n\n  static isProgressivelyLoadable(format) {\n    return (\n      format === SceneFormat.Splat ||\n      format === SceneFormat.KSplat ||\n      format === SceneFormat.Ply\n    );\n  }\n\n  /**\n   * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer and set up the sorting web worker.\n   * This function will terminate the existing sort worker (if there is one).\n   */\n  addSplatBuffers = (function() {\n    return function(\n      splatBuffers,\n      splatBufferOptions = [],\n      finalBuild = true,\n      showLoadingUI = true,\n      showLoadingUIForSplatTreeBuild = true,\n      replaceExisting = false,\n      enableRenderBeforeFirstSort = false,\n      preserveVisibleRegion = true,\n    ) {\n      if (this.isDisposingOrDisposed()) return Promise.resolve();\n\n      let splatProcessingTaskId = null;\n      const removeSplatProcessingTask = () => {\n        if (splatProcessingTaskId !== null) {\n          this.loadingSpinner.removeTask(splatProcessingTaskId);\n          splatProcessingTaskId = null;\n        }\n      };\n\n      this.splatRenderReady = false;\n      return new Promise((resolve) => {\n        if (showLoadingUI) {\n          splatProcessingTaskId = this.loadingSpinner.addTask(\n            'Processing splats...',\n          );\n        }\n        delayedExecute(() => {\n          if (this.isDisposingOrDisposed()) {\n            resolve();\n          } else {\n            const buildResults = this.addSplatBuffersToMesh(\n              splatBuffers,\n              splatBufferOptions,\n              finalBuild,\n              showLoadingUIForSplatTreeBuild,\n              replaceExisting,\n              preserveVisibleRegion,\n            );\n\n            const maxSplatCount = this.splatMesh.getMaxSplatCount();\n            if (\n              this.sortWorker &&\n              this.sortWorker.maxSplatCount !== maxSplatCount\n            ) {\n              this.disposeSortWorker();\n            }\n            // If we aren't calculating the splat distances from the center on the GPU, the sorting worker needs\n            // splat centers and transform indexes so that it can calculate those distance values.\n            if (!this.gpuAcceleratedSort) {\n              this.preSortMessages.push({\n                centers: buildResults.centers.buffer,\n                sceneIndexes: buildResults.sceneIndexes.buffer,\n                range: {\n                  from: buildResults.from,\n                  to: buildResults.to,\n                  count: buildResults.count,\n                },\n              });\n            }\n            const sortWorkerSetupPromise =\n              !this.sortWorker && maxSplatCount > 0 ?\n                this.setupSortWorker(this.splatMesh) :\n                Promise.resolve();\n            sortWorkerSetupPromise.then(() => {\n              if (this.isDisposingOrDisposed()) return;\n              this.runSplatSort(true, true).then((sortRunning) => {\n                if (!this.sortWorker || !sortRunning) {\n                  this.splatRenderReady = true;\n                  removeSplatProcessingTask();\n                  resolve();\n                } else {\n                  if (enableRenderBeforeFirstSort) {\n                    this.splatRenderReady = true;\n                  } else {\n                    this.runAfterNextSort.push(() => {\n                      this.splatRenderReady = true;\n                    });\n                  }\n                  this.runAfterNextSort.push(() => {\n                    removeSplatProcessingTask();\n                    resolve();\n                  });\n                }\n              });\n            });\n          }\n        }, true);\n      });\n    };\n  })();\n\n  /**\n   * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer. By default, this function is additive;\n   * all splat buffers contained by the viewer's splat mesh before calling this function will be preserved. This behavior can be\n   * changed by passing 'true' for 'replaceExisting'.\n   * @param {Array<SplatBuffer>} splatBuffers SplatBuffer instances\n   * @param {Array<object>} splatBufferOptions Array of options objects: {\n   *\n   *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n   *                                     value (valid range: 0 - 255), defaults to 1\n   *\n   *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n   *\n   *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n   *\n   *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n   * }\n   * @param {boolean} finalBuild Will the splat mesh be in its final state after this build?\n   * @param {boolean} showLoadingUIForSplatTreeBuild Whether or not to show the loading spinner during construction of the splat tree.\n   * @return {object} Object containing info about the splats that are updated\n   */\n  addSplatBuffersToMesh = (function() {\n    let splatOptimizingTaskId;\n\n    return function(\n      splatBuffers,\n      splatBufferOptions,\n      finalBuild = true,\n      showLoadingUIForSplatTreeBuild = false,\n      replaceExisting = false,\n      preserveVisibleRegion = true,\n    ) {\n      if (this.isDisposingOrDisposed()) return;\n      let allSplatBuffers = [];\n      let allSplatBufferOptions = [];\n      if (!replaceExisting) {\n        allSplatBuffers =\n          this.splatMesh.scenes.map((scene) => scene.splatBuffer) || [];\n        allSplatBufferOptions = this.splatMesh.sceneOptions ?\n          this.splatMesh.sceneOptions.map((sceneOptions) => sceneOptions) :\n          [];\n      }\n      allSplatBuffers.push(...splatBuffers);\n      allSplatBufferOptions.push(...splatBufferOptions);\n      if (this.renderer) this.splatMesh.setRenderer(this.renderer);\n      const onSplatTreeIndexesUpload = (finished) => {\n        if (this.isDisposingOrDisposed()) return;\n        const splatCount = this.splatMesh.getSplatCount();\n        if (\n          showLoadingUIForSplatTreeBuild &&\n          splatCount >= MIN_SPLAT_COUNT_TO_SHOW_SPLAT_TREE_LOADING_SPINNER\n        ) {\n          if (!finished && !splatOptimizingTaskId) {\n            this.loadingSpinner.setMinimized(true, true);\n            splatOptimizingTaskId = this.loadingSpinner.addTask(\n              'Optimizing data structures...',\n            );\n          }\n        }\n      };\n      const onSplatTreeReady = (finished) => {\n        if (this.isDisposingOrDisposed()) return;\n        if (finished && splatOptimizingTaskId) {\n          this.loadingSpinner.removeTask(splatOptimizingTaskId);\n          splatOptimizingTaskId = null;\n        }\n      };\n      const buildResults = this.splatMesh.build(\n        allSplatBuffers,\n        allSplatBufferOptions,\n        true,\n        finalBuild,\n        onSplatTreeIndexesUpload,\n        onSplatTreeReady,\n        preserveVisibleRegion,\n      );\n      if (finalBuild && this.freeIntermediateSplatData) {\n        this.splatMesh.freeIntermediateSplatData();\n      }\n      return buildResults;\n    };\n  })();\n\n  /**\n   * Set up the splat sorting web worker.\n   * @param {SplatMesh} splatMesh SplatMesh instance that contains the splats to be sorted\n   * @return {Promise}\n   */\n  setupSortWorker(splatMesh) {\n    if (this.isDisposingOrDisposed()) return;\n    return new Promise((resolve) => {\n      const DistancesArrayType = this.integerBasedSort ?\n        Int32Array :\n        Float32Array;\n      const splatCount = splatMesh.getSplatCount();\n      const maxSplatCount = splatMesh.getMaxSplatCount();\n      this.sortWorker = createSortWorker(\n        maxSplatCount,\n        this.sharedMemoryForWorkers,\n        this.enableSIMDInSort,\n        this.integerBasedSort,\n        this.splatMesh.dynamicMode,\n        this.splatSortDistanceMapPrecision,\n      );\n      this.sortWorker.onmessage = (e) => {\n        if (e.data.sortDone) {\n          this.sortRunning = false;\n          if (this.sharedMemoryForWorkers) {\n            this.splatMesh.updateRenderIndexes(\n              this.sortWorkerSortedIndexes,\n              e.data.splatRenderCount,\n            );\n          } else {\n            const sortedIndexes = new Uint32Array(\n              e.data.sortedIndexes.buffer,\n              0,\n              e.data.splatRenderCount,\n            );\n            this.splatMesh.updateRenderIndexes(\n              sortedIndexes,\n              e.data.splatRenderCount,\n            );\n          }\n\n          this.lastSplatSortCount = this.splatSortCount;\n\n          this.lastSortTime = e.data.sortTime;\n          this.sortPromiseResolver();\n          this.sortPromiseResolver = null;\n          this.forceRenderNextFrame();\n          if (this.runAfterNextSort.length > 0) {\n            this.runAfterNextSort.forEach((func) => {\n              func();\n            });\n            this.runAfterNextSort.length = 0;\n          }\n        } else if (e.data.sortCanceled) {\n          this.sortRunning = false;\n        } else if (e.data.sortSetupPhase1Complete) {\n          if (this.logLevel >= LogLevel.Info) {\n            console.log('Sorting web worker WASM setup complete.');\n          }\n          if (this.sharedMemoryForWorkers) {\n            this.sortWorkerSortedIndexes = new Uint32Array(\n              e.data.sortedIndexesBuffer,\n              e.data.sortedIndexesOffset,\n              maxSplatCount,\n            );\n            this.sortWorkerIndexesToSort = new Uint32Array(\n              e.data.indexesToSortBuffer,\n              e.data.indexesToSortOffset,\n              maxSplatCount,\n            );\n            this.sortWorkerPrecomputedDistances = new DistancesArrayType(\n              e.data.precomputedDistancesBuffer,\n              e.data.precomputedDistancesOffset,\n              maxSplatCount,\n            );\n            this.sortWorkerTransforms = new Float32Array(\n              e.data.transformsBuffer,\n              e.data.transformsOffset,\n              Constants.MaxScenes * 16,\n            );\n          } else {\n            this.sortWorkerIndexesToSort = new Uint32Array(maxSplatCount);\n            this.sortWorkerPrecomputedDistances = new DistancesArrayType(\n              maxSplatCount,\n            );\n            this.sortWorkerTransforms = new Float32Array(\n              Constants.MaxScenes * 16,\n            );\n          }\n          for (let i = 0; i < splatCount; i++) {\n            this.sortWorkerIndexesToSort[i] = i;\n          }\n          this.sortWorker.maxSplatCount = maxSplatCount;\n\n          if (this.logLevel >= LogLevel.Info) {\n            console.log('Sorting web worker ready.');\n            const splatDataTextures = this.splatMesh.getSplatDataTextures();\n            const covariancesTextureSize = splatDataTextures.covariances.size;\n            const centersColorsTextureSize =\n              splatDataTextures.centerColors.size;\n            console.log(\n              'Covariances texture size: ' +\n                covariancesTextureSize.x +\n                ' x ' +\n                covariancesTextureSize.y,\n            );\n            console.log(\n              'Centers/colors texture size: ' +\n                centersColorsTextureSize.x +\n                ' x ' +\n                centersColorsTextureSize.y,\n            );\n          }\n\n          resolve();\n        }\n      };\n    });\n  }\n\n  disposeSortWorker() {\n    if (this.sortWorker) this.sortWorker.terminate();\n    this.sortWorker = null;\n    this.sortPromise = null;\n    if (this.sortPromiseResolver) {\n      this.sortPromiseResolver();\n      this.sortPromiseResolver = null;\n    }\n    this.preSortMessages = [];\n    this.sortRunning = false;\n  }\n\n  removeSplatScene(indexToRemove, showLoadingUI = true) {\n    return this.removeSplatScenes([indexToRemove], showLoadingUI);\n  }\n\n  removeSplatScenes(indexesToRemove, showLoadingUI = true) {\n    if (this.isLoadingOrUnloading()) {\n      throw new Error(\n        'Cannot remove splat scene while another load or unload is already in progress.',\n      );\n    }\n\n    if (this.isDisposingOrDisposed()) {\n      throw new Error('Cannot remove splat scene after dispose() is called.');\n    }\n\n    let sortPromise;\n\n    this.splatSceneRemovalPromise = new Promise((resolve, reject) => {\n      let revmovalTaskId;\n\n      if (showLoadingUI) {\n        this.loadingSpinner.removeAllTasks();\n        this.loadingSpinner.show();\n        revmovalTaskId = this.loadingSpinner.addTask('Removing splat scene...');\n      }\n\n      const checkAndHideLoadingUI = () => {\n        if (showLoadingUI) {\n          this.loadingSpinner.hide();\n          this.loadingSpinner.removeTask(revmovalTaskId);\n        }\n      };\n\n      const onDone = (error) => {\n        checkAndHideLoadingUI();\n        this.splatSceneRemovalPromise = null;\n        if (!error) resolve();\n        else reject(error);\n      };\n\n      const checkForEarlyExit = () => {\n        if (this.isDisposingOrDisposed()) {\n          onDone();\n          return true;\n        }\n        return false;\n      };\n\n      sortPromise = this.sortPromise || Promise.resolve();\n      sortPromise.then(() => {\n        if (checkForEarlyExit()) return;\n        const savedSplatBuffers = [];\n        const savedSceneOptions = [];\n        const savedSceneTransformComponents = [];\n        for (let i = 0; i < this.splatMesh.scenes.length; i++) {\n          let shouldRemove = false;\n          for (let indexToRemove of indexesToRemove) {\n            if (indexToRemove === i) {\n              shouldRemove = true;\n              break;\n            }\n          }\n          if (!shouldRemove) {\n            const scene = this.splatMesh.scenes[i];\n            savedSplatBuffers.push(scene.splatBuffer);\n            savedSceneOptions.push(this.splatMesh.sceneOptions[i]);\n            savedSceneTransformComponents.push({\n              position: scene.position.clone(),\n              quaternion: scene.quaternion.clone(),\n              scale: scene.scale.clone(),\n            });\n          }\n        }\n        this.disposeSortWorker();\n        this.splatMesh.dispose();\n        this.sceneRevealMode = SceneRevealMode.Instant;\n        this.createSplatMesh();\n        this.addSplatBuffers(\n          savedSplatBuffers,\n          savedSceneOptions,\n          true,\n          false,\n          true,\n        )\n          .then(() => {\n            if (checkForEarlyExit()) return;\n            checkAndHideLoadingUI();\n            this.splatMesh.scenes.forEach((scene, index) => {\n              scene.position.copy(\n                savedSceneTransformComponents[index].position,\n              );\n              scene.quaternion.copy(\n                savedSceneTransformComponents[index].quaternion,\n              );\n              scene.scale.copy(savedSceneTransformComponents[index].scale);\n            });\n            this.splatMesh.updateTransforms();\n            this.splatRenderReady = false;\n\n            this.runSplatSort(true).then(() => {\n              if (checkForEarlyExit()) {\n                this.splatRenderReady = true;\n                return;\n              }\n              sortPromise = this.sortPromise || Promise.resolve();\n              sortPromise.then(() => {\n                this.splatRenderReady = true;\n                onDone();\n              });\n            });\n          })\n          .catch((e) => {\n            onDone(e);\n          });\n      });\n    });\n\n    return this.splatSceneRemovalPromise;\n  }\n\n  /**\n   * Start self-driven mode\n   */\n  start() {\n    if (this.selfDrivenMode) {\n      if (this.webXRMode) {\n        this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc);\n      } else {\n        this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc);\n      }\n      this.selfDrivenModeRunning = true;\n    } else {\n      throw new Error('Cannot start viewer unless it is in self driven mode.');\n    }\n  }\n\n  /**\n   * Stop self-driven mode\n   */\n  stop() {\n    if (this.selfDrivenMode && this.selfDrivenModeRunning) {\n      if (this.webXRMode) {\n        this.renderer.setAnimationLoop(null);\n      } else {\n        cancelAnimationFrame(this.requestFrameId);\n      }\n      this.selfDrivenModeRunning = false;\n    }\n  }\n\n  /**\n   * Dispose of all resources held directly and indirectly by this viewer.\n   */\n  async dispose() {\n    if (this.isDisposingOrDisposed()) return this.disposePromise;\n\n    let waitPromises = [];\n    let promisesToAbort = [];\n    for (let promiseKey in this.splatSceneDownloadPromises) {\n      if (this.splatSceneDownloadPromises.hasOwnProperty(promiseKey)) {\n        const downloadPromiseToAbort =\n          this.splatSceneDownloadPromises[promiseKey];\n        promisesToAbort.push(downloadPromiseToAbort);\n        waitPromises.push(downloadPromiseToAbort.promise);\n      }\n    }\n    if (this.sortPromise) {\n      waitPromises.push(this.sortPromise);\n    }\n\n    this.disposing = true;\n    this.disposePromise = Promise.all(waitPromises).finally(() => {\n      this.stop();\n      if (this.orthographicControls) {\n        this.orthographicControls.dispose();\n        this.orthographicControls = null;\n      }\n      if (this.perspectiveControls) {\n        this.perspectiveControls.dispose();\n        this.perspectiveControls = null;\n      }\n      this.controls = null;\n      if (this.splatMesh) {\n        this.splatMesh.dispose();\n        this.splatMesh = null;\n      }\n      if (this.sceneHelper) {\n        this.sceneHelper.dispose();\n        this.sceneHelper = null;\n      }\n      if (this.resizeObserver) {\n        this.resizeObserver.unobserve(this.rootElement);\n        this.resizeObserver = null;\n      }\n      this.disposeSortWorker();\n      this.removeEventHandlers();\n\n      this.loadingSpinner.removeAllTasks();\n      this.loadingSpinner.setContainer(null);\n      this.loadingProgressBar.hide();\n      this.loadingProgressBar.setContainer(null);\n      this.infoPanel.setContainer(null);\n\n      this.camera = null;\n      this.threeScene = null;\n      this.splatRenderReady = false;\n      this.initialized = false;\n      if (this.renderer) {\n        if (!this.usingExternalRenderer) {\n          this.rootElement.removeChild(this.renderer.domElement);\n          this.renderer.dispose();\n        }\n        this.renderer = null;\n      }\n\n      if (!this.usingExternalRenderer) {\n        document.body.removeChild(this.rootElement);\n      }\n\n      this.sortWorkerSortedIndexes = null;\n      this.sortWorkerIndexesToSort = null;\n      this.sortWorkerPrecomputedDistances = null;\n      this.sortWorkerTransforms = null;\n      this.disposed = true;\n      this.disposing = false;\n      this.disposePromise = null;\n    });\n    promisesToAbort.forEach((toAbort) => {\n      toAbort.abort('Scene disposed');\n    });\n    return this.disposePromise;\n  }\n\n  selfDrivenUpdate() {\n    if (this.selfDrivenMode && !this.webXRMode) {\n      this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc);\n    }\n    this.update();\n    if (this.shouldRender()) {\n      this.render();\n      this.consecutiveRenderFrames++;\n    } else {\n      this.consecutiveRenderFrames = 0;\n    }\n    this.renderNextFrame = false;\n  }\n\n  forceRenderNextFrame() {\n    this.renderNextFrame = true;\n  }\n\n  shouldRender = (function() {\n    let renderCount = 0;\n    const lastCameraPosition = new THREE.Vector3();\n    const lastCameraOrientation = new THREE.Quaternion();\n    const changeEpsilon = 0.0001;\n\n    return function() {\n      if (\n        !this.initialized ||\n        !this.splatRenderReady ||\n        this.isDisposingOrDisposed()\n      ) {\n        return false;\n      }\n\n      let shouldRender = false;\n      let cameraChanged = false;\n      if (this.camera) {\n        const cp = this.camera.position;\n        const co = this.camera.quaternion;\n        cameraChanged =\n          Math.abs(cp.x - lastCameraPosition.x) > changeEpsilon ||\n          Math.abs(cp.y - lastCameraPosition.y) > changeEpsilon ||\n          Math.abs(cp.z - lastCameraPosition.z) > changeEpsilon ||\n          Math.abs(co.x - lastCameraOrientation.x) > changeEpsilon ||\n          Math.abs(co.y - lastCameraOrientation.y) > changeEpsilon ||\n          Math.abs(co.z - lastCameraOrientation.z) > changeEpsilon ||\n          Math.abs(co.w - lastCameraOrientation.w) > changeEpsilon;\n      }\n\n      shouldRender =\n        this.renderMode !== RenderMode.Never &&\n        (renderCount === 0 ||\n          this.splatMesh.visibleRegionChanging ||\n          cameraChanged ||\n          this.renderMode === RenderMode.Always ||\n          this.dynamicMode === true ||\n          this.renderNextFrame);\n\n      if (this.camera) {\n        lastCameraPosition.copy(this.camera.position);\n        lastCameraOrientation.copy(this.camera.quaternion);\n      }\n\n      renderCount++;\n      return shouldRender;\n    };\n  })();\n\n  render = (function() {\n    return function() {\n      if (\n        !this.initialized ||\n        !this.splatRenderReady ||\n        this.isDisposingOrDisposed()\n      ) {\n        return;\n      }\n\n      const hasRenderables = (threeScene) => {\n        for (let child of threeScene.children) {\n          if (child.visible) return true;\n        }\n        return false;\n      };\n\n      const savedAuoClear = this.renderer.autoClear;\n      if (hasRenderables(this.threeScene)) {\n        this.renderer.render(this.threeScene, this.camera);\n        this.renderer.autoClear = false;\n      }\n      this.renderer.render(this.splatMesh, this.camera);\n      this.renderer.autoClear = false;\n      if (this.sceneHelper.getFocusMarkerOpacity() > 0.0) {\n        this.renderer.render(this.sceneHelper.focusMarker, this.camera);\n      }\n      if (this.showControlPlane) {\n        this.renderer.render(this.sceneHelper.controlPlane, this.camera);\n      }\n      this.renderer.autoClear = savedAuoClear;\n    };\n  })();\n\n  update(renderer, camera) {\n    if (this.dropInMode) this.updateForDropInMode(renderer, camera);\n\n    if (\n      !this.initialized ||\n      !this.splatRenderReady ||\n      this.isDisposingOrDisposed()\n    ) {\n      return;\n    }\n\n    if (this.controls) {\n      this.controls.update();\n      if (this.camera.isOrthographicCamera && !this.usingExternalCamera) {\n        Viewer.setCameraPositionFromZoom(\n          this.camera,\n          this.camera,\n          this.controls,\n        );\n      }\n    }\n    this.runSplatSort();\n    this.updateForRendererSizeChanges();\n    this.updateSplatMesh();\n    this.updateMeshCursor();\n    this.updateFPS();\n    this.timingSensitiveUpdates();\n    this.updateInfoPanel();\n    this.updateControlPlane();\n  }\n\n  updateForDropInMode(renderer, camera) {\n    this.renderer = renderer;\n    if (this.splatMesh) this.splatMesh.setRenderer(this.renderer);\n    this.camera = camera;\n    if (this.controls) this.controls.object = camera;\n    this.init();\n  }\n\n  updateFPS = (function() {\n    let lastCalcTime = getCurrentTime();\n    let frameCount = 0;\n\n    return function() {\n      if (\n        this.consecutiveRenderFrames >\n        CONSECUTIVE_RENDERED_FRAMES_FOR_FPS_CALCULATION\n      ) {\n        const currentTime = getCurrentTime();\n        const calcDelta = currentTime - lastCalcTime;\n        if (calcDelta >= 1.0) {\n          this.currentFPS = frameCount;\n          frameCount = 0;\n          lastCalcTime = currentTime;\n        } else {\n          frameCount++;\n        }\n      } else {\n        this.currentFPS = null;\n      }\n    };\n  })();\n\n  updateForRendererSizeChanges = (function() {\n    const lastRendererSize = new THREE.Vector2();\n    const currentRendererSize = new THREE.Vector2();\n    let lastCameraOrthographic;\n\n    return function() {\n      if (!this.usingExternalCamera) {\n        this.renderer.getSize(currentRendererSize);\n        if (\n          lastCameraOrthographic === undefined ||\n          lastCameraOrthographic !== this.camera.isOrthographicCamera ||\n          currentRendererSize.x !== lastRendererSize.x ||\n          currentRendererSize.y !== lastRendererSize.y\n        ) {\n          if (this.camera.isOrthographicCamera) {\n            this.camera.left = -currentRendererSize.x / 2.0;\n            this.camera.right = currentRendererSize.x / 2.0;\n            this.camera.top = currentRendererSize.y / 2.0;\n            this.camera.bottom = -currentRendererSize.y / 2.0;\n          } else {\n            this.camera.aspect = currentRendererSize.x / currentRendererSize.y;\n          }\n          this.camera.updateProjectionMatrix();\n          lastRendererSize.copy(currentRendererSize);\n          lastCameraOrthographic = this.camera.isOrthographicCamera;\n        }\n      }\n    };\n  })();\n\n  timingSensitiveUpdates = (function() {\n    let lastUpdateTime;\n\n    return function() {\n      const currentTime = getCurrentTime();\n      if (!lastUpdateTime) lastUpdateTime = currentTime;\n      const timeDelta = currentTime - lastUpdateTime;\n\n      this.updateCameraTransition(currentTime);\n      this.updateFocusMarker(timeDelta);\n\n      lastUpdateTime = currentTime;\n    };\n  })();\n\n  updateCameraTransition = (function() {\n    let tempCameraTarget = new THREE.Vector3();\n    let toPreviousTarget = new THREE.Vector3();\n    let toNextTarget = new THREE.Vector3();\n\n    return function(currentTime) {\n      if (this.transitioningCameraTarget) {\n        toPreviousTarget\n          .copy(this.previousCameraTarget)\n          .sub(this.camera.position)\n          .normalize();\n        toNextTarget\n          .copy(this.nextCameraTarget)\n          .sub(this.camera.position)\n          .normalize();\n        const rotationAngle = Math.acos(toPreviousTarget.dot(toNextTarget));\n        const rotationSpeed = (rotationAngle / (Math.PI / 3)) * 0.65 + 0.3;\n        const t =\n          (rotationSpeed / rotationAngle) *\n          (currentTime - this.transitioningCameraTargetStartTime);\n        tempCameraTarget\n          .copy(this.previousCameraTarget)\n          .lerp(this.nextCameraTarget, t);\n        this.camera.lookAt(tempCameraTarget);\n        this.controls.target.copy(tempCameraTarget);\n        if (t >= 1.0) {\n          this.transitioningCameraTarget = false;\n        }\n      }\n    };\n  })();\n\n  updateFocusMarker = (function() {\n    const renderDimensions = new THREE.Vector2();\n    let wasTransitioning = false;\n\n    return function(timeDelta) {\n      this.getRenderDimensions(renderDimensions);\n      if (this.transitioningCameraTarget) {\n        this.sceneHelper.setFocusMarkerVisibility(true);\n        const currentFocusMarkerOpacity = Math.max(\n          this.sceneHelper.getFocusMarkerOpacity(),\n          0.0,\n        );\n        let newFocusMarkerOpacity = Math.min(\n          currentFocusMarkerOpacity + FOCUS_MARKER_FADE_IN_SPEED * timeDelta,\n          1.0,\n        );\n        this.sceneHelper.setFocusMarkerOpacity(newFocusMarkerOpacity);\n        this.sceneHelper.updateFocusMarker(\n          this.nextCameraTarget,\n          this.camera,\n          renderDimensions,\n        );\n        wasTransitioning = true;\n        this.forceRenderNextFrame();\n      } else {\n        let currentFocusMarkerOpacity;\n        if (wasTransitioning) currentFocusMarkerOpacity = 1.0;\n        else {\n          currentFocusMarkerOpacity = Math.min(\n            this.sceneHelper.getFocusMarkerOpacity(),\n            1.0,\n          );\n        }\n        if (currentFocusMarkerOpacity > 0) {\n          this.sceneHelper.updateFocusMarker(\n            this.nextCameraTarget,\n            this.camera,\n            renderDimensions,\n          );\n          let newFocusMarkerOpacity = Math.max(\n            currentFocusMarkerOpacity - FOCUS_MARKER_FADE_OUT_SPEED * timeDelta,\n            0.0,\n          );\n          this.sceneHelper.setFocusMarkerOpacity(newFocusMarkerOpacity);\n          if (newFocusMarkerOpacity === 0.0) {\n            this.sceneHelper.setFocusMarkerVisibility(false);\n          }\n        }\n        if (currentFocusMarkerOpacity > 0.0) this.forceRenderNextFrame();\n        wasTransitioning = false;\n      }\n    };\n  })();\n\n  updateMeshCursor = (function() {\n    const outHits = [];\n    const renderDimensions = new THREE.Vector2();\n\n    return function() {\n      if (this.showMeshCursor) {\n        this.forceRenderNextFrame();\n        this.getRenderDimensions(renderDimensions);\n        outHits.length = 0;\n        this.raycaster.setFromCameraAndScreenPosition(\n          this.camera,\n          this.mousePosition,\n          renderDimensions,\n        );\n        this.raycaster.intersectSplatMesh(this.splatMesh, outHits);\n        if (outHits.length > 0) {\n          this.sceneHelper.setMeshCursorVisibility(true);\n          this.sceneHelper.positionAndOrientMeshCursor(\n            outHits[0].origin,\n            this.camera,\n          );\n        } else {\n          this.sceneHelper.setMeshCursorVisibility(false);\n        }\n      } else {\n        if (this.sceneHelper.getMeschCursorVisibility()) {\n          this.forceRenderNextFrame();\n        }\n        this.sceneHelper.setMeshCursorVisibility(false);\n      }\n    };\n  })();\n\n  updateInfoPanel = (function() {\n    const renderDimensions = new THREE.Vector2();\n\n    return function() {\n      if (!this.showInfo) return;\n      const splatCount = this.splatMesh.getSplatCount();\n      this.getRenderDimensions(renderDimensions);\n      const cameraLookAtPosition = this.controls ? this.controls.target : null;\n      const meshCursorPosition = this.showMeshCursor ?\n        this.sceneHelper.meshCursor.position :\n        null;\n      const splatRenderCountPct =\n        splatCount > 0 ? (this.splatRenderCount / splatCount) * 100 : 0;\n      this.infoPanel.update(\n        renderDimensions,\n        this.camera.position,\n        cameraLookAtPosition,\n        this.camera.up,\n        this.camera.isOrthographicCamera,\n        meshCursorPosition,\n        this.currentFPS || 'N/A',\n        splatCount,\n        this.splatRenderCount,\n        splatRenderCountPct,\n        this.lastSortTime,\n        this.focalAdjustment,\n        this.splatMesh.getSplatScale(),\n        this.splatMesh.getPointCloudModeEnabled(),\n      );\n    };\n  })();\n\n  updateControlPlane() {\n    if (this.showControlPlane) {\n      this.sceneHelper.setControlPlaneVisibility(true);\n      this.sceneHelper.positionAndOrientControlPlane(\n        this.controls.target,\n        this.camera.up,\n      );\n    } else {\n      this.sceneHelper.setControlPlaneVisibility(false);\n    }\n  }\n\n  runSplatSort = (function() {\n    const mvpMatrix = new THREE.Matrix4();\n    const cameraPositionArray = [];\n    const lastSortViewDir = new THREE.Vector3(0, 0, -1);\n    const sortViewDir = new THREE.Vector3(0, 0, -1);\n    const lastSortViewPos = new THREE.Vector3();\n    const sortViewOffset = new THREE.Vector3();\n    const queuedSorts = [];\n\n    const partialSorts = [\n      {\n        angleThreshold: 0.55,\n        sortFractions: [0.125, 0.33333, 0.75],\n      },\n      {\n        angleThreshold: 0.65,\n        sortFractions: [0.33333, 0.66667],\n      },\n      {\n        angleThreshold: 0.8,\n        sortFractions: [0.5],\n      },\n    ];\n\n    return function(force = false, forceSortAll = false) {\n      if (!this.initialized) return Promise.resolve(false);\n      if (this.sortRunning) return Promise.resolve(true);\n      if (this.splatMesh.getSplatCount() <= 0) {\n        this.splatRenderCount = 0;\n        return Promise.resolve(false);\n      }\n\n      let angleDiff = 0;\n      let positionDiff = 0;\n      let needsRefreshForRotation = false;\n      let needsRefreshForPosition = false;\n\n      sortViewDir.set(0, 0, -1).applyQuaternion(this.camera.quaternion);\n      angleDiff = sortViewDir.dot(lastSortViewDir);\n      positionDiff = sortViewOffset\n        .copy(this.camera.position)\n        .sub(lastSortViewPos)\n        .length();\n\n      if (!force) {\n        if (!this.splatMesh.dynamicMode && queuedSorts.length === 0) {\n          if (angleDiff <= 0.99) needsRefreshForRotation = true;\n          if (positionDiff >= 1.0) needsRefreshForPosition = true;\n          if (!needsRefreshForRotation && !needsRefreshForPosition) {\n            return Promise.resolve(false);\n          }\n        }\n      }\n\n      this.sortRunning = true;\n      let { splatRenderCount, shouldSortAll } = this.gatherSceneNodesForSort();\n      shouldSortAll = shouldSortAll || forceSortAll;\n      this.splatRenderCount = splatRenderCount;\n\n      mvpMatrix.copy(this.camera.matrixWorld).invert();\n      const mvpCamera = this.perspectiveCamera || this.camera;\n      mvpMatrix.premultiply(mvpCamera.projectionMatrix);\n      mvpMatrix.multiply(this.splatMesh.matrixWorld);\n\n      let gpuAcceleratedSortPromise = Promise.resolve(true);\n      if (\n        this.gpuAcceleratedSort &&\n        (queuedSorts.length <= 1 || queuedSorts.length % 2 === 0)\n      ) {\n        gpuAcceleratedSortPromise = this.splatMesh.computeDistancesOnGPU(\n          mvpMatrix,\n          this.sortWorkerPrecomputedDistances,\n        );\n      }\n\n      gpuAcceleratedSortPromise.then(() => {\n        if (queuedSorts.length === 0) {\n          if (this.splatMesh.dynamicMode || shouldSortAll) {\n            queuedSorts.push(this.splatRenderCount);\n          } else {\n            for (let partialSort of partialSorts) {\n              if (angleDiff < partialSort.angleThreshold) {\n                for (let sortFraction of partialSort.sortFractions) {\n                  queuedSorts.push(\n                    Math.floor(this.splatRenderCount * sortFraction),\n                  );\n                }\n                break;\n              }\n            }\n            queuedSorts.push(this.splatRenderCount);\n          }\n        }\n        let sortCount = Math.min(queuedSorts.shift(), this.splatRenderCount);\n        this.splatSortCount = sortCount;\n\n        cameraPositionArray[0] = this.camera.position.x;\n        cameraPositionArray[1] = this.camera.position.y;\n        cameraPositionArray[2] = this.camera.position.z;\n\n        const sortMessage = {\n          modelViewProj: mvpMatrix.elements,\n          cameraPosition: cameraPositionArray,\n          splatRenderCount: this.splatRenderCount,\n          splatSortCount: sortCount,\n          usePrecomputedDistances: this.gpuAcceleratedSort,\n        };\n        if (this.splatMesh.dynamicMode) {\n          this.splatMesh.fillTransformsArray(this.sortWorkerTransforms);\n        }\n        if (!this.sharedMemoryForWorkers) {\n          sortMessage.indexesToSort = this.sortWorkerIndexesToSort;\n          sortMessage.transforms = this.sortWorkerTransforms;\n          if (this.gpuAcceleratedSort) {\n            sortMessage.precomputedDistances =\n              this.sortWorkerPrecomputedDistances;\n          }\n        }\n\n        this.sortPromise = new Promise((resolve) => {\n          this.sortPromiseResolver = resolve;\n        });\n\n        if (this.preSortMessages.length > 0) {\n          this.preSortMessages.forEach((message) => {\n            this.sortWorker.postMessage(message);\n          });\n          this.preSortMessages = [];\n        }\n        this.sortWorker.postMessage({\n          sort: sortMessage,\n        });\n\n        if (queuedSorts.length === 0) {\n          lastSortViewPos.copy(this.camera.position);\n          lastSortViewDir.copy(sortViewDir);\n        }\n\n        return true;\n      });\n\n      return gpuAcceleratedSortPromise;\n    };\n  })();\n\n  /**\n   * Determine which splats to render by checking which are inside or close to the view frustum\n   */\n  gatherSceneNodesForSort = (function() {\n    const nodeRenderList = [];\n    let allSplatsSortBuffer = null;\n    const tempVectorYZ = new THREE.Vector3();\n    const tempVectorXZ = new THREE.Vector3();\n    const tempVector = new THREE.Vector3();\n    const modelView = new THREE.Matrix4();\n    const baseModelView = new THREE.Matrix4();\n    const sceneTransform = new THREE.Matrix4();\n    const renderDimensions = new THREE.Vector3();\n    const forward = new THREE.Vector3(0, 0, -1);\n\n    const tempMax = new THREE.Vector3();\n    const nodeSize = (node) => {\n      return tempMax.copy(node.max).sub(node.min).length();\n    };\n\n    return function(gatherAllNodes = false) {\n      this.getRenderDimensions(renderDimensions);\n      const cameraFocalLength =\n        renderDimensions.y /\n        2.0 /\n        Math.tan((this.camera.fov / 2.0) * THREE.MathUtils.DEG2RAD);\n      const fovXOver2 = Math.atan(renderDimensions.x / 2.0 / cameraFocalLength);\n      const fovYOver2 = Math.atan(renderDimensions.y / 2.0 / cameraFocalLength);\n      const cosFovXOver2 = Math.cos(fovXOver2);\n      const cosFovYOver2 = Math.cos(fovYOver2);\n\n      const splatTree = this.splatMesh.getSplatTree();\n\n      if (splatTree) {\n        baseModelView.copy(this.camera.matrixWorld).invert();\n        baseModelView.multiply(this.splatMesh.matrixWorld);\n\n        let nodeRenderCount = 0;\n        let splatRenderCount = 0;\n\n        for (let s = 0; s < splatTree.subTrees.length; s++) {\n          const subTree = splatTree.subTrees[s];\n          modelView.copy(baseModelView);\n          if (this.splatMesh.dynamicMode) {\n            this.splatMesh.getSceneTransform(s, sceneTransform);\n            modelView.multiply(sceneTransform);\n          }\n          const nodeCount = subTree.nodesWithIndexes.length;\n          for (let i = 0; i < nodeCount; i++) {\n            const node = subTree.nodesWithIndexes[i];\n            if (\n              !node.data ||\n              !node.data.indexes ||\n              node.data.indexes.length === 0\n            ) {\n              continue;\n            }\n            tempVector.copy(node.center).applyMatrix4(modelView);\n\n            const distanceToNode = tempVector.length();\n            tempVector.normalize();\n\n            tempVectorYZ.copy(tempVector).setX(0).normalize();\n            tempVectorXZ.copy(tempVector).setY(0).normalize();\n\n            const cameraAngleXZDot = forward.dot(tempVectorXZ);\n            const cameraAngleYZDot = forward.dot(tempVectorYZ);\n\n            const ns = nodeSize(node);\n            const outOfFovY = cameraAngleYZDot < cosFovYOver2 - 0.6;\n            const outOfFovX = cameraAngleXZDot < cosFovXOver2 - 0.6;\n            if (\n              !gatherAllNodes &&\n              (outOfFovX || outOfFovY) &&\n              distanceToNode > ns\n            ) {\n              continue;\n            }\n            splatRenderCount += node.data.indexes.length;\n            nodeRenderList[nodeRenderCount] = node;\n            node.data.distanceToNode = distanceToNode;\n            nodeRenderCount++;\n          }\n        }\n\n        nodeRenderList.length = nodeRenderCount;\n        nodeRenderList.sort((a, b) => {\n          if (a.data.distanceToNode < b.data.distanceToNode) return -1;\n          else return 1;\n        });\n\n        let currentByteOffset = splatRenderCount * Constants.BytesPerInt;\n        for (let i = 0; i < nodeRenderCount; i++) {\n          const node = nodeRenderList[i];\n          const windowSizeInts = node.data.indexes.length;\n          const windowSizeBytes = windowSizeInts * Constants.BytesPerInt;\n          let destView = new Uint32Array(\n            this.sortWorkerIndexesToSort.buffer,\n            currentByteOffset - windowSizeBytes,\n            windowSizeInts,\n          );\n          destView.set(node.data.indexes);\n          currentByteOffset -= windowSizeBytes;\n        }\n\n        return {\n          splatRenderCount: splatRenderCount,\n          shouldSortAll: false,\n        };\n      } else {\n        const totalSplatCount = this.splatMesh.getSplatCount();\n        if (\n          !allSplatsSortBuffer ||\n          allSplatsSortBuffer.length !== totalSplatCount\n        ) {\n          allSplatsSortBuffer = new Uint32Array(totalSplatCount);\n          for (let i = 0; i < totalSplatCount; i++) {\n            allSplatsSortBuffer[i] = i;\n          }\n        }\n        this.sortWorkerIndexesToSort.set(allSplatsSortBuffer);\n        return {\n          splatRenderCount: totalSplatCount,\n          shouldSortAll: true,\n        };\n      }\n    };\n  })();\n\n  getSplatMesh() {\n    return this.splatMesh;\n  }\n\n  /**\n   * Get a reference to a splat scene.\n   * @param {number} sceneIndex The index of the scene to which the reference will be returned\n   * @return {SplatScene}\n   */\n  getSplatScene(sceneIndex) {\n    return this.splatMesh.getScene(sceneIndex);\n  }\n\n  getSceneCount() {\n    return this.splatMesh.getSceneCount();\n  }\n\n  isMobile() {\n    return navigator.userAgent.includes('Mobi');\n  }\n}\n","\u0000asm\u0001\u0000\u0000\u0000\u0000\u000f\bdylink.0\u0001\u0004\u0000\u0000\u0000\u0000\u0001\u0017\u0002`\u0000\u0000`\u0010\u0000\u0002\u000f\u0001\u0003env\u0006memory\u0002\u0000\u0000\u0003\u0003\u0002\u0000\u0001\u0007>\u0003\u0011__wasm_call_ctors\u0000\u0000\u0018__wasm_apply_data_relocs\u0000\u0000\u000bsortIndexes\u0000\u0001\n\u000f\u0002\u0002\u0000\u000b\u000f\u0004\u0001|\u0003{\u0007}\u0003 \u000b \nk!\f\u0002@\u0002@ \u000e\u0004@ \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0003 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0001j \u0002 \u0000 \u0001j(\u0002\u0000A\u0002tj(\u0002\u0000\"\u00016\u0002\u0000 \u0001 \n \u0001 \nH\u001b!\n \u0001 \r \u0001 \rJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0003\u000b \u000f\u0004@ \u000b \fM\r\u0002A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u001cj(\u0002\u0000\"\u001dA\u0002tj(\u0002\u0000\"\u001bG\u0004@\u0002 \u0005\t\u00028 \b \u001bA\u0006tj\"\u000e\t\u0002\f \u000e*\u0002\u001c \u0001 \u000e*\u0002, \u0002 \u000e*\u0002< \u0003\u0001 \u0005\t\u0002( \u000e\t\u0002\b \u000e*\u0002\u0018 \u0001 \u000e*\u0002( \u0002 \u000e*\u00028 \u0003\u0001 \u0005\t\u0002\b \u000e\t\u0002\u0000 \u000e*\u0002\u0010 \u0001 \u000e*\u0002  \u0002 \u000e*\u00020 \u0003\u0001 \u0005\t\u0002\u0018 \u000e\t\u0002\u0004 \u000e*\u0002\u0014 \u0001 \u000e*\u0002$ \u0002 \u000e*\u00024 \u0003\u0001\u0001\u0001\u0001\"\u0011_\f\u0000\u0000\u0000\u0000\u0000@@\u0000\u0000\u0000\u0000\u0000@@\"\u0012\u0001\"\u0013!\u0001\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e\u0002 \u0013!\u0000\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\u0011 \u000e\u001c\u0001\u0002 \u0011 \u0011\r\b\t\n\u000b\f\r\u000e\u000f\u0000\u0001\u0002\u0003\u0000\u0001\u0002\u0003_ \u0012\u0001\"\u0011!\u0000\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\u001c\u0002\u0002 \u0011!\u0001\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\u001c\u0003!\u0012 \u001b!\u000f\u000b \u0003 \u001cj \u0001 \u001dA\u0004tj\u0000\u0000\u0000 \u0012\u0001\"\u0011\u001b\u0000 \u0011\u001b\u0001j \u0011\u001b\u0002j \u0011\u001b\u0003j\"\u000e6\u0002\u0000 \u000e \n \n \u000eJ\u001b!\n \u000e \r \r \u000eH\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0003\u000b\u0002 \u0005*\u0002\b\u0014 \u0005*\u0002\u0018\"\u0001\f\u0000\u0000\u0000\u0000\u0000@@\u0000\u0000\u0000\u0000\u0000@@\u0001\"\u0011!\u0001\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e\u0002 \u0011!\u0000\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\u0002 \u0005*\u0002(D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0005A\u0007!\nAx!\r \u000b \fM\r\u0002\u0011 \u000e\u001c\u0001 \u0005\u001c\u0002!\u0012 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0002j \u0001 \u0000 \u0002j(\u0002\u0000A\u0004tj\u0000\u0000\u0000 \u0012\u0001\"\u0011\u001b\u0000 \u0011\u001b\u0001j \u0011\u001b\u0002j\"\u00026\u0002\u0000 \u0002 \n \u0002 \nH\u001b!\n \u0002 \r \u0002 \rJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0002 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0001j\u0002 \u0002 \u0000 \u0001j(\u0002\u0000A\u0002tj*\u0002\u0000D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \u000fE\u0004@ \u000b \fM\r\u0001 \u0005*\u0002(!\u0014 \u0005*\u0002\u0018!\u0015 \u0005*\u0002\b!\u0016A\u0007!\nAx!\r \f!\u0005\u0003@\u0002 \u0014 \u0001 \u0000 \u0005A\u0002t\"\u0007j(\u0002\u0000A\u0004tj\"\u0002*\u0002\b \u0016 \u0002*\u0002\u0000 \u0015 \u0002*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e \u0003 \u0007j \u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \u000b \fM\r\u0000A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u001bj(\u0002\u0000A\u0002t\"\u001cj(\u0002\u0000\"\u000eG\u0004@ \u0005*\u00028\"\u0014 \b \u000eA\u0006tj\"\u000f*\u0002< \u0005*\u0002(\"\u0015 \u000f*\u00028 \u0005*\u0002\b\"\u0016 \u000f*\u00020 \u0005*\u0002\u0018\"\u0017 \u000f*\u00024!\u0018 \u0014 \u000f*\u0002, \u0015 \u000f*\u0002( \u0016 \u000f*\u0002  \u0017 \u000f*\u0002$!\u0019 \u0014 \u000f*\u0002\u001c \u0015 \u000f*\u0002\u0018 \u0016 \u000f*\u0002\u0010 \u0017 \u000f*\u0002\u0014!\u001a \u0014 \u000f*\u0002\f \u0015 \u000f*\u0002\b \u0016 \u000f*\u0002\u0000 \u0017 \u000f*\u0002\u0004!\u0014 \u000e!\u000f\u000b \u0003 \u001bj\u0002 \u0018 \u0001 \u001cA\u0002tj\"\u000e*\u0002\f \u0019 \u000e*\u0002\b \u0014 \u000e*\u0002\u0000 \u001a \u000e*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0001\u000bAx!\rA\u0007!\n\u000b \u000b \fK\u0004@ \tA\u0001k \r \n!\u0014 \f!\r\u0003@\u0002 \u0014 \u0003 \rA\u0002tj\"\u0001(\u0002\u0000 \nk\"\u0015C\u0000\u0000\u0000O]\u0004@ \u0015\f\u0001\u000bAx\u000b!\u000e \u0001 \u000e6\u0002\u0000 \u0004 \u000eA\u0002tj\"\u0001 \u0001(\u0002\u0000A\u0001j6\u0002\u0000 \rA\u0001j\"\r \u000bG\r\u0000\u000b\u000b \tA\u0002O\u0004@ \u0004(\u0002\u0000!\rA\u0001!\n\u0003@ \u0004 \nA\u0002tj\"\u0001 \u0001(\u0002\u0000 \rj\"\r6\u0002\u0000 \nA\u0001j\"\n \tG\r\u0000\u000b\u000b \fA\u0000J\u0004@ \f!\n\u0003@ \u0006 \nA\u0001k\"\u0001A\u0002t\"\u0002j \u0000 \u0002j(\u0002\u00006\u0002\u0000 \nA\u0001K \u0001!\n\r\u0000\u000b\u000b \u000b \fJ\u0004@ \u000b!\n\u0003@ \u0006 \u000b \u0004 \u0003 \nA\u0001k\"\nA\u0002t\"\u0001j(\u0002\u0000A\u0002tj\"\u0002(\u0002\u0000\"\u0005kA\u0002tj \u0000 \u0001j(\u0002\u00006\u0002\u0000 \u0002 \u0005A\u0001k6\u0002\u0000 \n \fJ\r\u0000\u000b\u000b\u000b","\u0000asm\u0001\u0000\u0000\u0000\u0000\u000f\bdylink.0\u0001\u0004\u0000\u0000\u0000\u0000\u0001\u0017\u0002`\u0000\u0000`\u0010\u0000\u0002\u000f\u0001\u0003env\u0006memory\u0002\u0000\u0000\u0003\u0003\u0002\u0000\u0001\u0007>\u0003\u0011__wasm_call_ctors\u0000\u0000\u0018__wasm_apply_data_relocs\u0000\u0000\u000bsortIndexes\u0000\u0001\n\u000f\u0002\u0002\u0000\u000b\u000f\u0003\u0001|\u0007}\u0006 \u000b \nk!\f\u0002@\u0002@ \u000e\u0004@ \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0003 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0001j \u0002 \u0000 \u0001j(\u0002\u0000A\u0002tj(\u0002\u0000\"\u00016\u0002\u0000 \u0001 \n \u0001 \nH\u001b!\n \u0001 \r \u0001 \rJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0003\u000b \u000f\u0004@ \u000b \fM\r\u0002A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u001aj(\u0002\u0000A\u0002t\"\u001bj(\u0002\u0000\"\u000eG\u0004@\u0002 \u0005*\u00028\"\u0011 \b \u000eA\u0006tj\"\u000f*\u0002< \u0005*\u0002(\"\u0012 \u000f*\u00028 \u0005*\u0002\b\"\u0013 \u000f*\u00020 \u0005*\u0002\u0018\"\u0014 \u000f*\u00024D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0018\u0002 \u0011 \u000f*\u0002, \u0012 \u000f*\u0002( \u0013 \u000f*\u0002  \u0014 \u000f*\u0002$D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0019\u0002 \u0011 \u000f*\u0002\u001c \u0012 \u000f*\u0002\u0018 \u0013 \u000f*\u0002\u0010 \u0014 \u000f*\u0002\u0014D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u001c\u0002 \u0011 \u000f*\u0002\f \u0012 \u000f*\u0002\b \u0013 \u000f*\u0002\u0000 \u0014 \u000f*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u001d \u000e!\u000f\u000b \u0003 \u001aj \u0001 \u001bA\u0002tj\"\u000e(\u0002\u0004 \u001cl \u000e(\u0002\u0000 \u001dlj \u000e(\u0002\b \u0019lj \u000e(\u0002\f \u0018lj\"\u000e6\u0002\u0000 \u000e \n \n \u000eJ\u001b!\n \u000e \r \r \u000eH\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0003\u000b\u0002 \u0005*\u0002(D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0002\u0002 \u0005*\u0002\u0018D\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u0007 \u000b \fM\u0002 \u0005*\u0002\bD\u0000\u0000\u0000\u0000\u0000@@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000fA\u0007!\nAx!\r\r\u0002 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\bj \u0001 \u0000 \bj(\u0002\u0000A\u0004tj\"\b(\u0002\u0004 \u0007l \b(\u0002\u0000 \u000flj \b(\u0002\b \u0002lj\"\b6\u0002\u0000 \b \n \b \nH\u001b!\n \b \r \b \rJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \r\u0004@A\u0007!\nAx!\r \u000b \fM\r\u0002 \f!\u0005\u0003@ \u0003 \u0005A\u0002t\"\u0001j\u0002 \u0002 \u0000 \u0001j(\u0002\u0000A\u0002tj*\u0002\u0000D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \u000fE\u0004@ \u000b \fM\r\u0001 \u0005*\u0002(!\u0011 \u0005*\u0002\u0018!\u0012 \u0005*\u0002\b!\u0013A\u0007!\nAx!\r \f!\u0005\u0003@\u0002 \u0011 \u0001 \u0000 \u0005A\u0002t\"\u0007j(\u0002\u0000A\u0004tj\"\u0002*\u0002\b \u0013 \u0002*\u0002\u0000 \u0012 \u0002*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b!\u000e \u0003 \u0007j \u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0005A\u0001j\"\u0005 \u000bG\r\u0000\u000b\f\u0002\u000b \u000b \fM\r\u0000A!\u000fA\u0007!\nAx!\r \f!\u0002\u0003@ \u000f \u0007 \u0000 \u0002A\u0002t\"\u0018j(\u0002\u0000A\u0002t\"\u0019j(\u0002\u0000\"\u000eG\u0004@ \u0005*\u00028\"\u0011 \b \u000eA\u0006tj\"\u000f*\u0002< \u0005*\u0002(\"\u0012 \u000f*\u00028 \u0005*\u0002\b\"\u0013 \u000f*\u00020 \u0005*\u0002\u0018\"\u0014 \u000f*\u00024!\u0015 \u0011 \u000f*\u0002, \u0012 \u000f*\u0002( \u0013 \u000f*\u0002  \u0014 \u000f*\u0002$!\u0016 \u0011 \u000f*\u0002\u001c \u0012 \u000f*\u0002\u0018 \u0013 \u000f*\u0002\u0010 \u0014 \u000f*\u0002\u0014!\u0017 \u0011 \u000f*\u0002\f \u0012 \u000f*\u0002\b \u0013 \u000f*\u0002\u0000 \u0014 \u000f*\u0002\u0004!\u0011 \u000e!\u000f\u000b \u0003 \u0018j\u0002 \u0015 \u0001 \u0019A\u0002tj\"\u000e*\u0002\f \u0016 \u000e*\u0002\b \u0011 \u000e*\u0002\u0000 \u0017 \u000e*\u0002\u0004D\u0000\u0000\u0000\u0000\u0000\u0000@\"\u0010D\u0000\u0000\u0000\u0000\u0000\u0000Ac\u0004@ \u0010\f\u0001\u000bAx\u000b\"\u000e6\u0002\u0000 \n \u000e \n \u000eH\u001b!\n \r \u000e \r \u000eJ\u001b!\r \u0002A\u0001j\"\u0002 \u000bG\r\u0000\u000b\f\u0001\u000bAx!\rA\u0007!\n\u000b \u000b \fK\u0004@ \tA\u0001k \r \n!\u0011 \f!\r\u0003@\u0002 \u0011 \u0003 \rA\u0002tj\"\u0001(\u0002\u0000 \nk\"\u0012C\u0000\u0000\u0000O]\u0004@ \u0012\f\u0001\u000bAx\u000b!\u000e \u0001 \u000e6\u0002\u0000 \u0004 \u000eA\u0002tj\"\u0001 \u0001(\u0002\u0000A\u0001j6\u0002\u0000 \rA\u0001j\"\r \u000bG\r\u0000\u000b\u000b \tA\u0002O\u0004@ \u0004(\u0002\u0000!\rA\u0001!\n\u0003@ \u0004 \nA\u0002tj\"\u0001 \u0001(\u0002\u0000 \rj\"\r6\u0002\u0000 \nA\u0001j\"\n \tG\r\u0000\u000b\u000b \fA\u0000J\u0004@ \f!\n\u0003@ \u0006 \nA\u0001k\"\u0001A\u0002t\"\u0002j \u0000 \u0002j(\u0002\u00006\u0002\u0000 \nA\u0001K \u0001!\n\r\u0000\u000b\u000b \u000b \fJ\u0004@ \u000b!\n\u0003@ \u0006 \u000b \u0004 \u0003 \nA\u0001k\"\nA\u0002t\"\u0001j(\u0002\u0000A\u0002tj\"\u0002(\u0002\u0000\"\u0005kA\u0002tj \u0000 \u0001j(\u0002\u00006\u0002\u0000 \u0002 \u0005A\u0001k6\u0002\u0000 \n \fJ\r\u0000\u000b\u000b\u000b","import * as THREE from 'three';\nimport { Viewer } from './Viewer.js';\n\n/**\n * DropInViewer: Wrapper for a Viewer instance that enables it to be added to a Three.js scene like\n * any other Three.js scene object (Mesh, Object3D, etc.)\n */\nexport class DropInViewer extends THREE.Group {\n  constructor(options = {}) {\n    super();\n    options.selfDrivenMode = false;\n    options.useBuiltInControls = false;\n    options.rootElement = null;\n    options.ignoreDevicePixelRatio = false;\n    options.dropInMode = true;\n    options.camera = undefined;\n    options.renderer = undefined;\n\n    this.viewer = new Viewer(options);\n    this.splatMesh = null;\n    this.updateSplatMesh();\n\n    this.callbackMesh = DropInViewer.createCallbackMesh();\n    this.add(this.callbackMesh);\n    this.callbackMesh.onBeforeRender = DropInViewer.onBeforeRender.bind(\n      this,\n      this.viewer,\n    );\n\n    this.unprojectMousePosition = this.unprojectPositionFromSplats.bind(this);\n\n    this.setupIDMode = this.setupIDMeshMode.bind(this);\n\n    this.viewer.onSplatMeshChanged(() => {\n      this.updateSplatMesh();\n    });\n  }\n\n  updateSplatMesh() {\n    if (this.splatMesh !== this.viewer.splatMesh) {\n      if (this.splatMesh) {\n        this.remove(this.splatMesh);\n      }\n      this.splatMesh = this.viewer.splatMesh;\n      this.add(this.viewer.splatMesh);\n    }\n  }\n\n  setupIDMeshMode(status) {\n    if(this.splatMesh !== null) {\n      this.splatMesh.setupIDMode(status);\n    }\n  }\n\n  /**\n   * Add a single splat scene to the viewer.\n   * @param {string} path Path to splat scene to be loaded\n   * @param {object} options {\n   *\n   *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n   *                                     value (valid range: 0 - 255), defaults to 1\n   *\n   *         showLoadingUI:         Display a loading spinner while the scene is loading, defaults to true\n   *\n   *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n   *\n   *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n   *\n   *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n   *\n   *         onProgress:                 Function to be called as file data are received\n   *\n   * }\n   * @return {AbortablePromise}\n   */\n  addSplatScene(path, options = {}) {\n    if (options.showLoadingUI !== false) options.showLoadingUI = true;\n    return this.viewer.addSplatScene(path, options);\n  }\n\n  /**\n   * Add multiple splat scenes to the viewer.\n   * @param {Array<object>} sceneOptions Array of per-scene options: {\n   *\n   *         path: Path to splat scene to be loaded\n   *\n   *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified\n   *                                     value (valid range: 0 - 255), defaults to 1\n   *\n   *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]\n   *\n   *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]\n   *\n   *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]\n   * }\n   * @param {boolean} showLoadingUI Display a loading spinner while the scene is loading, defaults to true\n   * @return {AbortablePromise}\n   */\n  addSplatScenes(sceneOptions, showLoadingUI) {\n    if (showLoadingUI !== false) showLoadingUI = true;\n    return this.viewer.addSplatScenes(sceneOptions, showLoadingUI);\n  }\n\n  /**\n   * Get a reference to a splat scene.\n   * @param {number} sceneIndex The index of the scene to which the reference will be returned\n   * @return {SplatScene}\n   */\n  getSplatScene(sceneIndex) {\n    return this.viewer.getSplatScene(sceneIndex);\n  }\n\n  removeSplatScene(index, showLoadingUI = true) {\n    return this.viewer.removeSplatScene(index, showLoadingUI);\n  }\n\n  removeSplatScenes(indexes, showLoadingUI = true) {\n    return this.viewer.removeSplatScenes(indexes, showLoadingUI);\n  }\n\n  getSceneCount() {\n    return this.viewer.getSceneCount();\n  }\n\n  setActiveSphericalHarmonicsDegrees(activeSphericalHarmonicsDegrees) {\n    this.viewer.setActiveSphericalHarmonicsDegrees(\n      activeSphericalHarmonicsDegrees,\n    );\n  }\n\n   /*\n  Proposed functionality for the interaction with the splats\n  The camera is the persepective camera used to render\n  The mousePosition parameter is the normalised position of the mouse\n  relative to the screen.\n  */\n  unprojectPositionFromSplats(renderer, camera, mousePosition) {\n    return this.viewer.unprojectMousePosition(renderer, camera, mousePosition);\n  }\n\n  async dispose() {\n    return await this.viewer.dispose();\n  }\n\n  static onBeforeRender(viewer, renderer, threeScene, camera) {\n    viewer.update(renderer, camera);\n  }\n\n  static createCallbackMesh() {\n    const geometry = new THREE.SphereGeometry(1, 8, 8);\n    const material = new THREE.MeshBasicMaterial();\n    material.colorWrite = false;\n    material.depthWrite = false;\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.frustumCulled = false;\n    return mesh;\n  }\n}\n"],"names":["AbortablePromise","static","constructor","promiseFunc","abortHandler","resolver","rejecter","this","promise","Promise","resolve","reject","promiseResolve","bind","promiseReject","args","error","id","idGen","then","onResolve","onResolveResult","args2","catch","onFail","abort","reason","AbortedPromiseError","Error","msg","super","floatView","Float32Array","int32View","Int32Array","buffer","uintEncodedFloat","f","makeProgressiveFetchFunction","get","globalThis","fetch","path","onProgress","saveChunks","abortController","AbortController","signal","aborted","async","data","ok","errorText","text","status","statusText","reader","body","getReader","bytesDownloaded","_fileSize","headers","fileSize","parseInt","undefined","chunks","value","chunk","done","read","Blob","arrayBuffer","percent","percentLabel","length","toFixed","push","fetchWithProgress","clamp","val","min","max","Math","getCurrentTime","performance","now","disposeAllMeshes","object3D","geometry","dispose","material","children","child","delayedExecute","func","fast","window","setTimeout","getSphericalHarmonicsComponentCountForDegree","sphericalHarmonicsDegree","nativePromiseWithExtractedComponents","abortablePromiseWithExtractedComponents","Semver","major","minor","patch","toString","isIOS","ua","navigator","userAgent","indexOf","getIOSSemever","extract","match","UncompressedSplatArray","X","Y","Z","SCALE0","SCALE1","SCALE2","ROTATION0","ROTATION1","ROTATION2","ROTATION3","FDC0","FDC1","FDC2","OPACITY","FRC0","FRC1","FRC2","FRC3","FRC4","FRC5","FRC6","FRC7","FRC8","FRC9","FRC10","FRC11","FRC12","FRC13","FRC14","FRC15","FRC16","FRC17","FRC18","FRC19","FRC20","FRC21","FRC22","FRC23","sphericalHarmonicsCount","componentCount","defaultSphericalHarmonics","Array","fill","splats","splatCount","createSplat","baseSplat","shEntries","i","addSplat","splat","getSplat","index","addDefaultSplat","newSplat","addSplatFromComonents","x","y","z","scale0","scale1","scale2","rot0","rot1","rot2","rot3","r","g","b","opacity","rest","addSplatFromArray","src","srcIndex","srcSplat","Constants","DefaultSphericalHarmonics8BitCompressionHalfRange","SphericalHarmonics8BitCompressionRange","toHalfFloat","THREE","DataUtils","fromHalfFloat","toUncompressedFloat","compressionLevel","isSH","range8BitMin","range8BitMax","fromUint8","toUint8","v","rangeMin","rangeMax","range","floor","fromHalfFloatToUint8","fromUint8ToHalfFloat","dataViewFloatForCompressionLevel","dataView","floatIndex","getFloat32","getUint16","getUint8","convertBetweenCompressionLevels","noop","fromLevel","toLevel","outputConversionFunc","copyBetweenBuffers","srcBuffer","srcOffset","destBuffer","destOffset","byteCount","Uint8Array","dest","SplatBuffer","BytesPerCenter","BytesPerScale","BytesPerRotation","BytesPerColor","ScaleOffsetBytes","RotationffsetBytes","ColorOffsetBytes","SphericalHarmonicsOffsetBytes","ScaleRange","BytesPerSphericalHarmonicsComponent","SphericalHarmonicsOffsetFloat","SphericalHarmonicsDegrees","BytesPerSplat","bufferData","secLoadedCountsToMax","constructFromBuffer","getSplatCount","getMaxSplatCount","maxSplatCount","getMinSphericalHarmonicsDegree","minSphericalHarmonicsDegree","sections","section","getBucketIndex","localSplatIndex","bucketIndex","maxSplatIndexInFullBuckets","fullBucketCount","bucketSize","bucketSplatIndex","partiallyFullBucketIndex","currentPartiallyFilledBucketSize","partiallyFilledBucketLengths","getSplatCenter","globalSplatIndex","outCenter","transform","sectionIndex","globalSplatIndexToSectionMap","splatCountOffset","srcSplatCentersBase","bytesPerSplat","DataView","dataBase","bucketBase","BucketStorageSizeFloats","sf","compressionScaleFactor","sr","compressionScaleRange","bucketArray","applyMatrix4","getSplatScaleAndRotation","scaleMatrix","Matrix4","rotationMatrix","tempMatrix","tempPosition","Vector3","scale","rotation","Quaternion","outScale","outRotation","scaleOverride","srcSplatScalesBase","CompressionLevels","set","makeScale","makeRotationFromQuaternion","copy","multiply","decompose","getSplatColor","outColor","srcSplatColorsBase","splatColorsArray","fillSplatCenterArray","outCenterArray","srcFrom","srcTo","destFrom","center","centerDestBase","CenterComponentCount","fillSplatScaleRotationArray","ensurePositiveW","quaternion","flip","w","outScaleArray","outRotationArray","desiredOutputCompressionLevel","outputConversion","srcCompressionLevel","scaleDestBase","ScaleComponentCount","rotationDestBase","RotationComponentCount","srcScaleX","srcScaleY","srcScaleZ","srcRotationW","srcRotationX","srcRotationY","srcRotationZ","normalize","identity","premultiply","tempMatrix4","Matrix3","covarianceMatrix","transformedCovariance","transform3x3","transform3x3Transpose","outCovariance","outOffset","setFromMatrix4","transpose","elements","fillSplatCovarianceArray","covarianceArray","covarianceDestBase","CovarianceComponentCount","computeCovariance","fillSplatColorArray","outColorArray","minimumAlpha","colorDestBase","ColorComponentCount","alpha","fillSphericalHarmonicsArray","sphericalHarmonicVectors","tempMatrix3","tempTranslation","tempScale","tempRotation","sh11","sh12","sh13","sh21","sh22","sh23","sh24","sh25","shIn1","shIn2","shIn3","shIn4","shIn5","shOut1","shOut2","shOut3","shOut4","shOut5","set3","array","val1","val2","val3","set3FromArray","srcDestView","stride","srcBase","copy3","srcArray","destArray","setOutput3","destBase","conversionFunc","toUncompressedFloatArray3","outSphericalHarmonicsArray","outSphericalHarmonicsDegree","localFromHalfFloatToUint8","minSphericalHarmonicsCoeff","maxSphericalHarmonicsCoeff","localToUint8","outSphericalHarmonicsComponentsCount","srcSplatSHBase","shDestBase","compressionLevelForOutputConversion","minShCoeff","maxShCoeff","rotateSphericalHarmonics3","rotateSphericalHarmonics5","v1","v2","v3","transformRow","outArray","t0","t1","t2","addInto3","v4","v5","t3","t4","in1","in2","in3","tsh11","tsh12","tsh13","out1","out2","out3","dot3","in4","in5","tsh21","tsh22","tsh23","tsh24","tsh25","out4","out5","kSqrt0104","sqrt","kSqrt0304","kSqrt0103","kSqrt0403","kSqrt0112","dot5","parseHeader","headerArrayUint8","HeaderSizeBytes","headerArrayUint16","Uint16Array","headerArrayUint32","Uint32Array","headerArrayFloat32","versionMajor","versionMinor","maxSectionCount","sectionCount","sceneCenter","writeHeaderCountsToBuffer","writeHeaderToBuffer","header","parseSectionHeaders","offset","sectionHeaderArrayUint16","SectionHeaderSizeBytes","sectionHeaderArrayUint32","sectionHeaderArrayFloat32","sectionHeaders","sectionHeaderBase","sectionHeaderBaseUint16","sectionHeaderBaseUint32","sectionBase","bucketCount","bucketBlockSize","halfBucketBlockSize","bucketStorageSizeBytes","partiallyFilledBucketCount","bucketsMetaDataSizeBytes","bucketsStorageSizeBytes","calculateComponentStorage","splatDataStorageSizeBytes","storageSizeBytes","sectionHeader","base","bucketsBase","writeSectionHeaderToBuffer","sectionHeadeArrayUint16","sectionHeadeArrayUint32","sectionHeadeArrayFloat32","BucketStorageSizeBytes","writeSectionHeaderSplatCountToBuffer","globalSplatIndexToLocalSplatIndexMap","linkBufferArrays","buildMaps","bytesPerCenter","bytesPerScale","bytesPerRotation","bytesPerColor","sphericalHarmonicsComponentsPerSplat","sphericalHarmonicsBytesPerSplat","cumulativeSplatCount","j","updateLoadedCounts","newSectionCount","newSplatCount","updateSectionLoadedCounts","sectionHeaderOffset","tempCenterBuffer","ArrayBuffer","tempScaleBuffer","tempRotationBuffer","tempColorBuffer","tempSHBuffer","tempRot","bucketCenterDelta","OFFSET_X","OFFSET_Y","OFFSET_Z","OFFSET_SCALE0","OFFSET_SCALE1","OFFSET_SCALE2","OFFSET_ROT0","OFFSET_ROT1","OFFSET_ROT2","OFFSET_ROT3","OFFSET_FDC0","OFFSET_FDC1","OFFSET_FDC2","OFFSET_OPACITY","OFFSET_FRC0","OFFSET_FRC9","OFFSET","compressPositionOffset","doubleCompressionScaleRange","round","targetSplat","sectionBuffer","bufferOffset","bucketCenter","centerBase","scaleBase","rotationBase","colorBase","sphericalHarmonicsBase","rot","shOut","s","sub","bytesPerSHComponent","srcVal","degree1ByteCount","rgba","Uint8ClampedArray","generateFromUncompressedSplatArrays","splatArrays","blockSize","options","shDegree","sa","splatArray","sc","sectionBuffers","sectionHeaderBuffers","totalSplatCount","validSplats","sectionOptions","sectionBlockSize","blockSizeFactor","BucketBlockSize","sectionBucketSize","ceil","bucketSizeFactor","BucketSize","bucketInfo","computeBucketsForUncompressedSplatArray","fullBuckets","partiallyFullBucketLengths","partiallyFullBuckets","map","bucket","buckets","sectionDataSizeBytes","bucketMetaDataSizeBytes","bucketDataBytes","sectionSizeBytes","outSplatCount","fromArray","row","writeSplatDataToSectionBuffer","bucketMetaDataArray","pfb","sectionHeaderBuffer","sectionsCumulativeSizeBytes","byteLength","unifiedBufferSize","unifiedBuffer","currentUnifiedBase","halfBlockSize","dimensions","yBlocks","zBlocks","blockCenter","xBlock","yBlock","zBlock","bucketId","toArray","partiallyFullBucketArray","hasOwnProperty","HeaderMagicBytes","HeaderEndTokenBytes","HeaderEndToken","DataTypeMap","Map","Int8Array","Int16Array","Float64Array","unpackUnorm","bits","t","unpack111011","result","lerp","a","getElementPropStorage","element","name","properties","find","p","storage","PlayCanvasCompressedPlyParser","decodeHeaderText","headerText","chunkElement","vertexElement","headerLines","split","filter","line","startsWith","words","count","has","StorageType","storageSizeByes","BYTES_PER_ELEMENT","type","byteSize","headerSizeBytes","decodeHeader","plyBuffer","endHeaderTokenOffset","buf","search","endIndex","TextDecoder","decode","slice","readElementData","readBuffer","readOffset","fromIndex","toIndex","propertyFilter","e","property","requiredStorageSizeBytes","getInt8","getInt16","getInt32","getUint32","getFloat64","readPly","readIndex","getElementStorageArrays","minX","minY","minZ","maxX","maxY","maxZ","minScaleX","minScaleY","minScaleZ","positionExtremes","scaleExtremes","maxScaleX","maxScaleY","maxScaleZ","position","color","c","Vector4","chunkSplatIndexOffset","positionArray","scaleArray","rotationArray","colorArray","outSplat","chunkIndex","norm","m","unpackRot","exp","parseToUncompressedSplatBufferSection","vertexDataBuffer","veretxReadOffset","outBuffer","outBytesPerSplat","tempSplat","decompressSplat","outBase","parseToUncompressedSplatArraySection","parseToUncompressedSplatArray","PlyFormat","FieldSizeIdDouble","FieldSizeIdInt","FieldSizeIdUInt","FieldSizeIdFloat","FieldSizeIdShort","FieldSizeIdUShort","FieldSizeIdUChar","FieldSizeStringMap","double","int","uint","float","short","ushort","uchar","FieldSize","PlyParserUtils","decodeSectionHeader","fieldNameIdMap","headerStartLine","extractedLines","processingSection","headerEndLine","vertexCount","endOfHeader","sectionName","fieldIds","fieldTypes","allFieldNames","usedFieldNames","fieldTypesByName","trim","lineComponents","validComponents","lineComponent","trimmedComponent","fieldMatch","fieldTypeStr","fieldName","fieldId","fieldType","fieldOffsets","bytesPerVertex","sphericalHarmonics","decodeSphericalHarmonicsFromSectionHeader","dataSizeBytes","degree","sphericalHarmonicsCoefficientsPerChannel","coefficientsPerChannel","sphericalHarmonicsDegree1Fields","degree1Fields","sphericalHarmonicsDegree2Fields","degree2Fields","fieldNames","sphericalHarmonicsFieldCount","rgb","getHeaderSectionNames","sectionNames","headerLine","checkTextForEndHeader","endHeaderTestText","includes","checkBufferForEndHeader","searchOfset","chunkSize","decoder","endHeaderTestChunk","extractHeaderFromBufferToText","headerOffset","readChunkSize","headerChunk","readHeaderFromBuffer","convertHeaderTextToLines","prunedLines","determineHeaderFormatFromHeaderText","headertText","format","determineHeaderFormatFromPlyBuffer","readVertex","vertexData","dataOffset","fieldsToRead","rawVertex","BaseFieldNamesToRead","BaseFieldsToReadIndexes","SCALE_0","SCALE_1","SCALE_2","ROT_0","ROT_1","ROT_2","ROT_3","F_DC_0","F_DC_1","F_DC_2","RED","GREEN","BLUE","F_REST_0","INRIAV1PlyParser","plyParserutils","decodeHeaderLines","shLineCount","forEach","shFieldsToReadCount","shRemainingFieldNamesToRead","from","fieldNamesToRead","fieldsToReadIndexes","reduce","acc","decodeHeaderFromBuffer","findSplatData","fromSplat","toSplat","splatData","splatDataOffset","toBuffer","toOffset","parsedSplat","parseToUncompressedSplat","decodeSectionSplatData","sectionSplatData","rawSplat","OFFSET_ROTATION0","OFFSET_ROTATION1","OFFSET_ROTATION2","OFFSET_ROTATION3","OFFSET_FRC","readSplat","SH_C0","CodeBookEntryNamesToRead","CodeBookEntriesToReadIndexes","CB_FEATURES_DC","CB_FEATURES_REST_0","CB_FEATURES_REST_3","CB_OPACITY","CB_SCALING","CB_ROTATION_RE","CB_ROTATION_IM","FieldNamesToRead","FieldsToReadIndexes","PLY_SCALE_0","PLY_SCALE_1","PLY_SCALE_2","PLY_ROT_0","PLY_ROT_1","PLY_ROT_2","PLY_ROT_3","PLY_X","PLY_Y","PLY_Z","PLY_F_DC_0","PLY_F_DC_1","PLY_F_DC_2","PLY_OPACITY","PLY_RED","PLY_GREEN","PLY_BLUE","hf","NaN","pow","INRIAV2PlyParser","decodeSectionHeadersFromHeaderLines","codeBookEntriesToReadIdMap","codeBookSectionIndex","currentStartLine","lastSectionFound","decodeSectionHeadersFromHeaderText","getSplatCountFromSectionHeaders","decodeHeaderFromHeaderText","findVertexData","targetSection","byteOffset","decodeCodeBook","codeBookData","codeBook","codeBookElementOffset","codeBookPage","page","baseValue","unified","PlyParser","plyFormat","DirectLoadError","InternalLoadType","LoaderStatus","SplatPartitioner","sectionFilters","groupingParameters","partitionGenerator","partitionUncompressedSplatArray","results","newArrays","sectionSplats","sectionFilter","parameters","getStandardPartitioner","partitionSize","clampDistance","point","centerDist","lengthSq","sort","patitionCount","currentStartSplat","startSplat","splatIndex","blocksSize","SplatBufferGenerator","splatPartitioner","alphaRemovalThreshold","sectionSize","generateFromUncompressedSplatArray","partitionResults","getStandardGenerator","storeChunksInBuffer","inBytes","sizeBytes","finalize","optimizeSplatData","PlyLoader","loadFromURL","fileName","loadDirectoToSplatBuffer","onProgressiveLoadSectionProgress","defaultFetchWithProgress","internalLoadType","directLoadSectionSizeBytes","ProgressiveLoadSectionSize","splatDataOffsetBytes","directLoadBufferIn","directLoadBufferOut","directLoadSplatBuffer","compressedPlyHeaderChunksBuffer","headerLoaded","readyToLoadSplatData","compressed","loadPromise","standardLoadUncompressedSplatArray","numBytesStreamed","numBytesParsed","numBytesDownloaded","textDecoder","inriaV1PlyParser","chunkData","loadComplete","startBytes","endBytes","sizeRequiredForHeaderAndChunks","shDescriptor","splatBufferSizeBytes","CurrentMajorVersion","CurrentMinorVersion","numBytesToProcess","addedSplatCount","numBytesToParse","numBytesLeftOver","parsedDataViewOffset","dataToParse","keepChunks","keepSize","unshift","chunkDatas","plyFileData","loadFromFileData","SplatParser","fromBuffer","fromOffset","outBytesPerCenter","outBytesPerScale","outBytesPerRotation","inBase","RowSizeBytes","inCenter","inScale","CenterSizeBytes","inColor","ScaleSizeBytes","inRotation","RotationSizeBytes","quat","parseStandardSplatToUncompressedSplatArray","inBuffer","ColorSizeBytes","SplatLoader","numBytesLoaded","percentStr","bytesLoadedSinceLastSection","splatFileData","KSplatLoader","checkVersion","minVersionMajor","minVersionMinor","externalOnProgress","onSectionBuilt","directLoadBuffer","headerBuffer","sectionHeadersBuffer","headerLoading","sectionHeadersLoaded","sectionHeadersLoading","numBytesProgressivelyLoaded","totalBytesToDownload","downloadComplete","loadSectionQueued","directLoadPromise","queuedCheckAndLoadSectionsCount","checkAndLoadSectionHeaders","performLoad","totalSectionStorageStorageByes","totalStorageSizeBytes","checkAndLoadSections","baseDataOffset","reachedSections","loadedSplatCount","bytesRequiredToReachSectionSplatData","bytesPastSSectionSplatDataStart","loadedSplatsForSection","percentComplete","ProgressiveLoadSectionDelayDuration","fullBuffer","splatBuffer","fileData","downLoadLink","blob","document","createElement","appendChild","download","href","URL","createObjectURL","click","SceneFormat","Splat","KSplat","Ply","GLTF","sceneFormatFromPath","endsWith","LogLevel","None","Warning","Info","Debug","_changeEvent","_startEvent","_endEvent","_ray","Ray","_plane","Plane","TILT_LIMIT","cos","MathUtils","DEG2RAD","OrbitControls","EventDispatcher","object","domElement","style","touchAction","enabled","target","minDistance","maxDistance","Infinity","minZoom","maxZoom","minPolarAngle","maxPolarAngle","PI","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","zoomToCursor","autoRotate","autoRotateSpeed","keys","LEFT","UP","RIGHT","BOTTOM","mouseButtons","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TOUCH","TWO","DOLLY_PAN","target0","clone","position0","zoom0","zoom","_domElementKeyEvents","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","getDistance","distanceTo","listenToKeyEvents","addEventListener","onKeyDown","stopListenToKeyEvents","removeEventListener","saveState","scope","reset","clearDampedRotation","clearDampedPan","updateProjectionMatrix","dispatchEvent","update","state","STATE","NONE","sphericalDelta","panOffset","setFromUnitVectors","up","quatInverse","invert","lastPosition","lastQuaternion","lastTargetPosition","twoPI","applyQuaternion","setFromVector3","rotateLeft","isFinite","makeSafe","addScaledVector","add","performCursorZoom","isOrthographicCamera","radius","setFromSpherical","lookAt","multiplyScalar","zoomChanged","newRadius","isPerspectiveCamera","prevRadius","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","unproject","mouseAfter","console","warn","transformDirection","matrix","origin","direction","abs","dot","setFromNormalAndCoplanarPoint","intersectPlane","distanceToSquared","EPS","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","onPointerMove","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","angle","rotateUp","panLeft","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","targetDistance","tan","fov","clientHeight","right","left","clientWidth","top","bottom","dollyOut","dollyScale","dollyIn","updateMouseParameters","event","rect","getBoundingClientRect","clientX","clientY","width","h","height","dist","handleMouseDownRotate","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","handleTouchMoveRotate","getSecondPointerPosition","subVectors","handleTouchMovePan","handleTouchMoveDolly","setPointerCapture","pointerId","addPointer","pointerType","trackPointer","DOLLY_ROTATE","onTouchStart","mouseAction","button","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","onTouchMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","splice","removePointer","releasePointerCapture","preventDefault","handleMouseWheel","needsUpdate","code","handleKeyDown","pointer","passive","RenderMode","Always","OnChange","Never","_axis","ArrowHelper","Object3D","dir","headLength","headRadius","lineGeometry","CylinderGeometry","translate","coneGeometry","Mesh","MeshBasicMaterial","toneMapped","matrixAutoUpdate","cone","setDirection","radians","acos","setFromAxisAngle","setColor","source","SceneHelper","threeScene","splatRenderTarget","renderTargetCopyQuad","renderTargetCopyCamera","meshCursor","focusMarker","controlPlane","debugRoot","secondaryDebugRoot","updateSplatRenderTargetForRenderDimensions","destroySplatRendertarget","WebGLRenderTarget","RGBAFormat","stencilBuffer","depthBuffer","depthTexture","DepthTexture","DepthFormat","UnsignedIntType","setupRenderTargetCopyObjects","renderTargetCopyMaterial","ShaderMaterial","vertexShader","fragmentShader","uniforms","sourceColorTexture","sourceDepthTexture","depthWrite","depthTest","transparent","blending","CustomBlending","blendSrc","SrcAlphaFactor","blendSrcAlpha","blendDst","OneMinusSrcAlphaFactor","blendDstAlpha","extensions","fragDepth","PlaneGeometry","OrthographicCamera","destroyRenderTargetCopyObjects","setupMeshCursor","ConeGeometry","coneMaterial","downArrow","upArrow","leftArrow","rightArrow","visible","destroyMeshCursor","remove","setMeshCursorVisibility","getMeschCursorVisibility","setMeshCursorPosition","positionAndOrientMeshCursor","camera","setupFocusMarker","sphereGeometry","SphereGeometry","focusMarkerMaterial","buildFocusMarkerMaterial","destroyFocusMarker","updateFocusMarker","toCamera","viewport","matrixWorld","toCameraDistance","realFocusPosition","uniformsNeedUpdate","setFocusMarkerVisibility","setFocusMarkerOpacity","getFocusMarkerOpacity","setupControlPlane","planeGeometry","rotateX","planeMaterial","side","DoubleSide","planeMesh","arrowDir","arrowOrigin","arrowHelper","destroyControlPlane","setControlPlaneVisibility","positionAndOrientControlPlane","tempQuaternion","defaultUp","addDebugMeshes","createDebugMeshes","createSecondaryDebugMeshes","destroyDebugMeshes","renderOrder","debugMeshRoot","createMesh","sphereMesh","buildDebugMaterial","boxGeometry","BoxGeometry","boxMesh","separation","Color","FrontSide","SceneRevealMode","Default","Gradual","Instant","SplatRenderMode","ThreeD","TwoD","GLTFParser","decodeSplatData","splatBuffers","shBuffers","positions","POSITION","scales","sx","sy","sz","rotations","rx","ry","rz","rw","opacities","sh0","sh_band_0","dcx","dcy","dcz","GLTFLoader","viewer","url","gltf","fetchGLTF","filePaths","gltfUrl","baseUrl","substring","lastIndexOf","attributes","meshes","primitives","OPF_mesh_primitive_custom_attributes","attributeMapping","sh_band_1_0","sh_band_1_triplet_0","sh_band_1_1","sh_band_1_triplet_1","sh_band_1_2","sh_band_1_triplet_2","sh_band_2_0","sh_band_2_triplet_0","sh_band_2_1","sh_band_2_triplet_1","sh_band_2_2","sh_band_2_triplet_2","sh_band_2_3","sh_band_2_triplet_3","sh_band_2_4","sh_band_2_triplet_4","Object","fromEntries","entries","key","bufferIndex","bufferViews","accessors","bufferView","buffers","uri","getFilePaths","fetchBuffers","getSplatCountFromGLTF","loadFromBufferData","response","json","bufferNames","bufferPromises","all","assign","VectorRight","VectorUp","VectorBackward","setParameters","boxContainsPoint","box","epsilon","intersectBox","planeIntersectionPoint","planeIntersectionPointArray","originArray","directionArray","outHit","normal","hitNormal","extremeVec","multiplier","sign","toSide","idx1","idx2","intersectSphere","toSphereCenterVec","toClosestApproach","toClosestApproachSq","diffSq","radiusSq","thc","Hit","hitClone","Raycaster","raycastAgainstTrueSplatEllipsoid","ray","setFromCameraAndScreenPosition","ndcCoords","screenPosition","screenDimensions","setFromMatrixPosition","near","far","intersectSplatMesh","toLocal","fromLocal","sceneTransform","localRay","tempPoint","splatMesh","outHits","splatTree","getSplatTree","subTrees","subTree","dynamicMode","getSceneTransform","outHitsForSubTree","rootNode","castRayAtSplatTreeNode","hit","tempColor","tempCenter","tempHit","scaleEpsilon","uniformScaleMatrix","toSphereSpace","fromSphereSpace","tempRay","node","boundingBox","indexes","splatGlobalIndex","splatSceneIndex","getSceneIndexForSplat","getScene","splatRenderMode","uniformScale","log10","SplatMaterial","buildVertexShaderBase","enableOptionalEffects","maxSphericalHarmonicsDegree","customVars","vertexShaderSource","MaxScenes","getVertexShaderFadeIn","getUniforms","splatScale","pointCloudModeEnabled","fadeInComplete","orthographicMode","visibleRegionFadeStartRadius","visibleRegionRadius","currentTime","firstRenderTime","centersColorsTexture","sphericalHarmonicsTexture","sphericalHarmonicsTextureR","sphericalHarmonicsTextureG","sphericalHarmonicsTextureB","sphericalHarmonics8BitCompressionRangeMin","sphericalHarmonics8BitCompressionRangeMax","focal","orthoZoom","inverseFocalAdjustment","basisViewport","debugColor","centersColorsTextureSize","sphericalHarmonicsTextureSize","sphericalHarmonics8BitMode","sphericalHarmonicsMultiTextureMode","sceneIndexesTexture","sceneIndexesTextureSize","sceneCount","sceneOpacity","sceneVisibility","transformMatrices","SplatMaterial3D","build","antialiased","maxScreenSpaceSplatSize","buildVertexShaderProjection","fragmentShaderSource","buildFragmentShader","alphaTest","NormalBlending","SplatMaterial2D","referenceQuadGeneration","SplatGeometry","baseGeometry","BufferGeometry","setIndex","positionsArray","BufferAttribute","setAttribute","setXYZ","InstancedBufferGeometry","splatIndexArray","splatIndexes","InstancedBufferAttribute","setUsage","DynamicDrawUsage","instanceCount","SplatScene","copyTransformData","otherScene","updateTransform","matrixWorldAutoUpdate","updateWorldMatrix","updateMatrix","SplatTreeNode","depth","Box3","SplatSubTree","maxDepth","maxCentersPerNode","sceneDimensions","sceneMin","sceneMax","nodesWithIndexes","convertWorkerSubTreeNode","workerSubTreeNode","minVector","maxVector","convertedNode","convertWorkerSubTree","workerSubTree","convertedSubTree","visitLeavesFromNode","visitFunc","createSplatTreeWorker","self","WorkerSplatTreeNodeIDGen","WorkerBox3","containsPoint","WorkerSplatSubTree","addedIndexes","disposed","WorkerSplatTreeNode","processSplatTreeNode","tree","indexToCenter","sceneCenters","newIndexes","nodeDimensions","halfDimensions","nodeCenter","childrenBounds","splatCounts","baseIndexes","childNode","buildSubTree","centerCount","onmessage","process","allCenters","postMessage","createSplatTree","centers","SplatTree","diposeSplatTreeWorker","splatTreeWorker","terminate","processSplatMesh","filterFunc","onIndexesUpload","onSplatTreeConstruction","Worker","addCentersForScene","splatOffset","addedCount","addBase","checkForEarlyExit","scenes","transferBuffers","workerProcessCenters","countLeaves","leafCount","visitLeaves","WebGLExtensions","gl","getExtension","extension","init","capabilities","isWebGL2","WebGLCapabilities","maxAnisotropy","getMaxPrecision","precision","getShaderPrecisionFormat","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","WebGL2RenderingContext","maxPrecision","drawBuffers","logarithmicDepthBuffer","maxTextures","getParameter","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","getMaxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","floatVertexTextures","maxSamples","MAX_SAMPLES","dummyGeometry","dummyMaterial","MAX_TEXTURE_TEXELS","SplatMesh","halfPrecisionCovariancesOnGPU","devicePixelRatio","enableDistancesComputationOnGPU","integerBasedDistancesComputation","logLevel","sceneFadeInRateMultiplier","renderer","baseSplatTree","splatDataTextures","distancesTransformFeedback","program","centersBuffer","sceneIndexesBuffer","outDistancesBuffer","centersLoc","modelViewProjLoc","sceneIndexesLoc","transformsLocs","globalSplatIndexToSceneIndexMap","lastBuildSplatCount","lastBuildScenes","lastBuildMaxSplatCount","lastBuildSceneCount","finalBuild","webGLUtils","calculatedSceneCenter","maxSplatDistanceFromSceneCenter","visibleRegionBufferRadius","visibleRegionChanging","lastRenderer","setupIDMode","setupIDMaterialMode","uSetID","Number","buildScenes","parentObject","sceneOptions","scene","createScene","splatAlphaRemovalThreshold","buildSplatIndexMaps","localSplatIndexMap","sceneIndexMap","buildSplatTree","minAlphas","onSplatTreeIndexesUpload","disposeSplatTree","buildStartTime","splatColor","sceneIndex","minAlpha","buildTime","log","leavesWithVertices","avgSplatCount","nodeCount","nodeSplatCount","keepSceneTransforms","preserveVisibleRegion","getTotalMaxSplatCountForSplatBuffers","newScenes","newScene","existingScene","splatBufferSphericalHarmonicsDegree","splatBuffersChanged","isUpdateBuild","disposeMeshData","indexMaps","splatBufferSplatCount","setupDistancesComputationTransformFeedback","dataUpdateResults","refreshGPUDataFromSplatBuffers","onSplatTreeReadyCallback","freeIntermediateSplatData","deleteTextureData","texture","image","onUpdate","baseData","covariances","colors","centerColors","sceneIndexes","textures","disposeTextures","computeDistancesOnGPUSyncTimeout","clearTimeout","disposeDistancesComputationGPUResources","textureKey","textureContainer","onSplatTreeReady","callback","getDataForDistancesComputation","start","end","getIntegerCenters","getFloatCenters","getSceneIndexes","sinceLastBuildOnly","refreshDataTexturesFromSplatBuffers","updateStart","refreshGPUBuffersForDistancesComputation","to","updateGPUCentersBufferForDistancesComputation","updateGPUTransformIndexesBufferForDistancesComputation","updateBaseDataFromSplatBuffers","setupDataTextures","updateDataTexturesFromBaseData","updateVisibleRegion","computeDataTextureSize","elementsPerTexel","elementsPerSplat","texSize","getCovariancesInitialTextureSpecs","elementsPerTexelStored","getCovariancesElementsPertexelStored","covarianceCompressionLevel","getTargetCovarianceCompressionLevel","shCompressionLevel","getTargetSphericalHarmonicsCompressionLevel","initialCovTexSpecs","SphericalHarmonicsArrayType","shComponentCount","shData","centersColsTexSize","paddedCentersCols","updateCenterColorsPaddedData","centersColsTex","DataTexture","RGBAIntegerFormat","internalFormat","size","covTexSpecs","covariancesElementsPerTexelStored","covTexSize","covariancesElementsPerTexelAllocated","covariancesTextureData","covTex","updatePaddedCompressedCovariancesTextureData","covariancesTextureHalfFloat","FloatType","covariancesTexture","dummyTex","covariancesAreHalfFloat","covariancesTextureSize","elementsPerTexelAllocated","scaleRotationsTexSize","ScaleRotationsDataType","scaleRotationsTextureType","paddedScaleRotations","updateScaleRotationsPaddedData","scaleRotationsTex","scaleRotationsTexture","scaleRotationsTextureSize","shTextureType","UnsignedByteType","HalfFloatType","paddedSHComponentCount","shElementsPerTexel","texelFormat","RGFormat","shTexSize","paddedSHArray","shTexture","paddedComponentCount","textureCount","shComponentCountPerChannel","paddedSHArraySize","textureUniforms","paddedSHArrays","shTextures","componentCountPerChannel","sceneIndexesTexSize","paddedTransformIndexes","RedIntegerFormat","covarancesTextureDesc","scaleRotationsTextureDesc","scaleRotationCompressionLevel","shITextureDesc","fillSplatDataArrays","shTextureDesc","centerColorsTextureDescriptor","paddedCenterColors","centerColorsTexture","centerColorsTextureProps","__webglTexture","updateDataTexture","covarancesStartElement","covariancesEndElement","covariance","covariancesTextureProps","bytesPerElement","scaleRotationsTextureProps","shBytesPerElement","updateTexture","shTextureSize","shTextureProps","sceneIndexesTexDesc","paddedSceneIndexes","sceneIndexesTextureProps","getMaximumSplatBufferCompressionLevel","maxCompressionLevel","getMinimumSplatBufferCompressionLevel","minCompressionLevel","computeTextureUpdateRegion","endSplat","textureWidth","texelsPerSplat","startSplatTexels","startRow","startRowElement","endSplatTexels","endRow","dataStart","dataEnd","paddedData","textureSize","textureProps","getContext","updateRegion","updateElementCount","updateDataView","updateHeight","glType","convert","glFormat","colorSpace","currentTexture","TEXTURE_BINDING_2D","bindTexture","TEXTURE_2D","texSubImage2D","sourceData","textureData","textureDataStartIndex","fromElement","toElement","textureDataView","textureDataIndex","sequentialCount","setUint16","colorsBase","centersBase","centerColorsBase","arr","scaleRotationsBase","avgCenter","distFromCSceneCenter","updateVisibleRegionFadeDistance","sceneRevealMode","fastFadeRate","gradualFadeRate","defaultFadeInRate","fadeInRate","shaderFadeInComplete","updateRenderIndexes","globalIndexes","renderSplatCount","setDrawRange","updateTransforms","updateUniforms","renderDimensions","cameraFocalLengthX","cameraFocalLengthY","orthographicZoom","transforms","setSplatScale","getSplatScale","setPointCloudModeEnabled","getPointCloudModeEnabled","getSplatDataTextures","includeSinceLastBuild","getTotalSplatCountForScenes","getTotalSplatCountForSplatBuffers","getTotalMaxSplatCountForScenes","vao","deleteVertexArray","deleteProgram","deleteShader","disposeDistancesComputationGPUBufferResources","deleteTransformFeedback","deleteBuffer","setRenderer","WebGLUtils","currentMaxSplatCount","rebuildGPUObjects","rebuildBuffers","createShader","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","typeName","errors","getShaderInfoLog","vsSource","currentVao","VERTEX_ARRAY_BINDING","currentProgram","CURRENT_PROGRAM","currentProgramDeleted","getProgramParameter","DELETE_STATUS","createVertexArray","bindVertexArray","createProgram","attachShader","transformFeedbackVaryings","SEPARATE_ATTRIBS","linkProgram","LINK_STATUS","getProgramInfoLog","useProgram","getAttribLocation","getUniformLocation","createBuffer","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","vertexAttribIPointer","INT","vertexAttribPointer","FLOAT","UNSIGNED_INT","STATIC_READ","createTransformFeedback","bindTransformFeedback","TRANSFORM_FEEDBACK","bindBufferBase","TRANSFORM_FEEDBACK_BUFFER","isUpdate","offsetSplats","ArrayType","subBufferOffset","bufferSubData","maxArray","STATIC_DRAW","fillTransformsArray","tempArray","sceneTransformElements","computeDistancesOnGPU","modelViewProjMatrix","outComputedDistances","enable","RASTERIZER_DISCARD","iTempMatrix","getIntegerMatrixArray","iTransform","uniform4i","uniformMatrix4fv","iViewProjMatrix","iViewProj","uniform3i","viewProj","uniform3f","beginTransformFeedback","POINTS","drawArrays","endTransformFeedback","disable","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","checkSync","timeout","bitflags","clientWaitSync","TIMEOUT_EXPIRED","WAIT_FAILED","deleteSync","getBufferSubData","getLocalSplatParameters","globalIndex","paramsObj","returnSceneTransform","getSplatBufferForSplat","localIndex","getSplatLocalIndex","getSceneTransformForSplat","applySceneTransform","sphericalHarmonicsCompressionLevel","srcStart","srcEnd","destStart","tempTransform","startSceneIndex","endSceneIndex","padFour","floatCenters","intCenters","paddedFloatCenters","outTransform","getSceneCount","matrixElements","intMatrixArray","computeBoundingBox","applySceneTransforms","InfoPanel","container","infoCells","layout","infoPanelContainer","innerHTML","append","infoPanel","className","infoTable","display","layoutEntry","labelCell","classList","spacerCell","infoCell","cameraPosition","cameraLookAtPosition","cameraUp","orthographicCamera","meshCursorPosition","currentFPS","splatRenderCount","splatRenderCountPct","lastSortTime","focalAdjustment","pointCloudMode","cameraPosString","cla","cameraLookAtString","cameraLookAt","cameraUpString","cursPos","cursorPosString","cursorPosition","fps","renderWindow","sortTime","setContainer","parentElement","removeChild","zIndex","show","hide","LoadingProgressBar","tasks","progressBarContainerOuter","progressBarBox","progressBarBackground","progressBar","setProgress","progress","LoadingSpinner","message","taskIDGen","elementID","elementIDGen","spinnerContainerOuter","spinnerContainerPrimary","spinnerPrimary","messageContainerPrimary","spinnerContainerMin","spinnerMin","messageContainerMin","setMinimized","fadeTransitions","addTask","newTask","removeTask","task","removeAllTasks","setMessageForTask","setMessage","minimized","instant","showHideSpinner","displayStyle","fadeTransitionsIndex","out","duration","onComplete","startTime","startOpacity","parseFloat","isNaN","interval","setInterval","elapsed","clearInterval","fadeElement","ARButton","createButton","sessionInit","disableButton","cursor","onmouseenter","onmouseleave","onclick","stylizeElement","padding","border","borderRadius","background","font","textAlign","outline","xr","isSessionSupported","supported","domOverlay","overlay","svg","createElementNS","currentSession","optionalFeatures","root","onSessionStarted","session","onSessionEnded","setReferenceSpaceType","setSession","textContent","requestSession","offerSession","err","showStartAR","exception","isSecureContext","location","replace","textDecoration","VRButton","sessionOptions","showEnterVR","xrSessionIsGranted","registerSessionGrantedListener","test","WebXRMode","VR","AR","SorterWasmNoSIMD","sortWorker","wasmInstance","wasmMemory","useSharedMemory","integerBasedSort","indexesToSortOffset","sortedIndexesOffset","sceneIndexesOffset","transformsOffset","precomputedDistancesOffset","mappedDistancesOffset","frequenciesOffset","centersOffset","modelViewProjOffset","countsZero","sortedIndexesOut","distanceMapRange","uploadedSplatCount","BytesPerInt","BytesPerFloat","renderCount","sortCount","splatSortCount","usePrecomputedDistances","copyIndexesToSort","copyPrecomputedDistances","copyTransforms","indexesToSort","precomputedDistances","modelViewProj","sortStartTime","exports","sortIndexes","sortMessage","sortDone","sortedIndexes","sortEndTime","CENTERS_BYTES_PER_ENTRY","sorterWasmBytes","matrixSize","memoryRequiredForIndexesToSort","memoryRequiredForCenters","memoryRequiredForModelViewProjectionMatrix","memoryRequiredForPrecomputedDistances","memoryRequiredForMappedDistances","memoryRequiredForSortedIndexes","memoryRequiredForIntermediateSortBuffers","memoryRequiredforTransformIndexes","memoryRequiredforTransforms","extraMemory","MemoryPageSize","totalRequiredMemory","totalPagesRequired","sorterWasmImport","module","env","memory","WebAssembly","Memory","initial","maximum","shared","compile","wasmModule","instantiate","instance","sortSetupPhase1Complete","indexesToSortBuffer","sortedIndexesBuffer","precomputedDistancesBuffer","transformsBuffer","Viewer","initialCameraPosition","initialCameraLookAt","dropInMode","selfDrivenMode","selfDrivenUpdateFunc","selfDrivenUpdate","useBuiltInControls","rootElement","ignoreDevicePixelRatio","gpuAcceleratedSort","sharedMemoryForWorkers","dynamicScene","webXRMode","webXRActive","webXRSessionInit","renderMode","enableSIMDInSort","inMemoryCompressionLevel","semver","splatSortDistanceMapPrecision","DefaultSplatSortDistanceMapPrecision","onSplatMeshChangedCallback","createSplatMesh","controls","perspectiveControls","orthographicControls","perspectiveCamera","showMeshCursor","showControlPlane","showInfo","sceneHelper","sortRunning","lastSplatSortCount","sortWorkerIndexesToSort","sortWorkerSortedIndexes","sortWorkerPrecomputedDistances","sortWorkerTransforms","preSortMessages","runAfterNextSort","selfDrivenModeRunning","splatRenderReady","raycaster","startInOrthographicMode","consecutiveRenderFrames","previousCameraTarget","nextCameraTarget","mousePosition","mouseDownPosition","mouseDownTime","resizeObserver","mouseMoveListener","mouseDownListener","mouseUpListener","keyDownListener","sortPromise","sortPromiseResolver","splatSceneDownloadPromises","splatSceneDownloadAndBuildPromise","splatSceneRemovalPromise","loadingSpinner","loadingProgressBar","usingExternalCamera","usingExternalRenderer","initialized","disposing","disposePromise","opts","unprojectMousePosition","unprojectPositionFromSplats","frustumCulled","setupCamera","setupRenderer","setupWebXR","setupControls","setupEventHandlers","Scene","getRenderDimensions","PerspectiveCamera","WebGLRenderer","antialias","setPixelRatio","autoClear","setClearColor","setSize","ResizeObserver","forceRenderNextFrame","observe","onMouseUp","removeEventHandlers","setRenderMode","setActiveSphericalHarmonicsDegrees","activeSphericalHarmonicsDegrees","onSplatMeshChanged","forward","tempMatrixLeft","tempMatrixRight","makeRotationAxis","setOrthographicMode","offsetX","offsetY","clickOffset","onMouseClick","checkForFocalPointChange","toNewFocalPoint","transitioningCameraTarget","intersectionPoint","transitioningCameraTargetStartTime","getSize","outDimensions","offsetWidth","offsetHeight","fromCamera","resetControls","fromControls","toControls","setCameraZoomFromPosition","setCameraPositionFromZoom","tempVector","positionCamera","zoomedCamera","toLookAtDistance","negate","zoomCamera","positionZamera","updateSplatMesh","focalLengthX","projectionMatrix","focalLengthY","focalMultiplier","adjustForWebXRStereo","xrCameraProj00","getCamera","cameraProj00","isLoadingOrUnloading","isDisposingOrDisposed","addSplatSceneDownloadPromise","removeSplatSceneDownloadPromise","setSplatSceneDownloadAndBuildPromise","clearSplatSceneDownloadAndBuildPromise","addSplatScene","progressiveLoad","isProgressivelyLoadable","showLoadingUI","loadingUITaskId","onProgressUIUpdate","percentCompleteLabel","loaderStatus","suffix","downloadDone","downloadedPercentage","splatBuffersAddedUIUpdate","firstBuild","downloadAndBuildSingleSplatSceneProgressiveLoad","downloadAndBuildSingleSplatSceneStandardLoad","addSplatBufferOptions","orientation","addSplatBuffers","buildFunc","onException","downloadPromise","downloadSplatSceneToSplatBuffer","downloadAndBuildPromise","onDownloadProgress","onDownloadException","progressiveLoadedSectionBuildCount","progressiveLoadedSectionBuilding","queuedProgressiveLoadSectionBuilds","checkAndBuildProgressiveLoadSections","queuedBuild","shift","progressiveLoadFirstSectionBuildPromise","splatSceneDownloadPromise","addSplatScenes","fileCount","onLoadProgress","fileIndex","totalPercent","baseDownloadPromises","nativeDownloadPromises","baseDownloadPromise","finally","progressiveBuild","splatBufferOptions","showLoadingUIForSplatTreeBuild","replaceExisting","enableRenderBeforeFirstSort","splatProcessingTaskId","removeSplatProcessingTask","buildResults","addSplatBuffersToMesh","disposeSortWorker","setupSortWorker","runSplatSort","splatOptimizingTaskId","allSplatBuffers","allSplatBufferOptions","finished","DistancesArrayType","worker","sourceWasm","iOSSemVer","sorterWasmBinaryString","atob","charCodeAt","createSortWorker","sortCanceled","removeSplatScene","indexToRemove","removeSplatScenes","indexesToRemove","revmovalTaskId","checkAndHideLoadingUI","onDone","savedSplatBuffers","savedSceneOptions","savedSceneTransformComponents","shouldRemove","setAnimationLoop","requestFrameId","requestAnimationFrame","stop","cancelAnimationFrame","waitPromises","promisesToAbort","promiseKey","downloadPromiseToAbort","unobserve","toAbort","shouldRender","render","renderNextFrame","lastCameraPosition","lastCameraOrientation","changeEpsilon","cameraChanged","cp","co","savedAuoClear","hasRenderables","updateForDropInMode","updateForRendererSizeChanges","updateMeshCursor","updateFPS","timingSensitiveUpdates","updateInfoPanel","updateControlPlane","lastCalcTime","frameCount","lastRendererSize","currentRendererSize","lastCameraOrthographic","aspect","lastUpdateTime","timeDelta","updateCameraTransition","tempCameraTarget","toPreviousTarget","toNextTarget","rotationAngle","wasTransitioning","currentFocusMarkerOpacity","newFocusMarkerOpacity","mvpMatrix","cameraPositionArray","lastSortViewDir","sortViewDir","lastSortViewPos","sortViewOffset","queuedSorts","partialSorts","angleThreshold","sortFractions","force","forceSortAll","angleDiff","positionDiff","needsRefreshForRotation","needsRefreshForPosition","shouldSortAll","gatherSceneNodesForSort","mvpCamera","gpuAcceleratedSortPromise","partialSort","sortFraction","nodeRenderList","allSplatsSortBuffer","tempVectorYZ","tempVectorXZ","modelView","baseModelView","tempMax","nodeSize","gatherAllNodes","cameraFocalLength","fovXOver2","atan","fovYOver2","cosFovXOver2","cosFovYOver2","nodeRenderCount","distanceToNode","setX","setY","cameraAngleXZDot","cameraAngleYZDot","ns","currentByteOffset","windowSizeInts","windowSizeBytes","getSplatMesh","getSplatScene","isMobile","DropInViewer","Group","callbackMesh","createCallbackMesh","onBeforeRender","setupIDMeshMode","colorWrite","mesh"],"mappings":"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,KAG1EwrB,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,IACE,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,IAEpBC,GAAmB,CACvB,UACA,UACA,UACA,QACA,QACA,QACA,QACA,IACA,IACA,IACA,SACA,SACA,SACA,UACA,MACA,QACA,OACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,aAEIC,GAAsBD,GAAiBtR,KAAI,CAACuF,EAAGhgB,IAAMA,KAGzDisB,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,IACEd,GAEEe,GAAUJ,GACVK,GAAYJ,GACZK,GAAWJ,GAEX5qB,GAAiBirB,IACrB,MAAMhQ,GAAK,MAAQgQ,IAAO,GACpB5P,EAAI,KAAO4P,EACjB,OACGA,GAAM,IAAM,EAAI,IAChBhQ,EACO,KAANA,EACEI,EACE6P,IACA,IACFryB,KAAKsyB,IAAI,EAAGlQ,EAAI,KAAO,EAAII,EAAI,MAChCA,EAAI,KAAQ,eACf,EAGG,MAAM+P,GACX,WAAAv3B,GACEK,KAAKozB,eAAiB,IAAIpF,EAC3B,CAED,mCAAAmJ,CAAoCnP,GAClC,MAAMkG,EAAiB2H,GAAoBhC,QAAO,CAACC,EAAKzM,KACtDyM,EAAI8B,GAAiBvO,IAAYA,EAC1ByM,IACN,CAAE,GAECsD,EAA6BhC,GAA6BvB,QAC9D,CAACC,EAAKzM,KACJyM,EAAIqB,GAAyB9N,IAAYA,EAClCyM,IAET,CAAE,GAGErD,EAAezC,GAAewC,sBAAsBxI,GAC1D,IAAIqP,EACJ,IAAK,IAAI/U,EAAI,EAAGA,EAAImO,EAAatsB,OAAQme,IAAK,CAExB,qBADAmO,EAAanO,KAE/B+U,EAAuB/U,EAE1B,CAED,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"}